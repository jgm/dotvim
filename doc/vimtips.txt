*vimtips.txt*
This file comes from the Vim Online tip database.
These tips were downloaded on Thu, 27 Jan 2005 19:58:29 -0800
:set foldmethod=marker

VimTip	{{{1 1: the super star


When a discussion started about learning vim on the vim list Juergen Salk mentioned the "*" key as something that he wished he had know earlier. When I read the mail I had to go help on what the heck the "*" did. I also wish I had known earlier...

Using the "*" key while in normal mode searches for the word under the cursor.

If that doesn't save you a lot of typing, I don't know what will.






VimTip	{{{1 2: easy edit of files in the same directory


It was often frustrating when I would open a file deep in the code tree and then realize I wanted to open another file in that same directory. Douglas Potts taught me a nice way to do this. Add the following snipit to your vimrc:

"   Edit another file in the same directory as the current file
"   uses expression to extract path from current file's path
"  (thanks Douglas Potts)
if has("unix")
    map ,e :e <C-R>=expand("%:p:h") . "/" <CR>
else
    map ,e :e <C-R>=expand("%:p:h") . "\" <CR>
endif

Then when you type ,e in normal mode you can use tab to complete to the file. You can also expand this to allow for spitting, etc. Very very nice.






VimTip	{{{1 3: use vim to quickly compile java files


For a number of years I used vim on an SGI box. When I left my job at SGI I went to a company that developed on PCs. For 2 years I used IDEs. I was unhappy. I was frustrated. I couldn't figure out why. (Beyond my machine crashing twice a day.) Finally I upgraded to windows 2000 (kind of stable!) and started using vim as an IDE. All was good. Here is how you use vim to compile your java:

1. While I'm sure this works with javac, javac is slow slow slow. So download the Jikes complier first. (Jikes is from ibm, search on google for jikes and you will find it..available on most platforms.)

2. Add the following to your vimrc:

set makeprg=jikes -nowarn -Xstdout +E %
set errorformat=%f:%l:%c:%*\d:%*\d:%*\s%m 

3. When you are editing a java file type :make and it will compile the current file and jump you to the first error in the file (if any). Read ":help quickfix" for how to move between errors.

To setup your classpath environment either launch gvim from a shell that has your classpath/path setup or use the "let" command to configure it in your vimrc.






VimTip	{{{1 4: Any word completion


Either when programming or writing, I tend to have some identifiers or words that I use all the time. By sheer accident, I noticed the 'ctrl-n' command, that will attempt to complete the word under the cursor. Hit it once, and it will try to complete it with the first match in the current file. If there is no match, it will (at least in the case of C code) search through all files included from the current one. Repeated invocations will cycle through all found matches.






VimTip	{{{1 5: Quickly searching for a word



To search for a word under the cursor in the current file you
can use either the "*" or "#" keys.

The "*" key will search for the word from the current cursor 
position to the end of the file. The "#" key will search for the 
word from the current cursor position to the top of the file.

Note that the above two keys will search for the whole word and not
the partial word.  This is equivalent to using the <word> pattern
in the search commands (/ and ?).

To search for partial matches, you can use the "g*" and "g#" key
sequence.

You can also use the mouse to search for a word.  This will only
work in the GUI version of VIM (gvim) or a console version
of VIM in an xterm which accepts a mouse. Also, the 'mousemodel'
should be set to 'extend'.  Add the following line to your .vimrc:

set mousemodel=extend

To search for a word under the cursor from the current cursor
position to the end of the file, press the shift key and click
on the word using the left mouse button.  To search in the opposite
direction, press the shift key and click on the word using the
the right mouse button.

To get more help on these, use

:help *
:help #
:help g*
:help g#
:help <S-LeftMouse>
:help <S-RightMouse>







VimTip	{{{1 6: Using the % key



The % key can be used

1. To jump to a matching opening or closing parenthesis, square 
   bracket or a curly brace i.e. ([{}])
2. To jump to start or end of a C-style comment /* */.  
3. To jump to a matching #if, #ifdef, #else, #elif, #endif C 
   preprocessor conditionals.

To get more information about this, do

             :help %

The % key can be extended to support other matching pairs by
modifying the "matchpairs" option.  Read the help on

             :help matchpairs







VimTip	{{{1 7: Jumping to the start and end of a code block



To jump to the beginning of a C code block (while, switch, if etc),
use the [{ command.

To jump to the end of a C code block (while, switch, if etc),
use the ]} command.

The above two commands will work from anywhere inside the code
block.

To jump to the beginning of a parenthesis use the [( command.

To jump to the end of a parenthesis use the ]) command.

To get more help on these commands, do

:help [{
:help ]}
:help [(
:help ])







VimTip	{{{1 8: Jumping to the declaration of a local/global variable



'gd' command: 
To jump to the declaration of a local variable in a C program, 
position the cursor on the name of the variable and use the
gd command.

'gD' command:
To jump to the declaration of a global variable in a C program, 
position the cursor on the name of the variable and use the
gD command.






VimTip	{{{1 9: Displaying a variable/macro definition



To display the definition of a variable, place the cursor on the
variable and use the [i command.  To display a macro definition,
place the cursor on the macro name and use the [d command.
Note that these commands will work most of the time (not all the
time).  To get more help on these commands, use

:help [i
:help [d






VimTip	{{{1 10: Jumping to previosuly visited locations in a file



Vim remembers all the locations visited by you in a file in a session.
You can jump to the older locations by pressing the Ctrl-O key.  You
can jump to the newer locations by pressing the Ctrl-I or the <Tab>
key.

To get more help on these keys, use

:help CTRL-O
:help CTRL-I
:help jump-motions







VimTip	{{{1 11: Completing words quicky in insert mode



In Insert mode, press the Ctrl-p or Ctrl-n key to complete part of 
a word that has been typed.

This is useful while typing C programs to complete long variable and
function names.  This also helps in avoiding typing mistakes.

Note that using the 'complete' option, you can complete keywords
defined in one of the include files, tag file, etc.

To get more help on this, use

:help i_Ctrl-N
:help i_Ctrl-P
:help ins-completion
:help complete







VimTip	{{{1 12: Converting tabs to spaces



To insert space characters whenever the tab key is pressed, set the
'expandtab' option:

        set expandtab

With this option set, if you want to enter a real tab character use
Ctrl-V<Tab> key sequence.

To control the number of space characters that will be inserted when
the tab key is pressed, set the 'tabstop' option.  For example, to
insert 4 spaces for a tab, use:

        set tabstop=4

After the 'expandtab' option is set, all the new tab characters entered
will be changed to spaces.  This will not affect the existing tab
characters.  To change all the existing tab characters to match the
current tab settings, use

        :retab

To change the number of space characters inserted for indentation, use
the 'shiftwidth' option:

        set shiftwidth=4

For example, to get the following coding style,
        - No tabs in the source file
        - All tab characters are 4 space characters

use the following set of options:

        set tabstop=4
        set shiftwidth=4
        set expandtab

Add the above settings to your .vimrc file.

To get more help on these options, use
:help tabstop
:help shiftwidth
:help expandtab







VimTip	{{{1 13: Incremental search



To move the cursor to the matched string, while typing the search
string, set the following option in the .vimrc file:

        set incsearch

You can complete the search by pressing the Enter key.  To cancel
the search, press the escape key.







VimTip	{{{1 14: Highlighting all the search pattern matches



To highlight all the search pattern matches in a file set the
following option:

        :set hlsearch

After this option is set, if you search for a pattern, all the
matches in the file will be highlighted in yellow.

To disable the highlighting temporarily, use the command

        :nohlsearch

This command will remove the highlighting for the current search.
The highlighting will come back for the next search.

To disable the highlighting completely, set the following option:

        :set nohlsearch

By default, the hlsearch option is turned off.

To get more help on this option, use

:help 'hlsearch'
:help :nohlsearch







VimTip	{{{1 15: Displaying status line always



To display the status line always, set the following option in
your .vimrc file:

        set laststatus=2

The advantage of having the status line displayed always is, you
can see the current mode, file name, file status, ruler, etc.

To get more help on this, use

:help laststatus







VimTip	{{{1 16: Avoiding the "Hit ENTER to continue" prompts



To avoid the "Hit ENTER to continue" prompt, use the 'shortmess'
option.  Add the following line to your .vimrc file:

    set shortmess=a

Also, you can increase the height of the command line to 2

    set cmdheight=2

The default command height is 1.

To get more help on these options, use

:help hit-enter
:help shortmess
:help cmdheight







VimTip	{{{1 17: Erasing previosuly entered characters in insert mode



In insert mode, to erase previously entered characters, set the
following option:

        set backspace=2

By default, this option is empty.  If this option is empty, in
insert mode, you can not erase characters entered before this
insert mode started.  This is the standard Vi behavior.

To get more help on this, use

:help 'backspace'







VimTip	{{{1 18: Cleanup your HTML


From Johannes Zellner on the vim list:

You can use vim's makeprg and equalprg to clean up HTML. First download html tidy from http://www.w3.org/People/Raggett/tidy/. Then use the following commands.

vim6?
exe 'setlocal equalprg=tidy -quiet -f '.&errorfile
setlocal makeprg=tidy -quiet -e %

vim5?
exe 'set equalprg=tidy -quiet -f '.&errorfile
set makeprg=tidy -quiet -e %

At this point you can use make to clean up the full file or you can use = to clean up sections.

:help =
:help equalprg
:help makeprg








VimTip	{{{1 19: line numbers...


I have started doing all my code reviews on a laptop because of the number command.

:set number will put line numbers along the left side of a window

:help number






VimTip	{{{1 20: Are *.swp and *~ files littering your working directory?


Have you ever been frustrated at swap files and backups cluttering
up your working directory? 

Untidy:
  ons.txt
  ons.txt~
  README
  README~
  tester.py
  tester.py~

Here are a couple of options that can help:

  set   backupdir=./.backup,.,/tmp
  set   directory=.,./.backup,/tmp

This way, if you want your backups to be neatly grouped, just 
create a directory called '.backup' in your working directory. 
Vim will stash backups there. The 'directory' option controls
where swap files go. If your working directory is not writable,
Vim will put the swap file in one of the specified places.






VimTip	{{{1 21: easy pasting to windows apps


In Vim, the unnamed register is the " register, and the Windows
Clipboard is the * register. This means that if you yank something,
you have to yank it to the * register if you want to paste it into
a Windows app. If this is too much trouble, set the 'clipboard' 
option to 'unnamed'. Then you always yank to *.

So pasting to windows apps doesn't require prefixing "* :

  set   clipboard=unnamed







VimTip	{{{1 22: handle common typos for :commands


I frequently hold the shift key for too long when typing, for instance :wq, and end up with :Wq.  Vim then whines "Not an editor command: Wq"

In my .vimrc, I have taught vim my common typos:
command! Q  quit
command! W  write
command! Wq wq
" this one won't work, because :X is already a built-in command
command! X  xit






VimTip	{{{1 23: Vim xterm title


Check out your .vimrc. If 'set notitle' is an entry, comment it out with a quotation mark ("). Now your xterm should inherit the title from Vim.            e.g. 'Vim - ~/.vimrc'. This can be quite nice when programming and editing lots of files at the same time.
by [jonasbn@wanadoo.dk]






VimTip	{{{1 24: changing the default syntax highlighting


     Here are some pointers to the vim documentation.  Notice that the mechanism is different in vim 6.0 and vim 5.x.

1. I want *.foo files to be highlighted like HTML files.

:help new-filetype  http://www.vim.org/html/autocmd.html#new-filetype

2. I want to define a syntax file for *.bar files.  Read the above and also

:help mysyntaxfile  http://www.vim.org/html/syntax.html#mysyntaxfile

3. I want to make a few changes to the existing syntax highlighting.  Depending on the x in 5.x, either read the above and page down a few screens, or you may be able to skip right to

:help mysyntaxfile-add  http://www.vim.org/html/syntax.html#mysyntaxfile-add

4. I want to change some of the colors from their defaults.  Again, read

:help mysyntaxfile  http://www.vim.org/html/syntax.html#mysyntaxfile






VimTip	{{{1 25: color highlighting on telnet (esp w/ SecureCRT)


The following settings in .vimrc will enable color highlighting when using SecureCRT and may work on other telnet packages. The terminal type should be selected as ANSI and color enabled.


if !has("gui_running")
set t_Co=8
set t_Sf=^[[3%p1%dm
set t_Sb=^[[4%p1%dm
endif


The ^[ is entered as "<ctrl-v><esc>" 








VimTip	{{{1 26: Getting rid of ^M - mixing dos and unix


If you work in a mixed environment you will often open files that have ^M's in them. An example would be this:

------------------------------------------------------------------
import java.util.Hashtable; ^M
import java.util.Properties; ^Mimport java.io.IOException;
import org.xml.sax.AttributeList; ^M
import org.xml.sax.HandlerBase; ^Mimport org.xml.sax.SAXException;

/**^M
  * XMLHandler: This class parses the elements contained^M
  * within a XML message and builds a Hashtable^M

[snip]
------------------------------------------------------------------

Notice that some programs are not consistent in the way they insert the line breaks so you end up with some lines that have both a carrage return and a ^M and some lines that have a ^M and no carrage return (and so blend into one). There are two steps to clean this up.

1. replace all extraneous ^M:

:%s/^M$//g

BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT M"! This expression will replace all the ^M's that have carriage returns after them with nothing. (The dollar ties the search to the end of a line)

2. replace all ^M's that need to have carriage returns:

:%s/^M//g

Once again: BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT M"! This expression will replace all the ^M's that didn't have carriage returns after them with a carriage return.

Voila! Clean file. Map this to something if you do it frequently.

:help ffs - for more info on file formats

thanks to jonathan merz, douglas potts, and benji fisher







VimTip	{{{1 27: Convert hex to dec


when you check the output of objdump, you'll confused by the $0xFFFFFFc operand, this function translate the hexcamal to decimal.
function! Hex2Dec()
    let lstr = getline(".")
    let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    while hexstr != ""
        let hexstr = hexstr + 0
        exe 's#0x[a-f0-9]+#'.hexstr."#"
        let lstr = substitute(lstr, '0x[a-f0-9]+', hexstr, "")
        let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    endwhile
endfunction
usage:
5,8call Hex2Dec()







VimTip	{{{1 28: add a line-number to every line without cat or awk alike utilities.


With Unix-like environment, you can use cat or awk to generate a line number easily, because vim has a friendly interface with shell, so everything work in vim as well as it does in shell.
:%!call -n
or
:%!awk '{print NR,$0}'

But, if you use vim in MS-DOS, of win9x, win2000, you loss these tookit.
here is a very simple way to archive this only by vim:
fu! LineIt()
  exe ":s/^/".line(".")."/"
endf

Well, a sequence composed with alphabet is as easy as above:
  exe "s/^/".nr2char(line("."))."/"







VimTip	{{{1 29: reverse all the line with only 7 keystroke in vim


:g/^/m0
well, 
1. : bring you to command-line mode(also known as ex-mode) from normal-mode(also known as command mode).
2. g means you'll take an action through the whole file, generally perform a search, `v' also perform a search but it match the line not match the canonical expression.
3. / begins the regular express
4. ^ is a special character respect the start of a line.
5. the second / ends the regular express and indicate that the remains is action to do.
6. m means move, `t` and `co' for copy, `d' for delete
7. 0 is the destination line.

you can use 
:g/regexp/t$
to filter all lines and pick the match line together and copy them to the end of the buffer or
:g/regexp/y A
to put them into a register(not eax, ebx...)






VimTip	{{{1 30: Increasing or decreasing numbers


To increase a number under or nearest to the right of the cursor, go to Normal mode and type:
    Ctrl-A

To decrease, type:
    Ctrl-X

Using this in a macro simplifies generating number sequences a lot.







VimTip	{{{1 31: Find and Replace


To find and replace one or more occurences of a given text pattern with a
new text string, use the s[ubstitute] command.

There are a variety of options, but these are what you most probably want:

:%s/foo/bar/g           find each occurance of 'foo' and replace it with 'bar' without asking for confirmation

:%s/foo/bar/gc          find each occurance of 'foo' and replace it with 'bar' asking for confirmation first

:%s/<foo>/bar/gc      find (match exact word only) and replace each occurance of 'foo' with 'bar'

:%s/foo/bar/gci         find (case insensitive) and replace each occurance of 'foo' with 'bar'

:%s/foo/bar/gcI         find (case sensitive) and replace each occurance of 'foo' with 'bar'


NB: Without the 'g' flag, replacement occurs only for the first occurrence in each line.

For a full description and some more interesting examples of the substitute command refer to

:help substitute

See also:

:help cmdline-ranges
:help pattern
:help gdefault







VimTip	{{{1 32: Write your own vim function(scripts)


compare to C and shell(bash), herein is some vim specifics about vim-script:
1. A function name must be capitalized.
   hex2dec is invalid
   Hex2dec is valid
   while in c and shell(bash), both lowercase and uppercase is allowed.
2. how to reference the parameters
   fu! Hex2dec(var1, var2)
    let str=a:var1
    let str2=a:var2
   you must prefix the parameter name with "a:", and a:var1 itself is read-only
   in c, you reference the parameter directly and the parameter is writable.
3. how to implement variable parameter
   fu! Hex2dec(fixpara, ...)
     a:0 is the real number of the variable parameter when you invoke the function, with :Hex2dec("asdf", 4,5,6), a:0=3, and a:1=4 a:2=5 a:3=6
   you can combine "a:" and the number to get the value
   while i<a:0
     exe "let num=a:".i
     let i=i+1
   endwhile
   in c, the function get the real number by checking the additional parameter such as printf family, or by checking the special value such as NULL
4. where is the vim-library
  yes, vim has its own function-library, just like *.a in c
  :help functions
5. can I use += or ++ operator?
  Nop, += and ++ (and -=, -- and so on)operator gone away in vim.
6. How can I assign a value to a variables and fetch its value?
   let var_Name=value
   let var1=var2
   like it does in c, except you must use let keyword
7. Can I use any ex-mode command in a function?
  As I know, yes, just use it directly, as if every line you type appears in the familar : 
8. Can I call a function recurse?
  Yes, but use it carefully to avoid infinte call.
9. Can I call another function in a function?
  Course, like C does.
10. Must I compile the function?
   No, you needn't and you can't, just :so script_name, after this you can call the function freely.
11. Is it has integer and char or float data type?
   No, like perl, vim script justify the variable type depend upon the context
   :let a=1
   :let a=a."asdf"
   :echo a
   you'll get `1asdf'
   :let a=1
   :let a=a+2
   :echo a
   you'll get 3
   But it differs from perl.
12. Must I append a `;' in every statement?
   No, never do that.
   ; is required in C, and optional in shell for each statement in a alone line.
   But is forbidden in vim.
   if you want combine servals statement in one single line, use `|'.
   Take your mind that every statement appears in function should be valid in ex-mode(except for some special statement).






VimTip	{{{1 33: toggle off the line-number when enter on-line help


I like the line-number for myself editing. But I hate it in on-line help page because it force the screen wrapped.
:au filetype help :se nonu







VimTip	{{{1 34: control the position of the new window


:se splitbelow 
make the new window appears below the current window.
:se splitright
make the new window appears in right.(only 6.0 version can do a vsplit)






VimTip	{{{1 35: For programmer: translate // style comment to /*  */and vice vesa


the `|' concatenate servals ex-command in one line.
It's the key to translate // style comments to /* */ style
:g#^s{-}//#s##/*# | s#$#*/#

the `|' keep the current line matchs ^s{-}// to perform s#$#*/

/* ... */ ---> //style
:g#/*(.{-})*/#//1#

/* ....
   ....
   .....
*/ 
=====> 
//......
//......
//......
style:
? Anyone implement it?






VimTip	{{{1 36: Using Gnu-info help in vim


K in normal bring you the man page about the keyword under current cursor.
:nnoremap <F1> :exe ":!info ".expand("<cword>")
Now press F1 while the cursor is hold by a keyword such as printf will bring you to Gnu-info help page
:h <F1>
:h nnoremap






VimTip	{{{1 37: The basic operation about vim-boolean optionals


:set number
switch the number on
:set nonumber
switch it off
:set invnumber 
or 
:set number!
switch it inverse against the current setting
:set number&
get the default value vim assums.

replace number with any legal vim-boolean optionals, they all works well.
for vim-non-boolean optionals
:set optional& 
also works properly.







VimTip	{{{1 38: Cursor one line at a time when :set wrap


If your tierd of the cursor jumping past 5 lines when :set wrap then add these mappings to you vimrc file.

nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

What they do is remap the cursor keys to use there `g' equvilant. See :help gj






VimTip	{{{1 39: Undo and Redo


To undo recent changes, use the u[ndo] command:

u              undo last change (can be repeated to undo preceding commands)
U              return the line to its original state (undo all changes in current line)
CTRL-R         Redo changes which were undone (undo the undo's).

For a full description of the undo/redo commands refer to

:help undo







VimTip	{{{1 40: Insert a file


To insert the contents of a file (or the output of a system command) 
into the current buffer, use the r[ead] command:

Examples:

:r foo.txt        inserts the file foo.txt below the cursor

:0r foo.txt       inserts the file foo.txt above the first line

:r !ls            inserts a listing of your directory below the cursor

:$r !pwd          inserts the current working directory below the last line 


For more information about the r[ead] command refer to:

:help read

See also:

:help cmdline-ranges
:help !cmd








VimTip	{{{1 41: Command-history facilities for Oracle/sqlplus user


	First of all, thanks Benji fisher,  Stefan Roemer...
and others in vim@vim.org which spend much time to 
answer questions, sometimes foolish question asked by
someone like me. Without their I can't get the final 
solution for my sqlplus work descripted follows.
	As Oracle user known, sqlplus has a very bad 
command-line edition environment. It has no 
command-history, don't support most of getline 
facilities. which MySQL and shell does it well. 
Even Microsoft recogonize this point. In Windows2000, 
doskey is installed by default.
	Below is my vim-solution to sqlplus, which 
record the command-history when you use 
edit(sqlplus builtin command) to open the editor
specified by EDITOR environment variable. It saves
the SQL statement into a standalone file such as
.sqlplus.history
	Every time you open the file 
afiedt.buf(sqlplus's default command-buffer file), 
you get two splited windows, the buffer above is 
afiedt.buf, the buffer below is .sqlplus.history, 
you can see every SQL statement in the windows. 
If you want to use SQL statement in line 5 to replace
 the current command-buffer, just press 5K, then 
	:xa
	to back to you sqlplus. and use / to repeat the command
 saved in command-buffer file called afiedt.buf by default.
	It can't process multi-line SQL statement convinencely.
 Todo this, just use you favorite vim trick to do that:
	fu! VimSQL()
    nnoremap <C-K> :<C-U>
	exe "let linenum=".v:count<CR>:1,$-1d<CR><C-W>j:exe lin
	enum."y"<CR><C-W>kP
    let linenum=line("$")
    1,$-1w! >> ~/.sqlplus.history
    e ~/.sqlplus.history
    execute ":$-".(linenum-1).",$m0"
    %!uniq
    if line("$")>100
      101,$d
    endif
    b#
    set splitbelow
    sp ~/.sqlplus.history
    au! BufEnter afiedt.buf
endf
au BufEnter afiedt.buf call VimSQL()







VimTip	{{{1 42: Using marks


To mark one or more positions in a file, use the m[ark] command.

Examples:

ma       -    set current cursor location as mark a

'a       -    jump to beginning of line of mark a

`a       -    jump to postition of mark a

d'a      -    delete from current line to line of mark a

d`a      -    delete from current cursor position to mark a

c'a      -    change text from current line to line of mark a

y`a      -    yank text to unnamed buffer from cursor to mark a

:marks   -    list all the current marks

NB: Lowercase marks (a-z) are valid within one file. Uppercase marks
(A-Z), also called file marks, are valid between files.

For a detailed description of the m[ark] command refer to

:help mark

See also:

:help various-motions 






VimTip	{{{1 43: Using abbreviations


To define abbreviations, use the ab[breviate] command.

Examples:

:ab rtfm read the fine manual  -  Whenever you type 'rtfm' followed by a <space> (or <esc> or <cr>) vim
                                  will expand this to 'read the fine manual'.

:ab                            -  list all defined abbreviations

:una[bbreviate] rtfm           -  remove 'rtfm' from the list of abbreviations

:abc[lear]                     -  remove all abbreviations


NB: To avoid expansion in insert mode, type CTRL-V after the last character of the abbreviation. 

For a detailed description of the ab[breviate] command and some more examples refer to

:help abbreviations







VimTip	{{{1 44: Repeat last changes


Simple text changes in normal mode (e.g. "dw" or "J") can be repeated with the "." command.
The last command-line change (those invoked with ":", e.g. ":s/foo/bar") can be 
repeated with the "@:" command.

For more informations about repeating single changes refer to:

:help single-repeat






VimTip	{{{1 45: Using command-line history


You can recall previous command lines from a history table by hitting 
the <Up> and <Down> cursor keys in command-line mode. 
For example, this can be used to find the previous substitute command: 
Type ":s" and then <Up>.

There are separate history tables for the ':' commands and for 
previous '/' or '?' search strings.

To display the history of last entered commands or search strings, 
use the :his[tory] command:

:his       -      Display command-line history. 

:his s     -      Display search string history.

  
For a detailed description of the command-line history refer to:

:help cmdline-history

See also:

:help Cmdline-mode







VimTip	{{{1 46: Win32 binaries with perl, python, and tcl


> Does anyone know if windows binaries of vim 5.7 are available with perl and
> python support turned on?

ftp://vim.sourceforge.net/pub/vim/upload_binaries/

http://vim.sourceforge.net/bin_download/






VimTip	{{{1 47: Swapping characters, words and lines


To swap two characters or lines, use the following commands:

xp       -     delete the character under the cursor and put it afterwards.
               (In other words, it swaps the characters.)

ddp      -     delete the current line and put it afterwards.
               (In other words, it swaps the lines.)

Unfortunately there is no universal solution to swap two words.
You may try the following ones, but don't expect too much of them:

dawwP    -     delete the word under the cursor, move forward one word
               and put it back after the cursor.  (In other words, it 
               swaps the current and following word.)
               
dawbP    -     delete the word under the cursor, move backward on word
               and put it back after the cursor.  (In other words, it
               swaps the current and preceeding word.)








VimTip	{{{1 48: Moving around


You can save a lot of time when navigating through the text by using 
appropriate movements commands. In most cases the cursor keys,
<PageUp> or <PageDown> are NOT the best choice.

Here is a selection of some basic movement commands that 
hopefully helps you to acquire a taste for more:

e   - move to the end of a word                   
w   - move forward to the beginning of a word     
3w  - move forward three words
b   - move backward to the beginning of a word
3b  - move backward three words

$       - move to the end of the line          
<End>   - same as $
0       - move to the beginning of the line
<Home>  - same as 0

)   - jump forward one sentence
(   - jump backward one sentence

}   - jump forward one paragraph
{   - jump backward one paragraph

H   - jump to the top of the display       
M   - jump to the middle of the display   
L   - jump to the bottom of the display

'm  - jump to the beginning of the line of mark m
`m  - jump to the location of mark m

G   - jump to end of file
1G  - jump to beginning of file
50G - jump to line 50

'' - return to the line where the cursor was before the latest jump
`` - return to the cursor position before the latest jump (undo the jump).

%  - jump to corresponding item, e.g. from an open brace to its 
     matching closing brace
   
For some more interesting movement commands (especially those 
for programmers) refer to:

:help motion.txt

:help search-commands






VimTip	{{{1 49: Switching case of characters


To switch the case of one or more characters use the "~", "gU" or
"gu" commands.

Examples:

~     -     switch case of character under cursor 
            (in visual-mode: switch case of highlighted text)

3~    -     switch case of next three characters

g~~   -     switch case of current line

U     -     in visual-mode: make highlighted text uppercase

gUU   -     make current line uppercase

u     -     in visual-mode: make highlighted text lowercase

guu   -     make current line lowercase

gUaw  -     make current word uppercase

guaw  -     make current word lowercase

For some more examples refer to

:help ~

See also:

:help simple-change






VimTip	{{{1 50: Recovering files


If your computer has crashed while editing a file, you should be able 
to recover the file by typing 

      vi -r <filename>

where <filename> is the name of the file you were editing at the time 
of the crash.
If you were editing without a file name, give an empty string as argument:

      vim -r ""

To get a list of recoverable files start vim without arguments:

      vim -r


For more information about file recovery refer to:

:help recovery







VimTip	{{{1 51: Entering german umlauts


To enter german umlauts (or any other of those weired 
characters) not available on your keyboard use 'digraphs':

In insert-mode type for example:
    
     CTRL-K "a

     CTRL-K ^e
 
which gives an 'ä' and 'e' with a hat. 

You can also set the digraph option:

    :set digraph (or :set dg)

With digraph option set you can enter 

    " <BS> a

    ^ <BS> e

which gives the same result.

To get a list of currently defined digraphs type

   :dig[graphs]

For more information about defining and using digraphs refer to:

:help digraph.txt






VimTip	{{{1 52: Scrolling synchronously


If you want to bind two or more windows such that when one
window is scrolled, the other windows are scrolled simultaneously,
set the 'scrollbind' option for these windows:

:set scrollbind

When a window that has 'scrollbind' set is scrolled, all other
'scrollbind' windows are scrolled the same amount, if possible.

For more information about the 'scrollbind' option refer to

:help scoll-binding







VimTip	{{{1 53: Better colors for syntax highlighting


For syntax highlighting there are two sets of default color 
maps: One for a light and another one for a dark background.
If you have a black background, use the following command to
get a better color map for syntax highlighting:

:set background=dark

You have to switch off and on again syntax highlighting to
activate the new color map:

:syntax off
:syntax on

For a detailled description of syntax highlighting refer to

:help syntax.txt

See also the Vim syntax support file: $VIMRUNTIME/syntax/synload.vim






VimTip	{{{1 54: View a Java Class File Decompiled thru Vim


Hi All,
Wish u could view a Java Class File using Vim,
Well ur query ends here.
First of all u will need a Java Decompiler to decompile
the Class File.
I would suggest the JAD decompiler by Pavel Kouznetsov 
http://www.geocities.com/SiliconValley/Bridge/8617/jad.html

Its a command line decompiler and absolutely free.
U can use any command line decompiler of ur choice.

Next create a vimscript file called jad.vim as
######################### FILE START ################
augr class
au!
au bufreadpost,filereadpost *.class %!d:jad.exe -noctor -ff -i -p %
au bufreadpost,filereadpost *.class set readonly
au bufreadpost,filereadpost *.class set ft=java
au bufreadpost,filereadpost *.class normal gg=G
au bufreadpost,filereadpost *.class set nomodified
augr END
######################## FILE END #####################

Note:- Keep the Jad.exe in a directory with out white spaces.
The -p options directs JAD to send the output to standard output
instead of a .jad file. Other options are described on the JAD site.

Next add the following line in the .vimrc file.
so jad.vim

Next time u do vim abc.class. Viola u have the source code
for abc.class.

NOTE:- I have written the script so as to open the class file
read only, So that u dont accidently modify it.
U can also exted this script to unjar a jar file and then view each
file in the JAR file.
thanks
bhaskar
Any suggestions are welcome







VimTip	{{{1 55: previous buffer


One of the keys to vim is buffer management. If I have to use another IDE that makes me click on a tab every time I want to look at another file I'm going to go postal.

So of course you know about :ls which lists all the current open buffers. This gets a little unweildly once you have a full project open so you can also use :b <any snipit of text> <tab> to complete to an open buffer. This is really nice because you can type any fragment of a file name and it will complete to the matching file. (i.e. RequestManager.java can be completed using "tma"<tab> or "req"<tab> or "r.java"<tab>).

Now for awhile I was also using :bn and :bp which jumps you to the next and previous buffer respectively. I found I was often frustrated because I wanted :bp to be the previous buffer I was in, not the previous buffer in the list. So (drum roll) the reason I wrote this tip was because of:

:b#

jump to the previous buffer you were in. Very very handy. The only thing nicer are tag, but that's a tip for another time.

:help buffers
:help bn
:help bp

If anybody knows where to get help on # in this context please add notes.






VimTip	{{{1 58: how to avoid obliterating window layout


If you take the time to lay out several windows
with vim (especially vertically in version 6), you may be bummed when
you hit an errant key and find that all but what one window
disappears.

What happens: while navigating between windows, you
hit <C-W>j, <C-W>k, etc.  At some point you accidently
hit <C-W> but then don't follow with a window command.
Now hitting 'o' to start insert mode issues a command
equivalent to :only, and closes all windows execept
for the one you are in (unless some windows have unsaved
changes in them).

How to avoid this: petition the vim-dev mailing list about
how :only is sufficient for the infrequenty use this might
get (j/k).

Really: use mapping to disable the <C-W>o functionality; put
this in your .vimrc:

nnoremap <C-W>O :echo "sucker"<CR>
nnoremap <C-W>o :echo "sucker"<CR>
nnoremap <C-W><C-O> :echo "sucker"<CR>

references:

:help :only
:help CTRL-W_o

That is all.
Scott







VimTip	{{{1 62: Applying substitutes to a visual block


If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's
http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source it in,
and then press ":B".  On the command line you'll see

:'<,'>BCtrl-V 

Just continue with the substitute or whatever...

:'<,'>B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central....|......:B s/abc/ABC/g
..................four "abc"s..............|
..................----------------....|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)








VimTip	{{{1 63: Applying substitutes to a visual block


If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's
http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source it in,
and then press ":B".  On the command line you'll see

:'<,'>BCtrl-V 

Just continue with the substitute or whatever...

:'<,'>B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central.......|......:B s/abc/ABC/g
..................four "abc"s.................|
..................---------............|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)








VimTip	{{{1 64: Always set your working directory to the file you're editing


Sometimes I think it's helpful if your working directory is always the same as the buffer you are editing.  You need to put this in your .vimrc:

function! CHANGE_CURR_DIR()
	let _dir = expand("%:p:h")
	exec "cd " . _dir
	unlet _dir
endfunction

autocmd BufEnter * call CHANGE_CURR_DIR()

Doing this will make a "cd" command to your the current buffer each time you switch to it.  This is actually similar to vimtip#2 but more automatic.

You should see for more details:
:help autocmd
:help expand
:help function

Note: This tip was contributed by somebody on the list a while ago (sorry for no reference) and it has been extremely helpful to me. Thanks!






VimTip	{{{1 65: Insert line number into the actuall text of the file.


Although :set number will add nice line number for you At time you may wish to actually place the line numbers into the file. For example on GNU Unix you can acomplish a simular task using cat -n file > new_file

In VIM you can use the global command to do this

:g/^/exec "s/^/".strpart(line(".")."    ", 0, 4)

What this does is run the exec comand on every line that matches /^/ (All)
The exec command taks a string and executes it as if it were typed in.

line(".")."    " -> returns the number of the current line plus four spaces.
strpart("123    ", 0, 4) -> returns only the first four characters ("123 ").
"s/^/123 " -> substituts the begining of the line with "123 ".






VimTip	{{{1 66: Transfer text between two Vim 'sessions',


This one is a one of my favorites from Dr. Chip, and I haven't seen it come
across vim tips yet...

Can use either visual, or marking to denote the text.

" transfer/read and write one block of text between vim sessions
" Usage:
" `from' session:
"     ma
"     move to end-of-block
"     xw
"
" `to' session:
"     move to where I want block inserted
"     xr
"
if has("unix")
  nmap xr   :r $HOME/.vimxfer<CR>
  nmap xw   :'a,.w! $HOME/.vimxfer<CR>
  vmap xr   c<esc>:r $HOME/.vimxfer<CR>
  vmap xw   :w! $HOME/.vimxfer<CR>
else
  nmap xr   :r c:/.vimxfer<CR>
  nmap xw   :'a,.w! c:/.vimxfer<CR>
  vmap xr   c<esc>:r c:/.vimxfer<cr>
  vmap xw   :w! c:/.vimxfer<CR>
endif







VimTip	{{{1 67: Ascii Value


Sometimes we, the programmers, need the value of a character, don't we?
You can learn the ascii value of a character by pressing g and a keys.(ga)!
It displays the value in dec, hex and octal...






VimTip	{{{1 68: Delete key


Don't worry if your delete key does not work properly.
Just press <CTRL>-Backspace.
It works under both mode(insert or normal).






VimTip	{{{1 69: dot makes life easier


You can copy and paste the last changes you made in the last insert mode
without using y and p by pressing . (just dot). 
Vim memorizes the keys you pressed and echos them if you hit the dot key. 
You must be in command mode as usual.
It can be helpful...






VimTip	{{{1 70: running a command on all buffers


From Peter Bismuti on the vim list:

How to global search and replace in all buffers with one command? 
You need the AllBuffers command:

:call AllBuffers("%s/string1/string2/g")

"put this in a file and source it
function AllBuffers(cmnd)
  let cmnd = a:cmnd
  let i = 1
  while (i <= bufnr("$"))
    if bufexists(i)
      execute "buffer" i
      execute cmnd
    endif
    let i = i+1
  endwhile
endfun

":call AllBuffers("%s/foo/bar/ge|update")

Thanks Peter!






VimTip	{{{1 71: Transfer text between two gvim sessions using clipboard


If you use gvim, you can transfer text from one instance of gvim into another one using clipboard.  It is convenient to use * (star) register, like this:

In one instance yank two lines into clipboard:
    "*2yy
Paste it in another instance in normal mode:
    "*p
or in insert mode:
    <Ctrl-R>*






VimTip	{{{1 72: Remove unwanted empty lines


Sometimes to improve the readability of the document I insert empty lines, which will be later removed.
To get rid off them try: 
:%g/^$/d
This will remove a l l  empty line in the document.
Some other tipps you can find under www.linuxclass.de/vim.phtml







VimTip	{{{1 73: Using vim as calculator


Basic calculations can done within vim easily by typing (insert-mode):
STRG (=CTRL) + R followed by =
then for example 2+2 and hit RETURN
the result 4 will be printed in the document.

Some other tipps you can find under www.linuxclass.de/vim.phtml







VimTip	{{{1 74: Using Vim as an outline processor


With the addition of folding, Vim6 can function as a high performance outline processor. Simply :set ai and in insert mode use backspace to promote and tab to demote headlines.

In command mode, << promotes (n<< to promote multiple lines), and >> demotes. Also, highlight several headlines and < or > to promote or demote.

:set foldmethod=indent, and then your z commands can expand or collapse headline trees, filewide or by the tree.

The VimOutliner GPL distro contains the scripts and configs to easily configure Vim6 as an outliner, including scripts to create tag files enabling interoutline hyperlinking.

The VimOutliner project is at http://www.troubleshooters.com/projects/vimoutliner/index.htm.

Steve (Litt)
slitt@troubleshooters.com







VimTip	{{{1 75: Remap CAPSLOCK key in Windows 2000 Professional and NT4.0


If you're Windows 2000 Professional user and got tired to move your hands off basic row when hitting <ESC> key
here the solution (not for Windows 9x.):
remap CapsLock key as <ESC> key. It's located in useful position.
Put this lines into <EscLock.reg> file and start it in explorer.Reboot.Enjoy.

REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,01,00,3a,00,00,00,00,00

To restore you capslock back just delete this entry from Registry and reboot.
And below is remapping <capslock> as <Left Control>:

REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00








VimTip	{{{1 76: Folding for Quickfix


The Quickfix mode aims to "speed up the edit-compile-edit cycle" according to ':help quickfix'. After executing ':make' or ':grep' it is possible to skim through the list of errors/matches and the appropriate source code locations with, for instance, the ':cnext' command.
Another way to get a quick overview is to use VIMs folding mode, to fold away all the error-free/match-free regions.
The script at the end of this message can be used for this purpose. It is at the moment not elaborate enough to put it up as a 'script'; but it might give someone inspiration to do so.
Big restrictions / bugs are as follows:
1. Vim Perl interface is required, i.e. the output of ':version' must contain '+perl' (People with Vim scripting knowledge might fix this)
2. Works only for one file, i.e. the current buffer.
3. It's a quick hack.
Sample usage: (a) edit a file, (b) do ':grep regexp %' to get a quickfix error list and (c) ':source foldqf.vim' will fold as described
Increasing the value of $CONTEXT gives you more context around the error regions.

Here comes it, it should be 7 lines:
---foldqf.vim
cwindow
perl $CONTEXT = 0;
perl @A = map { m/\|(\d+)\|/; $1 +0 } $curbuf->Get(1..$curbuf->Count());
close
normal zD
perl sub fold { VIM::DoCommand( $_[0] . ',' . ($_[1]) . "fold" ) if( $_[0] < $_[1] ); }
perl $last = 0; for (@A) { fold( $last+1+$CONTEXT, $_-1-$CONTEXT ); $last = $_; }; VIM::DoCommand(($A[-1]+1+$CONTEXT ) . ',$fold' );







VimTip	{{{1 77: Displaying search results using folds



A guy I work with told me about a function that an old IBM text editor had that he said was useful, and that is to create folds in the file after a search such that every line that is visible contains the search pattern(except possibly the first). All lines that do not contain the search pattern are folded up to the last occurence of the pattern or the top of the file.  

One use for such a function is to be able to make a quick and dirty api of a source file.  For example, if working in Java, you could run the function using the pattern "public|protected|private" and ithe results would be that only the method headers would be visible (well, close enough).  


function! Foldsearch(search)
        normal zE          "erase all folds to begin with
        normal G$          "move to the end of the file
	let folded = 0     "flag to set when a fold is found
        let flags = "w"    "allow wrapping in the search
        let line1 =  0     "set marker for beginning of fold
        while search(a:search, flags) > 0
                let  line2 = line(".")
		"echo "pattern found at line # " line2
                if (line2 -1 > line1)
                        "echo line1 . ":" . (line2-1)
                        "echo "A fold goes here."
                        execute ":" . line1 . "," . (line2-1) . "fold"
						let folded = 1       "at least one fold has been found
                endif
                let line1 = line2     "update marker
                let flags = "W"       "turn off wrapping
        endwhile
		" Now create the last fold which goes to the end of the file.
        normal $G
        let  line2 = line(".")
		"echo "end of file found at line # " line2
        if (line2  > line1 && folded == 1)
                "echo line1 . ":" . line2
                "echo "A fold goes here."
                execute ":". line1 . "," . line2 . "fold"
        endif
endfunction


" Command is executed as ':Fs pattern'"
command! -nargs=+ -complete=command Fs call Foldsearch(<q-args>)
" View the methods and variables in a java source file."
command! Japi Fs public\|protected\|private









VimTip	{{{1 78: rotating mail signatures


For people using mutt and vim for mail, the following script will allow you to insert a new signature (and again and again if you don\'t like the current one) at the bottom of your mail. This is usefull eg when you don\'t want to send a potentially offensive quote to someone you don\'t know very well (or a mailing list), but are too lazy to delete the quote, open your quotes file, and cut and paste another one in. (I put it here in \'tips\' and not in \'scripts\' because it is imo too short to be a \'real\' script)

" rotate_sig.vim
" Maintainer:  Roel Vanhout <roel@2e-systems.com>
" Version:     0.1
" Last Change: Tuesday, June 12, 2001
" Mapping I use:
" nmap ,r :call RotateSig()<CR>
" Usage:
" -Make sure you delimit your sig with '-- ', or adjust the script
" -Adjust the last execute to a command that prints a sig to stdout
" Known problems:
"   - You'll get an error message when you're below the last
"     '^-- $' in your mail (nothing bad though - just an not-
"     found marker)

function! RotateSig()
    normal mQG
    execute '?^-- $'
    execute ':nohl'
    normal o<ESC>
    normal dG
    normal <CR>
    execute 'r !~/bin/autosig ~/.quotes \%'
    normal `Q
endfunction








VimTip	{{{1 79: How to use :grep to get a clickable list of function names



The following function will make a :cwindow window with a line per function
in the current C source file. NOTE: It writes the file as a side effect.

Invoke with ':call ShowFunc()'
You may want to do :nmap <somekey> :call ShowFunc()<CR>

function! ShowFunc()
    
    let gf_s = &grepformat
    let gp_s = &grepprg

    let &grepformat = '%*\k%*\sfunction%*\s%l%*\s%f %*\s%m'
    let &grepprg = 'ctags -x --c-types=f --sort=no -o -'

    write
    silent! grep %
    cwindow

    let &grepformat = gf_s
    let &grepprg = gp_s

endfunc







VimTip	{{{1 80: Restore cursor to file position in previous editing session


Here's something for your <.vimrc> which will allow you to restore your cursor position in a file over several editing sessions.  This technique uses the viminfo option:

Ex. set viminfo='10,\"100,:20,%,n~/.viminfo
    au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif

If you're on Unix, the viminfo is probably fine as is (but check up on Vim's help for viminfo to see if you like the settings above).  For Windows you'll need to change the "n" suboption to something like

Ex. set viminfo='10,\"100,:20,%,nc:\\some\\place\\under\\Windoz\\_viminfo

This tip is a somewhat improved version of the example given for :he line()
in the Vim on-line documentation.






VimTip	{{{1 81: Substitution of characters and lines in VIM is made far easier with the s and S commands


Substitute  Characters
-----------------------------------
I was just editing a file that contained the same leading string on many lines. 

example:

foo_bar_baz1=a
foo_bar_baz1=abc674
foo_bar_baz1=qrs
foo_bar_baz1=m1
foo_bar_baz1=bz90
foo_bar_baz1=bc
...

Needing to only substitute a portion of the string, I referred to a VIM reference card and discovered a command answering my need exactly. The s command is used to subsitute a certain number of characters. In my example file above, if I only needed to subsititute the characters foo_bar, I set the cursor on the first character where I'd like the subsitution to begin and type 7s. VIM drops the characters foo_bar and goes to insert mode, waiting for the substitution text.

Substitute Lines
-----------------------
After years of using vi and VIM and always deleting multiple lines in order to replace them, I just discovered the S command. If you need to subsitute three lines of text, simply type 3S. VIM drops the three lines and goes into insert mode, waiting for the subsitution text. 






VimTip	{{{1 82: letting variable values be overwritten in a script


this is a simple function i wrote to get the value of a variable from three different places (in that order):  the current buffer, the global setting or from the script itself.

this allows me to set a default value for a configuration variable inside my script and the user to change it on a global level by setting the same variable with a g: prepended.  then, they can further set it on a per-buffer level by the the b: mechanism.  one of the examples for this might be my comments script (not uploaded).  i have a variable in there that determines whether comment characters (// for java, for example) are placed the beginning of the line or just before the first-non-blanks in the text.  i set up a default in my script:

let s:comments_hug_start_of_line=0   " comments should hug the text

that's fine as a default, but if i want to overwrite it for vim scripts, i just put the following in my ftplugin/vim.vim:

let b:comments_hug_start_of_line=1   " vim comments should hug the first column, always

" tries  to return  the buffer-specific  value of  a variable;  if not
" found,  tries to  return the  global value  -- if  that's not  found
" either, returns the value set in the script itself
function! GetVar(varName)
  if (exists ("b:" . a:varName))
    exe "let retVal=b:" . a:varName
  elseif (exists ("g:" . a:varName))
    exe "let retVal=g:" . a:varName
  elseif (exists ("s:" . a:varName))
    exe "let retVal=s:" . a:varName
  else
    retVal=-1
  endif
  return retVal
endfunction

personally, i never let it get to the -1 state by always having an s: set with SOME default value.






VimTip	{{{1 83: how to indent (useful for source code)


Here is the most useful vim command that I know of and I'm surprised that it's not yet in the tips list.

I use the indent features of vim all the time. Basically, it lets you indent your source code.

SETUP: To make indentation work nicely I have the following in my .vimrc file:
set et
set sw=4
set smarttab

these make vim behave nicely when indenting, giving 4 spaces (not tabs) for each "tabstop".

HOW TO USE:
in command mode, == will indent the current line
selecting a range of lines (with shift-v) then == will indent your selection
typing a number then == will indent that many lines, starting from your cursor
(you get the idea, there are many other things you can do to select a range of lines)

Tell me that isn't great?







VimTip	{{{1 84: Changing the behaviour of . to include visual mode


one of the things i do a lot in vim is to make a change to the beginning
or end of  the line (such as adding  the text '// remove' at  the end of
java debug code).  a quick way of doing  this is to use a  to append the
text to the end of the first line  and then move down one, hit . (repeat
last edit), move down, hit .  etc. etc. the following mapping allows one
to  simply  highlight the  region  in  question and  hit  .  -- it  will
automatically execute the . once on each line:

  " allow the . to execute once for each line of a visual selection
  vnoremap . :normal .<CR>

another thing i do a lot is to  record a quick macro in the "a" register
and then play it back a number of  times. while @@ can be used to repeat
the last register used, my recorded macros sometimes use other registers
so @@ doesn't necessarily  give me the same results as  @a. also, i have
mapped ' to `  because i like to go to the precise  location of my marks
-- always --  and never to the  beginning of the line. this  leaves my `
key unused. so:

  " make ` execute the contents of the a register
  nnoremap ` @a

then, in keeping with the visual . above, i did the same for the ` -- is
thexecutes @a once on each highlighed line.

  vnoremap ` :normal @a<CR>

as an example, say i have the following lines of java code:

      public String m_asdf;
      public String m_lkhj;
      public int m_hjkhjkh;

and, for some reason, i need to get the following:

      "asdf"
      "lkhj"
      "hjkhjkh"

i record the following into a:

  ^cf_"<ESC>$r"

the ^  is because my  java code is  indented and i  don't want to  go to
column 0 and the <esc> is an actual escape i hit to exit insert mode.

then, i  simply select (visually) the  other lines (only two  in case --
admittedly not an overly useful example) and just hit `.







VimTip	{{{1 85: How to mimic the vim 6.0 plugin feature with older versions


If you do not have vim 6.0, but would like to mimic the plugins directory feature then copy and paste this into your vimrc:

exec "source " . substitute(glob($VIM."/plugins/*.vim"), "\n", "\nsource ", "g")

It will automatically source every vim script file located in the vim/plugins directory.
Now, to add a new plugin, just drop the script in this directory and vim will automatically find it.







VimTip	{{{1 86: Helps undo 1 line when entered many


When U entered text, U cannot undo only 1 line, for example, when U press "u", all entered in last "insert" text removed.

If U add this line to .vimrc:
inoremap <Return> <Return>^O^[
where "^O" or "^[" is 1 char
"u" will undo (remove) only 1 line.







VimTip	{{{1 87: Get vim 5.x window in vim 6.x


The format of the window title in vim 5.x (well, at least for 5.7,.8, for Win32) used to be VIM - <full filename with path>.  It's not in the win32 binary of 6.0an that I found.  I want my old way back.

Turns out, all that it takes to get it back is 
:set title titlestring=VIM\ -\ %F "make sure that the window caption setting is turned on and set caption to vim 5.x style

Oh, however, one thing I did like about the 6.0 style is that it puts the word "help" in the title when the current buffer is a help file; so, I just tacked %h to my titlestring giving:

:set title titlestring=VIM\ -\ %F\ %h "make sure that the window caption setting is turned on and set caption to vim 5.x style

see also:
:he 'titlestring'
:he 'statusline'    "for the format for titlestring






VimTip	{{{1 88: How to maximize vim on entry (win32)


Maybe it's just because I have far too small of a monitor, because I can get distracted while coding if I have other stuff on the screen, or because I starting using vim on a console, but I definitely like my vim window maximized.  Anyway, sticking the following in your vimrc will always maximize your vim window on startup.

au GUIEnter * simalt ~x


:he win16-maximized








VimTip	{{{1 89: Get more screen real estate by hidding toolbar and/or menus


I use gvim over console vim because gvim is much more readable (under Windows).  However, that doesn't mean I want to dedicate screen space to things I'll never use (i.e. the toolbar and the menus).

Anyway, you can give the following a try if you'd like.

set guioptions-=T "get rid of toolbar
set guioptions-=m "get rid of menu

Oh, yeah.  If you decide that you don't really like being without your the toolbar or menus, issue the following:

set guioptions+=T "bring back toolbar
set guioptions+=m "bring back menu

see also: 
:he 'guioptions







VimTip	{{{1 90: Encryption


You can encrypt your texts by using vim. 
:X  prompts for an encryption key. 
After writing your key, if you save your document 
it will be encrypted and no one else (but you and vim) 
can read your documents.
If you reopen the file, VIM will ask for the key. 
If you want to disable encryption, just type
:set key=
if you forget your key you will lose your document. 
So please DO NOT forget your key,
 






VimTip	{{{1 91: Dictionary completions


This tip will will explain how to use the dictionary completion facilities provided by vim.  This can be useful if you use vim to type your email, edit code, etc.  

Dictionary completion is one of many search facilites provided by Insert mode completion.  It allows the user to get a list of keywords, based off of the current word at the cursor.  This is useful if you are typing a long word (e.g. acknowledgeable) and don't want to finish typing or don't remember the spelling.

To start, we must first tell vim where our dictionary is located.  This is done via the 'dictionary'  option.  Below is an example.  Your location may vary.  See :help 'dictionary'  for hints as to where you should look.

	:set dictionary-=/usr/share/dict/words dictionary+=/usr/share/dict/words

Now, to use this list we have to enter insert mode completion.  This is done by hitting CTRL-X while in insert mode.  Next, you have to specify what you want to complete.  For dictionaries use CTRL-K.  Once in this mode the keys CTRL-N and CTRL-P will cycle through the matches.  So, to complete the word "acknowledgeable" I would do the following in insert mode:

	acknow<CTRL-X><CTRL-K><CTRL-N>

It can be cumbersome to type CTRL-X CTRL-K for many different completions.  So, vim gives us a shortcut.  While in insert mode CTRL-N and CTRL-P will cycle through a predetermined set of completion sources.  By default, dictionary completion is not a part of this set.  This set is defined by the 'complete' option.  Therefore, we must add dictionary to this as shown below:

	:set complete-=k complete+=k

Now, while in insert mode we can type the following to complete our example:

	acknow<CTRL-N><CTRL-N>

This shortcut may not save a whole lot of typing.  However, I find that it requires less hand movement to only worry myself with two key combinations, rather than 4.

I find that the completion facilites provided by vim save me a *HUGE* amount of typing.  These savings can be realized in only a short amount of time if you are editing some code with functions and variables that have long names with underscores in them.

For more help:
	help ins-completion
	help compl-dictionary
	help 'complete'
	help 'dictionary'
	help :set+=






VimTip	{{{1 92: Reducing 'doc' directory size


As everyone knows, the $VIMRUNTIME/doc is increasing rapidly in size. The directory contained so many plain-text documents that I often compress them to save my diskspace. With the support of VIM's GZIP plugin, VIM will automatically uncompress the files when we need to read them.
Here is my procedure:
1.  If you have the source, go to 'runtime/doc' and edit 'doctags.c', change       printf("%s\t%s\t/*", p1, argv[0]);  to  printf("%s\t%s.gz\t/*", p1, argv[0]);
     then make. This is to modify the tag, or you'll have to change the 'tags' file by hand if you don't have doctags.c.
2. Edit the new generated 'tags' file to rename 'help.txt.gz' back to 'help.txt' because it's hard-written in VIM executable binary.
     :% s/help\.txt\.gz/help\.txt/g
3. Copy the new 'tags' to $VIMRNUTIME/doc and run 'gzip *.txt; gunzip help.txt'

On VIM 6.0an, we can reduce the original size (3302k) to 1326k.
I don't know if this helps, but if someone likes to compress documents... this can be reffered :)
    







VimTip	{{{1 93: if you use 'highlight search' feature, map a key to :noh


It is very convenient to use 'hlsearch' option.  However it can be annoying to have the highlight stick longer than you want it.  In order to run it off you have to type at least 4 keystrokes, ":noh".  So, it's a good idea to map this to a key.  I like to map it to control-n.  This is the line I use in my .vimrc file to do it:

nmap <silent> <C-N> :silent noh<CR>






VimTip	{{{1 94: Questions & Answers about using tags with Vim


Using tags file with Vim
------------------------
This document gives you a idea about the various facilities available
in Vim for using a tags file to browse through program source files.
You can read the Vim online help, which explains in detail the tags
support, using :help tagsearch.txt.  You can also use the help
keywords mentioned in this document to read more about a particular
command or option.  To read more about a particular command or option
use, :help <helpkeyword> in Vim.

1. How do I create a tags file?

   You can create a tags file either using the ctags utility or using
   a custom script or utility.

   Help keyword(s): tag

2. Where can I download the tools to generate the tags file?

   There are several utilities available to generate the tags file.
   Depending on the programming language, you can use any one of them.

   1. Exuberant ctags generates tags for the following programming
      language files: 
      
      Assembler, AWK, ASP, BETA, Bourne/Korn/Zsh Shell, C, C++, COBOL,
      Eiffel, Fortran, Java, Lisp, Make, Pascal, Perl, PHP, Python,
      REXX, Ruby, S-Lang, Scheme, Tcl, and Vim.

      You can download exuberant ctags from
      http://ctags.sourceforge.net/

   2. On Unix, you can use the /usr/bin/ctags utility.  This utility
      is present in most of the Unix installations.
   
   3. You can use jtags for generating tags file for java programs.
      You can download jtags from: http://www.fleiner.com/jtags/

   4. You can use ptags for generating tags file for perl programs.
      You can download ptags from:
      http://www.eleves.ens.fr:8080/home/nthiery/Tags/

   5. You can download scripts from the following links for
      generating tags file for verilog files:
   
            http://www.probo.com/vtags.htm
            http://www.cs.albany.edu/~mosh/Perl/veri-tags
            http://www.verilog.net/vrtags.txt

   6. You can download Hdrtag from the following linke:

            http://www.erols.com/astronaut/vim/index.html#Tags

      This utility generates tags file for the following programming
      languages: assembly, c/c++, header files, lex, yacc,LaTeX, vim,
      and Maple V.

   7. You can also use the following scripts which are part of the Vim
      runtime files:

          pltags.pl - Create tags file for perl code
          tcltags - Create tags file for TCL code
          shtags.pl - Create tags file for shell script

   Help keyword(s): ctags

3. How do I generate a tags file using ctags?

   You can generate a tags file for all the C files in the current
   directory using the following command:

        $ ctags *.c

   You can generate tags file for all the files in the current
   directory and all the sub-directories using (this applies only to
   exuberant ctags):

        $ ctags -R .

   You can generate tags file for all the files listed in a text file
   named flist using (this applies only to exuberant ctags)

       $ ctags -L flist

4. How do I configure Vim to locate a tags file?

   You can set the 'tags' option in Vim to specify a particular tags
   file.

        set tags=/my/dir/tags

   Help keyword(s): 'tags', tags-option

5. How do I configure Vim to use multiple tags files?

   The 'tags' option can specify more than one tags file.  The tag
   filenames are separated using either comma or spaces.

        set tags=/my/dir1/tags, /my/dir2/tags

6. How do I configure Vim to locate a tags file in a directory tree?

   Note that the following will work only in Vim 6.0 and above.  You
   can set the 'tags' option to make Vim search for the tags file in a
   directory tree.  For example, if the 'tags' option is set like
   this:

        set tags=tags;/

   Vim will search for the file named 'tags', starting with the
   current directory and then going to the parent directory and then
   recursively to the directory one level above, till it either
   locates the 'tags' file or reaches the root '/' directory.

   Help keyword(s): file-searching

7. How do I jump to a tag?

   There are several ways to jump to a tag location.
        1. You can use the 'tag' ex command.  For example,

               :tag <tagname>
   
           will jump to the tag named <tagname>.
        2. You can position the cursor over a tag name and then press
           Ctrl-].
        3. You can visually select a text and then press Ctrl-] to
           jump to the tag matching the selected text.
        4. You can click on the tag name using the left mouse button,
           while pressing the <Ctrl> key.
        5. You can press the g key and then click on the tag name
           using the left mouse button.
        6. You can use the 'stag' ex command, to open the tag in a new
           window.  For example,

                :stag func1

           will open the func1 definition in a new window.
        7. You can position the cursor over a tag name and then press
           Ctrl-W ].  This will open the tag location in a new window.

   Help keyword(s): :tag, Ctrl-], v_CTRL_], <C-LeftMouse>,
                    g<LeftMouse>, :stag, Ctrl-W_]

8. How do I come back from a tag jump?

   There are several ways to come back to the old location from a tag
   jump.
        1. You can use the 'pop' ex command.
        2. You can press Ctrl-t.
        3. You can click the right mouse button, while pressing the
           <Ctrl> key.
        4. You can press the g key and then click the right mouse
           button.

   Help keyword(s): :pop, Ctrl-T, <C-RightMouse>, g<RightMouse>

9. How do I jump again to a previously jumped tag location?

   You can use the 'tag' ex command to jump to a previously jumped tag
   location, which is stored in the tag stack.

   Help keyword(s): tag

10. How do I list the contents of the tag stack?

   Vim remembers the location from which you jumped to a tag in the
   tag stack.  You can list the current tag stack using the 'tags' ex
   command.

   Help keyword(s): :tags, tagstack

11. How do I jump to a particular tag match, if there are multiple
    matching tags?

    In some situations, there can be more than one match for a tag.
    For example, a C function or definition may be present in more
    than one file in a source tree.  There are several ways to jump to
    a specific tag from a list of matching tags.
    
        1. You can use the 'tselect' ex command to list all the tag
           matches.  For example,

                :tselect func1

          will list all the locations where func1 is defined.  You can
          then enter the number of a tag match to jump to that
          location.
        2. You can position the cursor over the tag name and press g]
           to get a list of matching tags.
        3. You can visually select a text and press g] to get a list
           of matching tags.
        4. You can use the 'stselect' ex command.  This will open the
           selected tag from the tag list in a new window.
        5. You can position the cursor over the tag name and press
           Ctrl-W g] to do a :stselect.

    Help keyword(s): tag-matchlist, :tselect, g], v_g], :stselect,
                     Ctrl-W_g]

12. I want to jump to a tag, if there is only one matching tag,
    otherwise a list of matching tags should be displayed.  How do I
    do this? 

    There are several ways to make Vim to jump to a tag directly, if
    there is only one tag match, otherwise present a list of tag
    matches.

        1. You can use the 'tjump' ex command.  For example,

                :tjump func1

           will jump to the definition func1, if it is defined only
           once.  If func1 is defined multiple times, a list of
           matching tags will be presented.
        2. You can position the cursor over the tag and press g
           Ctrl-].
        3. You can visually select a text and press g Ctrl-] to jump
           or list the matching tags.
        4. You can use the 'stjump' ex command.  This will open the
           matching or selected tag from the tag list in a new window.
        5. You can press Ctrl-W g Ctrl-] to do a :stjump.

    Help keyword(s): :tjump, g_Ctrl-], v_g_CTRL-], :stjump,
                     Ctrl-W_g_Ctrl-]

13. How do browse through a list of multiple tag matches?

    If there are multiple tag matches, you can browse through all of
    them using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'tfirst' or
       'trewind' ex command.
    2. To go to the last tag in the list, use the 'tlast' ex command.
    3. To go to the next matching tag in the list, use the 'tnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'tprevious' or 'tNext' ex command.

    Help keyword(s): :tfirst, :trewind, :tlast, :tnext, :tprevious,
                     :tNext

14. How do I preview a tag?

    You can use the preview window to preview a tag, without leaving
    the original window.  There are several ways to preview a tag:

        1. You can use the 'ptag' ex command to open a tag in the
           preview window.
        2. You can position the cursor on a tag name and press Ctrl-W
           } to open the tag in the preview window.
        3. You can use the 'ptselect' ex command to do the equivalent
           of the 'tselect' ex command in the preview window.
        4. You can use the 'ptjump' ex command to do the equivalent of
           the 'tjump' ex command in the preview window.
        5. You can position the cursor on the tag and press Ctrl-W g}
           to do a :ptjump on the tag.

    Help keyword(s): :preview-window, :ptag, Ctrl-W_}, :ptselect,
                     :ptjump, Ctrl-W_g}

15. How do I browse through the tag list in a preview window?

    If there are multiple tag matches, you can browse through all of
    them in the preview window using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'ptfirst' or
       'ptrewind' ex command.
    2. To go to the last tag in the list, use the 'ptlast' ex command.
    3. To go to the next matching tag in the list, use the 'ptnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'ptprevious' or 'ptNext' ex command.

    Help keyword(s): :ptfirst, :ptrewind, :ptlast, :ptnext,
                     :ptprevious, :ptNext

16. How do I start Vim to start editing a file at a given tag match?

    While starting Vim, you can use the command line option '-t' to
    supply a tag name.  Vim will directly jump to the supplied tag
    location.

    Help keyword(s): -t

17. How do I list all the tags matching a search pattern?

    There are several ways to go through a list of all tags matching a
    pattern.

        1. You can list all the tags matching a particular regular
           expression pattern by prepending the tag name with the '/'
           search character.  For example,

                :tag /<pattern>
                :stag /<pattern>
                :ptag /<pattern>
                :tselect /<pattern>
                :tjump /<pattern>
                :ptselect /<pattern>
                :ptjump /<pattern>

         2. If you have the 'wildmenu' option set, then you can press
            the <Tab> key to display a list of all the matching tags
            in the status bar.  You can use the arrow keys to move
            between the tags and then use the <Enter> key to select a
            tag.

         3. If you don't have the 'wildmenu' option set, you can still
            use the <Tab> key to browse through the list of matching
            tags.

    Help keyword(s): tag-regexp, wildmenu

18. What options are available to control how Vim handles the tags
    file?

    You can use the following options to control the handling of tags
    file by Vim:

    1. 'tagrelative' - Controls how the file names in the tags file
                       are treated.  When on, the filenames are
                       relative to the directory where the tags file
                       is present.

    2. 'taglength' -  Controls the number of significant characters
                      used for recognizing a tag.

    3. 'tagbsearch' - Controls the method used to search the tags file
                      for a tag.  If this option is on, binary search
                      is used to search the tags file.  Otherwise,
                      linear search is used.

    4. 'tagstack' - Controls how the tag stack is used.

    Help keyword(s): 'tagrelative', 'taglength', 'tagbsearch',
                     'tagstack'

19. Is it possible to highlight all the tags in the current file?

    Yes.  Read the Vim online help on "tag-highlight".

20. Is it possible to create a menu with all the tags in the current
    file?

    Yes.  It is possible to create a menu with all the tags in the
    current file using a Vim script.  Download the TagsMenu.vim script
    from the following link: 

    http://members.home.net/jayglanville/tagsmenu/TagsMenu.html

21. Is there a workaround to make the Ctrl-] key not to be treated as
    the telnet escape character?

    The default escape characters for telnet in Unix systems is
    Ctrl-].  While using Vim in a telnet session, if you use Ctrl-] to
    jump to a tag, you will get the telnet prompt.  There are two ways
    to avoid this problem:
    
    1. Map the telnet escape character to some other character using
       the "-e <escape character>" telnet command line option

    2. Disable the telnet escape character using the "-E" telnet
       command line option.

    Help keyword(s): telnet-CTRL-]








VimTip	{{{1 95: How do I pipe the output from ex commands into the text buffer?


This is a *request* for a tip.  I need to be able to pipe the output of a :blah ex command into the vim text buffer for editing.  I wanted to do this many times for different reasons and could never find a way!

I would just love to be able to do :hi --> textBuffer and examine the output at my own leasure scrolling up and down and using vim search commands on it.  Same thing for :set all, and other things.  Considering that cut and paste is horrible in windows, I can't for example do :set guioptions? then cut and paste!  So I have to retype it, or cut and paste from the help manual.  I really want to be able to pipe the output of ex commands into the text buffer.  Can someone help me?






VimTip	{{{1 96: Cooperation of Gvim and AutoCad [MTEXT]


You can - like me :o)  - use gvim, like replacement of internal AutoCad MTEXT editor. You need switch variable MTEXTED to "gvim" (or maybe fullpath, something like "c:\vim\vim60aq\gvim" ), and to your _vimrc you can put line:

autocmd BufRead,BufNewFile *.tmp source c:\vim\aacad.vim

And when you edit MTEXT in acad, menu AutoCad will be for your use in gvim (only in INSERT and VISUAL mode)

[NOTE: Only I can't start gvim like gvim -y (for any other person, not so accustomed vith gvim) or start gvim from gvim.lnk or gvim.bat (I'am using windows95) and automatic skip to INSERT mode -latest word star, on end of script- is without functionality(?) Maybe someone advise me?? ] 

Well, script aacad.vim is listed here:

"VIM menu for AutoCad's MTEXT editation
"brz; mailto:brz@centrum.cz;  8. 8. 2001
" Version Mk.I
"--------------------------------------------------------------------------

imenu &AutoCad.Insert.Space \~
vmenu &AutoCad.Insert.Space <Esc>`<i\~<Esc>%
imenu &AutoCad.Insert.Backslash \\
vmenu &AutoCad.Insert.Backslash <Esc>`<i\\<Esc>%
imenu &AutoCad.Insert.Brackets \{\}<Esc>F\i
vmenu &AutoCad.Insert.Brackets <Esc>`>a\}<Esc>`<i\{<Esc>%
imenu &AutoCad.Insert.Paragraph \P
vmenu &AutoCad.Insert.Paragraph <Esc>`>a\P<Esc>%

imenu &AutoCad.-SEP1- :

imenu &AutoCad.Colour.Red \C1;
vmenu &AutoCad.Colour.Red <Esc>`>a\C7;<Esc>`<i\C1;<Esc>%
imenu &AutoCad.Colour.Yellow \C2;
vmenu &AutoCad.Colour.Yellow <Esc>`>a\C7;<Esc>`<i\C2;<Esc>%
imenu &AutoCad.Colour.Green \C3;
vmenu &AutoCad.Colour.Green <Esc>`>a\C7;<Esc>`<i\C3;<Esc>%
imenu &AutoCad.Colour.Cyan \C4;
vmenu &AutoCad.Colour.Cyan <Esc>`>a\C7;<Esc>`<i\C4;<Esc>%
imenu &AutoCad.Colour.Blue \C5;
vmenu &AutoCad.Colour.Blue <Esc>`>a\C7;<Esc>`<i\C5;<Esc>%
imenu &AutoCad.Colour.Violet \C6;
vmenu &AutoCad.Colour.Violet <Esc>`>a\C7;<Esc>`<i\C6;<Esc>%
imenu &AutoCad.Colour.Black \C7;
vmenu &AutoCad.Colour.Black <Esc>`>a\C7;<Esc>`<i\C7;<Esc>%
imenu &AutoCad.Colour.D_Grey \C8;
vmenu &AutoCad.Colour.D_Grey <Esc>`>a\C7;<Esc>`<i\C8;<Esc>%
imenu &AutoCad.Colour.L_Grey \C9;
vmenu &AutoCad.Colour.L_Grey <Esc>`>a\C7;<Esc>`<i\C9;<Esc>%

imenu &AutoCad.Font.Arial \fArial;
vmenu &AutoCad.Font.Arial <Esc>`<i\fArial;<Esc>%
imenu &AutoCad.Font.Symbol \Fsymbol;
vmenu &AutoCad.Font.Symbol <Esc>`<i\Fsymbol;<Esc>%
imenu &AutoCad.Font.RomanC \Fromanc;
imenu &AutoCad.Font.RomanC <Esc>`<i\Fromanc;<Esc>%
imenu &AutoCad.Font.RomanS \Fromans;
vmenu &AutoCad.Font.RomanS <Esc>`<i\Fromans;<Esc>%
imenu &AutoCad.Font.RomanD \Fromand;
vmenu &AutoCad.Font.RomanD <Esc>`<i\Fromand;<Esc>%
imenu &AutoCad.Font.RomanT \Fromant;
vmenu &AutoCad.Font.RomanT <Esc>`<i\Fromant;<Esc>%

imenu &AutoCad.Size.0_5x \H0.5x;
vmenu &AutoCad.Size.0_5x <Esc>`<i\H0.5x;<Esc>%
imenu &AutoCad.Size.1_5x \H1.5x;
vmenu &AutoCad.Size.1_5x <Esc>`<i\H1.5x;<Esc>%
imenu &AutoCad.Size.2x \H2x;
vmenu &AutoCad.Size.2x <Esc>`<i\H2x;<Esc>%
imenu &AutoCad.Size.3x \H3x;
vmenu &AutoCad.Size.3x <Esc>`<i\H3x;<Esc>%

imenu &AutoCad.Effects.Set_Out_1_5 \T1.5;
vmenu &AutoCad.Effects.Set_Out_1_5 <Esc>`>a\T1;<Esc>`<i\T1.5;<Esc>%
imenu &AutoCad.Effects.Set_Out_2 \T2;
vmenu &AutoCad.Effects.Set_Out_2 <Esc>`>a\T1;<Esc>`<i\T2;<Esc>%

imenu &AutoCad.Effects.-SEP3- :
imenu &AutoCad.Effects.Tilt_15deg \Q15;
vmenu &AutoCad.Effects.Tilt_15deg <Esc>`>a\Q0;<Esc>`<i\Q10;<Esc>%
imenu &AutoCad.Effects.Tilt_20deg \Q20;
vmenu &AutoCad.Effects.Tilt_20deg <Esc>`>a\Q0;<Esc>`<i\Q20;<Esc>%
imenu &AutoCad.Effects.Tilt_30deg \Q30;
vmenu &AutoCad.Effects.Tilt_30deg <Esc>`>a\Q0;<Esc>`<i\Q30;<Esc>%

imenu &AutoCad.Effects.-SEP4- :
imenu &AutoCad.Effects.Change_Width_0_5x \W0.5;
vmenu &AutoCad.Effects.Change_Width_0_5x <Esc>`>a\W1;<Esc>`<i\W0.5;<Esc>%
imenu &AutoCad.Effects.Change_Width_2x \W2;
vmenu &AutoCad.Effects.Change_Width_2x <Esc>`>a\W1;<Esc>`<i\W2;<Esc>%

imenu &AutoCad.Effects.-SEP5- :
imenu &AutoCad.Effects.Justify_Down \A0;
vmenu &AutoCad.Effects.Justify_Down <Esc>`<i\A0;<Esc>%
imenu &AutoCad.Effects.Justify_Middle \A1;
vmenu &AutoCad.Effects.Justify_Middle <Esc>`<i\A1;<Esc>%
imenu &AutoCad.Effects.Justify_Up \A2;
vmenu &AutoCad.Effects.Justify_Up <Esc>`<i\A2;<Esc>%
imenu &AutoCad.Effects.Overlined_Characters \O\o<Esc>F\i
vmenu &AutoCad.Effects.Overlined_Characters <Esc>`>a\O<Esc>`<i\o<Esc>%
imenu &AutoCad.Effects.Underlined_Characters \L\l<Esc>F\i
vmenu &AutoCad.Effects.Underlined_Characters <Esc>`>a\l<Esc>`<i\L<Esc>%
imenu &AutoCad.Effects.Index_Top \S^;

imenu &AutoCad.-SEP6- :
imenu &AutoCad.Help <CR><CR>***Quit Editor: press Alt-F4 and 'No' ***<CR><CR>

star







VimTip	{{{1 97: How do I add a current time string inside Vim?


This is a *request* for a tip.
Sometimes (eg. editing HTML pages) I need to add a timestamp string to my editing buffer.
On UNIX systems, I can use  
  :r!date  
to get a localized date time string; but on Windows ('date' on Windows will query the user to input new date)
or other platforms which does not have 'date' command, how do I get a timestamp easily?







VimTip	{{{1 98: Getting vim help from mailing lists and newsgroups.


There have been a few "requests for tips" entered into the tips database lately.  If you have specific questions that aren't answered by the existing tips, there are a couple of resources that may be more appropriate:

The mailing list vim@vim.org is for vim users.  If you send an email to vim-help@vim.org, you'll get a message back telling you how to subscribe, as well as how to request old messages and contact the list maintainer.  This mailing list is also archived at http://groups.yahoo.com/group/vim.

The newsgroup comp.editors discusses many different editors, but most of the traffic is about vim.  When posting, it is appreciated if you include "vim" in the subject line.  The comp.editors newsgroup is archived at http://groups.google.com/groups?hl=en&safe=off&group=comp.editors.

Using the tips database for asking questions is not likely to work well.  For example, if you ask a question titled "Searching for strings in a file" and I read this site and see that tip, I'm not going to read it if I already know how to search for strings in a file.  In comp.editors and vim@vim.org, people expect to find questions from others and are therefore more likely to see your questions.

After finding the answer to your question, please consider whether it would make an appropriate tip, and if so, add it to the tips database.






VimTip	{{{1 99: How to tell what syntax highlighting group *that* is!


Here's a (what should be a one-line) map to help you tell just what
syntax highlighting groups the item under the cursor actually is:

map  <F10>  :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

Once known you can override the current highlighting with whatever you want.
If you're debugging a syntax highlighting file (a rare occupation), sometimes
you'll wish to know the entire chain of syntax highlighting.  For that,
check out

http://www.erols.com/astronaut/vim/vimscript/hilinks.vim








VimTip	{{{1 100: Jump to tag (e.g. help topic) with German keyboard (PC)


You're a newbie in vim and need some ":help"? Well, help.txt reads:

"Jump to a subject:  Position the cursor on a tag between |bars| and hit CTRL-]."

Unfortunately there is no "]" key on German keyboards. On Win32 try CTRL-+ (Strg-+), on Linux console I use CTRL-AltGr-9 (Strg-AltGr-9).

Kind regards






VimTip	{{{1 101: Change automatically to the directory the file in the current buffer is in


To change automatically to the directory the file in the current buffer is in
add a line (below)  to the file .vimrc .
The file .vimrc should have the following if-statement to control the autocmd feature:


  if has("autocmd")
	
    < ... lot of autocmd stuff ... >
	
    " Change to the directory the file in your current buffer is in
    autocmd BufEnter * :cd %:p:h
	
  endif " has("autocmd")


Add the line above the endif and restart vim/gvim.







VimTip	{{{1 102: smart mapping for tab completion


I'm used to complete words with <tab>, however when editing source I can't just map that to vim keyword completion because I sometime need to insert real tabs,
since it mostly happen when at the beginning of the line or after a ; and before a one line comma (java, c++ or perl anyone...) I've come to find the following really usefull
This is how you can map the <tab> key in insert mode while still being able to use it when at the start of a line or when the preceding char is not a keyword character.
in a script file in a plugin directory or in your .vimrc file:
first define a function which returns a <tab> or a <C-N> depending on the context:

function InsertTabWrapper()
      let col = col('.') - 1
      if !col || getline('.')[col - 1] !~ '\k'
          return "\<tab>"
      else
          return "\<c-p>"
      endif
endfunction

then define the appropriate mapping:
inoremap <tab> <c-r>=InsertTabWrapper()<cr>

the trick here is the use of the <c-r>= in insert mode to be able to call your function without leaving insert mode.
:help i_CTRL-R
Benoit






VimTip	{{{1 103: Move to next/previous line with same indentation


When working with Python and other languages which don't use braces, it's useful to be able to jump to and from lines which have the same indentation as the line you are currently on.

nn <M-,> k:call search ("^". matchstr (getline (line (".")+ 1), '\(\s*\)') ."\\S", 'b')<CR>^
nn <M-.> :call search ("^". matchstr (getline (line (".")), '\(\s*\)') ."\\S")<CR>^

will map Alt-< and Alt-> in Normal mode to upward and downward searching for lines with the same indent as the current line.






VimTip	{{{1 104: using vim to complement Perl's DBI::Shell


DBI::Shell is a Perl module that is used as a shell interface to Perl's popular DBI (database interface) package. Forget your favorite SQL navigation gui and give this method a shot. This has only been tested in UNIX.

1. run dbish (runs DBI::Shell; installed with DBI::Shell) and connect to any database
2. in dbish, set /format box
3. enter your query
4. to execute query, type "/ | vim -"

This runs the query and pipes the output to the standard input of vim. Here are some follow-up tips:
-use gvim instead of vim so a new window will pop up
-set nowrap once in vim
-make a syntax highlighting file for me!

-Adam Monsen






VimTip	{{{1 105: combining move and scroll


I sometimes found myself moving down a few lines with j, then scrolling down
about the same number of lines with <C-E> to put the cursor in roughly the
same place as it started.  I decided I wanted to map <C-J> (and <C-K>,
respectively) to the move-and-scroll operation.  First, I did

    :map <C-J> <C-E>j

This was pretty good, but behaved funny at the beginning and end of files.
Then, I realized that <C-D> already combined move and scroll, so I figured
that giving <C-D> a count of 1 would do it:

    :map <C-J> 1<C-D>

Unfortunately, this permanently attaches a count to <C-D> (ugh!), so I have
to undo that:

    :map <C-J> 1<C-D>:set scroll=0<CR>

This has the drawback of not necessarily resetting scroll to its original
value, but since I never change scroll, it's good enough for me.  It would
be nice if there were a version of <C-D> that did not have the side-affect
of changing scroll.

Happy vimming,
Andrew







VimTip	{{{1 106: Mail signature rotation: Supersimple one-line solution


Hallo,
next solution for _most_simple_ signature rotater: 
You can only put one line to your .vimrc || _vimrc:
map <Leader>ms :e c:\sign.txt<CR>ggV/--<CR>k"*xG$a<C-R><C-O>*<Esc>:w<CR>:bd<CR>G$a<C-M><Esc>"*P

Must exist file (from eg above) c:\sign.txt, with content:
--
first signature
--
second signature
--
third signature
--

When You finished mail, only call shortcut \ms and 'first signature' will be insert in your mail. In c:\sign.txt will be first signature pushed to the end of this file. When You want use other signature, only press 'u' and \ms again
(Or You can change \ms to e.g. <F12>, indeed. ) You can change this and append one part like 'basic' from command and append 'changing' part from .signature file, as you like...
Ok, one unpleasant thing is here: your signature must not contain '--' (signature separator)...
Anyhow, I find it useful
brz* <brz@centrum.cz>
http://brz.d2.cz/







VimTip	{{{1 107: C/C++: convert enum to string table


When testing your own C/C++ programs you sometimes wish to have a trace output,
which shows you, which enum value is used.
You can do this by creating a string table for that enum type,
which contains the enum identifyer as a string.
e.g.
printf ("%s", MyEnumStringTable [ MyEnumVal] );

You can create the complete string table by 
- marking the lines containing the complete typedef enum
- select menu C/C++.transform enum2Stringtab

You can create string table entries by 
- marking the lines within the typedef enum
- select menu C/C++.transform enum2String

This makes it easy to keep the enum (on changes) consistent to the string table.

Add the following lines to your _GVIMRC file:
31amenu C/C++.transform\ enum2Stringtab 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o};<ESC>uOstatic const char* const Names[] = {<ESC><CR>/sdfsdf<CR>
31vmenu C/C++.transform\ enum2Stringtab 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o};<ESC>uOstatic const char* const Names[] = {<ESC><CR>/sdfsdf<CR>

31amenu C/C++.transform\ enum2String 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o}<ESC>/sdfsdf<CR>
31vmenu C/C++.transform\ enum2String 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o}<ESC>/sdfsdf<CR>

hint: '/sdfsdf' is added for deactivating search highlighting,
ok, you'll sure find a better way to do this.






VimTip	{{{1 108: Toggle a fold with a single keystroke


When viewing/editing a folded file, it is often needed to inspect/close some fold.
To speed up these operation use the following (put in your $HOME/.vimrc):

" Toggle fold state between closed and opened. 
"
" If there is no fold at current line, just moves forward.
" If it is present, reverse it's state.
fun! ToggleFold()
	if foldlevel('.') == 0
		normal! l
	else
		if foldclosed('.') < 0
			. foldclose
		else
			. foldopen
		endif
	endif
	" Clear status line
	echo
endfun

" Map this function to Space key.
noremap <space> :call ToggleFold()<CR>


See :help folding for more information about folding.







VimTip	{{{1 109: jump between files


Often I know I'm likely to edit many files. I run 'vim *.pl' and get a whole bunch of open files.

To make jumping between files to a pleasure, I defined to mapss:

map <f1> :previous<cr>
map <f2> :next<cr>

Press F1 to go back and F2 to go forward.

-- 
Kirill






VimTip	{{{1 110: text->html table converter.


Below are two functions and a mapping which will convert lines of plain text into
HTML table code.
For example, you have several lines like:
-----------------------------------------------
1
2
3

4
5
6
---------------------------------------------------
by visualizing all the 7 lines and press <F5>, you can change the text into
<table><tr>
   <td>1</td>
   <td>2</td>
   <td>3</td>
</tr><tr>
   <td>4</td>
   <td>5</td>
   <td>6</td>
</tr></table>
which will eventually render into a table. 
So the rule is:
Every line is a table item, every empty line means starting of a new table row.



"A text->html table code converter
"By: Wenzhi Liang wzhliang@yahoo.com
"You can distribute/change this file freely as long as you keep the title area. Thanks

func Table()
	let end=line("'>")
	let start=line("'<")
	let i=start

	wh i <= end
		exe ":" . i
		let e=Empty()
		if e == 1
			exe "normal I</tr><tr>"
		else
			exe "normal I<td>A</td>>>"
		endif
		let i=i+1
	endwh

	exe "normal o</tr></table><<"
	exe ":" . start
	exe "normal O<table><tr><<"
endfunc

vmap <F5> <ESC>:call Table()<CR>

func Empty()
	let line_nr= line (".")
	let a=getline ( line_nr )
	let m=match(a, "\\S")
	if m == -1 
		return 1
	else
		return 0
	endif
endfunc






VimTip	{{{1 111: Printing with syntax highlighting independent of your normal highlighting


I have found it undesirable to use :hardcopy directly because it uses the current syntax highlighting to determine how to print the text.  For example, I like to print comments in italics, but I don't like italic fonts on the screen. This tip will show you how to set up a colorscheme for printing and use it only when you print.

I copied an existing colorscheme to ~/.vim/colors/print.vim, and changed all the lines like this:

  highlight Normal ctermbg=DarkGrey ctermfg=White guifg=White guibg=grey20
to this:
  highlight clear Normal

Then I set the syntax groups how I wanted them to be printed on the printer:

  highlight Comment        term=italic    cterm=italic    gui=italic
  highlight Constant       term=bold      cterm=bold      gui=bold
  etc....

I then defined the following command in my .vimrc file:

command! -nargs=* Hardcopy call DoMyPrint("<args>")

And, finally, I defined this function in my .vimrc:

function DoMyPrint(args)
    let colorsave=g:colors_name
    color print
    exec "hardcopy ".a:args
    exec 'color '.colorsave
endfunction


After this is complete, you can do:
   :Hardcopy > /tmp/out.ps
or just
   :Hardcopy
(Note the capital H)






VimTip	{{{1 112: Back and forth between indented lines again



Paul Wright posted a tip which explained how to jump back and forth between lines with the same indentation level. I do this a lot, so I came up with this slightly more comprehensive solution.

The example mappings below work as follows:

[l and ]l jump to the previous or the next line with the same indentation level as the one you're currently on.

[L and ]L jump to the previous or the next line with an indentation level lower than the line you're currently on.

These movements also work in visual mode and (only as of one of the 6.0 alpha versions) in operator pending mode, meaning that you can do a d]l. The motion is specified as being exclusive when in operator pending mode.

When might you use this? If you're writing programs in Python, Haskell, or editing XML files, they will be very useful. E.g. in XML you can jump to the outer enclosing tag, or the next matching tag. I use it for practically anything I edit, so it's not limited to this.



"
" NextIndent()
"
" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool):   true:  Motion is exclusive
"                     false: Motion is inclusive
" fwd (bool):         true:  Go to next line
"                     false: Go to previous line
" lowerlevel (bool):  true:  Go to line with lower indentation level
"                     false: Go to line with the same indentation level
" skipblanks (bool):  true:  Skip blank lines
"                     false: Don't skip blank lines

function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
	let line = line('.')
	let column = col('.')
	let lastline = line('$')
	let indent = indent(line)
	let stepvalue = a:fwd ? 1 : -1

	while (line > 0 && line <= lastline)
		let line = line + stepvalue
		if (	! a:lowerlevel && indent(line) == indent ||
				\ a:lowerlevel && indent(line) < indent)
			if (! a:skipblanks || strlen(getline(line)) > 0)
				if (a:exclusive)
					let line = line - stepvalue
				endif
				exe line
				exe "normal " column . "|"
				return
			endif
		endif
	endwhile
endfunc


" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<cr>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<cr>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<cr>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<cr>
vnoremap <silent> [l <esc>:call NextIndent(0, 0, 0, 1)<cr>m'gv''
vnoremap <silent> ]l <esc>:call NextIndent(0, 1, 0, 1)<cr>m'gv''
vnoremap <silent> [L <esc>:call NextIndent(0, 0, 1, 1)<cr>m'gv''
vnoremap <silent> ]L <esc>:call NextIndent(0, 1, 1, 1)<cr>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<cr>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<cr>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<cr>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<cr>







VimTip	{{{1 113: Translator in vim (Windows solution)


Hallo, today I found script "translate.vim", but on Windows this will be probably difficult to run it (maybe with Cygwin is it possible). I've simpler solution of keymap for vim interlacing to dictionary: 
Must exist file with vocabulary (e.g. "an-cs.txt"), which is called for word under cursor. In 'normal' is only displayed window with translations, in 'insert' is word under cursor deleted and is insert selected form of word from translantion window (select it by mouse and than press right button: It works fine on W2k). Key _F12_ is looking for "word", shifted _S-F12_ is looking for "pattern". 
For windows is needed agrep, which is localy placed on http://www.tgries.de/agrep/index.html

map <F12> b"*yw<Esc>:! c:/bin/agrep -wih <C-R>* "c:/dict/an-cs.txt"<CR>
imap <F12> <Esc>b"*yw<Esc>:! c:/bin/agrep -wih <C-R>* "c:/dict/an-cs.txt"<CR>dwi <C-R>* 
map <S-F12> b"*yw<Esc>:! c:/bin/agrep -ih <C-R>* "c:/dict/an-cs.txt"<CR>
imap <S-F12> <Esc>b"*yw<Esc>:! c:/bin/agrep -ih <C-R>* "c:/dict/an-cs.txt"<CR>dwi <C-R>*
	
brz* <brz@centrum.cz>






VimTip	{{{1 114: Browsing by  paragraph


It can be done by reaching the blank lines in up and down directions just by pressing

{    ----  For going to the blank line above the paragraph
}    ----  For going to the blank line below the paragraph






VimTip	{{{1 115: Browsing by  paragraph


It can be done by reaching the blank lines in up and down directions just by pressing

{    ----  For going to the blank line above the paragraph
}    ----  For going to the blank line below the paragraph






VimTip	{{{1 116: Search all occurances of the word under cursor in all the open files


Sometimes it is useful to know all the occurances of the word under cursor in all the open files. This can be done by pressing [I ( bracket and capital I ) . it shows the results found in the command window.







VimTip	{{{1 117: FAST SEARCH ACROSS THE PROJECT


Searching for a word across the project wastes most of the developres time, which can be avoided by the use of GNU Id_utils with VIM. 
The procedure needs to be followed is as follows:
download GNU idutils 3.2d (mkid,lid,fid,fnid,xtokid) 
from http://www.mossbayeng.com/~ron/vim/builds.html

uncompress and store these files in the directory from where vim is running.

goto the top level directory of the project, and run mkid, it will create ID file in that directory (As it is time consuming process, so be patient). copy this file ID to the directory from where vim is running.

USAGE:

Put these lines in your .vimrc:

	map _u :call ID_search()<Bar>execute "/\\<" . g:word . "\\>"<CR>
	map _n :n<Bar>execute "/\\<" . g:word . "\\>"<CR>

	function ID_search()
	  let g:word = expand("<cword>")
	  let x = system("lid --key=none ". g:word)
	  let x = substitute(x, "\n", " ", "g")
	  execute "next " . x
	endfun

To use it, place the cursor on a word, type "_u" and vim will load the file
that contains the word.  Search for the next ocurance of the word in the same
file with "n".  Go to the next file with "_n".

The mapping of "_u" and "_n" can be done to some other key as per your preference but I use ^K and ^L for this purpose.






VimTip	{{{1 118: Configuring gVim as Internet Explorer 'View Source' editor


Within the registry, you can specify the source editor to be used by Internet Explorer when {View|Source} is selected. Unfortunately, you can't specify a quoted filename argument here, i.e. "%1". The editor specified is supposed to handle filenames which contain spaces. This will cause problems for Vim because Vim treats each space as an argument separator. If an unquoted filename contains spaces, Vim treats the filename as multiple arguments and will open multiple files instead of one. To workaround this problem a quoted filename has to be passed to Vim. This can be done by creating the following Visual Basic Script file gVim.vbs:

'--- gVim.vbs -----------------------------------------------------------------
'function: Start gvim, combining multiple arguments to single file argument.
'changes:  20010905: Quoted 'oWShell.Run' filename argument, allowing spaces.
'          20010518: Created.
'author:   Freddy Vulto <fvu@fvu.myweb.nl>

  ' Making variable declaration mandatory
option explicit

dim oWShell, sArg, sFile

  ' Create script object
set oWShell = CreateObject("wscript.shell")
  ' Loop through arguments
for each sArg in wscript.arguments
    ' Add argument to filename
  sFile = sFile & sArg & " "
next
  ' Remove excess space
sFile = Trim(sFile)
  ' Run Vim with file argument.  Additional arguments:
  ' -R: View file readonly
  ' -c "set syntax=html": Use HTML syntax-highlighting
  '    NOTE: Use "-c ""set ft=html""" to make it work for Vim v6.
oWShell.Run _
  """D:\Programs\Vim\Vim58\gvim.exe """ & _
  "-R """ & sFile & """ " & _
  "-c ""set syntax=html"""

  ' Destroy script object
set oWShell = NOTHING


The source editor now can be specified by adding the following key to the registry:


HKEY_LOCAL_MACHINE
|- Software
   |- Microsoft
      |- Internet Explorer
         |- View Source Editor
            |- Editor Name       (Default) = D:\Programs\Vim\gvim.vbs


Freddy Vulto <fvu@fvu.myweb.nl>
http://fvu.myweb.nl/Projects/Vim/Web/vim.htm






VimTip	{{{1 119: Explorer startup and shutdown



I really like the new explorer window, but I wanted it to function a little more seemlessly in the editor.  The following code does two things.  First, the explorer is started when vim is started.   I also noticed and fixed that the explorers size is not equal to the window size, hence the strange behavior when popping between two windows.  The other major function of the code is to close the explorer when it's the only window that's left.  I'd actually like to take this a step further and close the window if the last _document_ window is closed.  I'd prefer that multiple explorers or help windows don't keep the application running - only having a file open keeps the application running.  But I didn't see an easy way to do this... anyone else?

BTW, thank you Bram for the help figuring this out.

Code (which currently lives in my _vimrc):

" FILE BROWSER STARTUP
func OpenFileWindow()
	" :runtime plugin/*.vim		" this would be useful if you were calling this
				"   function from the .vimrc directly
	let g:explDetailedList=1	" show size and date by default
	let g:explVertical=1		" Split vertically
	let g:explStartRight=0    	" Put new explorer window to the left of the current window
	:Sexplore
	set nonu
	set winwidth=15		" Make the width of the window match the explorer setting
	"let g:explVertical=0		" Split vertically
	doautocmd fileExplorer BufEnter " Forces the directory refresh to occur
	:winc l			" change to the document window
endfunc
	
func CloseIfLast()
	if exists("b:completePath")	" this is how I determine that I'm in an explorer window
		let n = winnr()
		wincmd p
		if n == winnr()
			quit	" quit the window
		endif
		wincmd p
	endif
endfunc

if has("autocmd")
	if !exists("rudyautocommands")
		let rudyautocommands = 1
		autocmd VimEnter * call OpenFileWindow()
		autocmd WinEnter * call CloseIfLast()

	endif
endif









VimTip	{{{1 120: Compiling Java with Sun JDK (javac) within VIM


The $VIMRUNTIME/compiler has 'jikes.vim', but there's nothing for traditional Sun JDK(javac),
so I tried (Only tested on Win 2000):

" Vim Compiler File    javac.vim
" Compiler:	Sun/IBM JDK: Javac

if exists("current_compiler")
  finish
endif
let current_compiler = "javac"

" Javac defaults to printing output on stderr and no options can convert, so we have to set 'shellpipe'
setlocal shellpipe=2> 
" 2> works on Win NT and UNIX
setlocal makeprg=javac\ #<.java
setlocal errorformat=%f:%l:%m
" Sorry I'm not familiar with 'errorformat', so I set it very simple.







VimTip	{{{1 121: Using vim as a syntax-highlighting pager


If you want to use Vim's syntax highlighting in a "more"-style pager, here's
one way to set it up:

First, create a vimrc like the following -- I called mine ~/.vimrc.more

---8<---cut here---8<---
" No compatibility -- necessary for mappings to work.
set nocompatible

" Status line
set laststatus=0
set cmdheight=1
set nomodifiable	" Only in version 6.0
set readonly

" Syntax colouring -- lines taken from syntax.txt discussion on colour xterms.
" See ':help color-xterm'. Use appropriate lines for your own set-up.
if has("terminfo")
    set t_Co=16
    set t_Sf=[3%p1%dm
    set t_Sb=[4%p1%dm
else
    set t_Co=16
    set t_Sf=[3%dm
    set t_Sb=[4%dm
endif
" My xterms have a navy-blue background, so I need this line too.
set background=dark
" Turn syntax on
syntax on

" Key bindings.
nmap b <C-B><C-G>
nmap q :q<CR>
" To type the following line, type *two* C-V's followed by two spaces. This
" is how you map the spacebar.
nmap ^V  <C-F><C-G>
---8<---cut here---8<---

Then, to use this .vimrc, add an alias. If you're using tcsh, the syntax will
be something like:

alias vmore "vim -u ~/.vimrc.more"

Then you can type "vmore [filename]" to view a file in this "pager". Spacebar
will move down, 'b' will move back up, and 'q' quits. You can add mappings for
other keys if you want to, also.






VimTip	{{{1 122: Skip blank lines when folding text.


I love the text folding capabilities of vim.  I didn't like that it would display the first line of the range as the "title" for the fold.  I like to write my comments with the "/*" on a line by itself.  So I wrote this little function that will skip over anything that isn't a character, and then display whatever it finds after that character.

Just include this in your ~/.vimrc (or ~/.gvimrc):

function GetFirstLineWithChars()
	let line_num = 0
	let charline = matchstr(getline(v:foldstart), '[a-zA-Z][a-zA-Z ]*')
	while strlen(charline) == 0
		let line_num = line_num + 1
		let charline = matchstr(getline(v:foldstart + line_num), '[a-zA-Z][a-zA-Z ]*')
	endw
	return charline
endfunction
set foldtext='+'.v:folddashes.substitute(GetFirstLineWithChars(),'\\\/\\\/\\\|\\*\\\|\\*\\\|{{{\\d\\=','','g')
set fillchars=fold: 
hi folded guibg=black guifg=yellow gui=bold

And as an added bonus, for those new to text folding, add this to your .vimrc file too:

autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview

That way whatever folds you set won't get lost when you quit.  I had that happen after spending 15 minutes folding up a 3000+ line file.  Happy vimming!






VimTip	{{{1 123: use functionality similar to the * search on multiple files


The use of star as in vimtip#1 and vimtip#5 is great, here is how to use this type of search accross a 
whole directory:
Just add the mappings (or choose different letter combinations):
map gr :grep <cword> *<cr>   
map gr :grep <cword> %:p:h/*<cr>   
map gR :grep \b<cword>\b *<cr>
map GR :grep \b<cword>\b %:p:h/*<cr>


mapping one will search for the word under the cursor (like g*) in any of the files in the current directory 
mapping two will search for the word under the cursor (like g*) in any of the files in the same directory as the current file
mapping three will search for the word under the cursor by itself (i.e. surrounded by word boundary like *) in any of the files in the current directory
mapping four will search for the word under the cursor by itself (i.e. surrounded by word boundary like *) in any of the files in the same directory as the current file

Benoit







VimTip	{{{1 124: Number a group of lines


Below is a way to number a set of lines.  Here is an exaple before and after snapshot:

apple
bob
pear
tree

1 apple
2 bob
3 pear
4 tree

" Description:
" This provides a command and a function.  They both can be called with or
" without a range.  In addition, they can be called with or without
" arguments.  Without a range they operate on the current line.
"
" There are two supported arguments.  They are described below:
"     arg1 -> the number to start at.  The default is one.  This will
"             number your selected lines sequentially.  The start can be a
"             number, ., $, or, 'x (like getline).
"     arg2 -> Text to append after numbers.  The default is a space.
"
" Examples:
"     To provide your functionality:
"         :%Nlist 20
"         :%call Nlist(20)
"     To make a list start at 1:
"         :'<,'>Nlist
"         :'<,'>call Nlist()
"     To number the whole buffer (with it's actual line number):
"         :%Nlist
"         :%call Nlist()
"     To number a subset of lines with their line number (and put a '] ' in
"     front of every number):
"         :'<,'>Nlist . ]\
"         :'<,'>call Nlist(".", "] ")

command! -nargs=* -range Nlist <line1>,<line2>call Nlist(<f-args>)
function! Nlist(...) range
    if 2 == a:0
        let start = a:1
        let append = a:2
    elseif 1 == a:0
        let start = a:1 
        let append = " "
    else
        let start = 1
        let append = " "
    endif

    " try to work like getline (i.e. allow the user to pass in . $ or 'x)
    if 0 == (start + 0)
        let start = line(start)
    endif

    exe a:firstline . "," . a:lastline . 's/^/\=line(".")-a:firstline+start.append/'
endfunction







VimTip	{{{1 125: Auto commenting for "}"


I always wanted a script that would auto-comment the end of a conditional block.  So, I wrote one.  This function searches for the previous matching "{", grabs the line, and inserts it as a comment after the "}".  If there is no previous matching "{", it inserts nothing.

So...

    if (test){


will generate:
    } // if (test)

This is obviously not work if you use a different style.  If you use 

   if (test)
   {

then substituting 'getline(".")', use  'getline(line(".") - 1)' should work.

Put the following in your .vimrc:
au BufNewFile,BufRead *.c,*.cc,*.C,*.h imap } <ESC>:call CurlyBracket()<CR>a
 
function CurlyBracket()
  let l:my_linenum = line(".")
  iunmap }
  sil exe "normal i}"
  imap } <ESC>:call CurlyBracket()<CR>
  let l:result1 =  searchpair('{', '', '}', 'bW')
  if (result1 > 0)
    let l:my_string = substitute(getline("."), '^\s*\(.*\){', '\1', "")
    sil exe ":" . l:my_linenum
    sil exe "normal a //" . l:my_string
  endif
endfunction






VimTip	{{{1 126: how do I get rid of that bold stuff with my xterm?


Having problems setting up your syntax highlighting because
everything is coming up in bold?

You're probably using an 8 color xterm and setting up highlighting
lines such as  hi Normal ... ctermfg=green .  The solution: use
numbers! 0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta,
6=cyan, and 7=white.  Vim tries to use "bright" colors when its
given names (because Windoz machines prefer to use dim text unless
its been made bold).

Read more about it under :help highlight-ctermfg .








VimTip	{{{1 127: Preview HTML files quickly


I've found while writing HTML files that it can become cumbersome when I have to switch to a web browser, load my page, and move back to VIM regularly to preview what I've written.  I've come up with the following tricks.

The first one requires that you have lynx (the text-based browser) installed on your computer (available from http://lynx.isc.org/release/).  If your HTML page is primarily text, with few (if any) images, you can set up the following function and mapping:

   function PreviewHTML_TextOnly()
      let l:fname = expand("%:p" )
      new
      set buftype=nofile nonumber
      exe "%!lynx " . l:fname . " -dump -nolist -underscore -width " . winwidth( 0 )
   endfunction

   map <Leader>pt  :call PreviewHTML_TextOnly()<CR>

This will open a new window and display your formatted HTML document in that window.  Note that bold-face, italics, links, etc. will be lost -- all you will see is the text -- but the "-underscore" parameter to Lynx causes any text that would have been bold, italicized, or underlined to be displayed like _this_.

The other trick requires that vim be running on your current machine, and that you be running a GUI of some sort (X-Windows, Windows, etc.).  You can cause vim to invoke your favorite browser and have it display the file, like this:
   function PreviewHTML_External()
      exe "silent !mozilla -remote \"openurl(file://" . expand( "%:p" ) . ")\""
   endfunction

   map <Leader>pp :call PreviewHTML_External()<CR>
If you don't use mozilla, you will need to modify the function to use your preferred browser.

Happy vimming!







VimTip	{{{1 128: grep, diff, patch, idutils, etc. for Windows systems


     If you use Vim on Windows, and you wish you had some of those nifty UNIX command-line tools,
but do not feel like installing all of Cygwin, you can get many of the most-used tools from Ron Aaron's
web site:
http://www.mossbayeng.com/~ron/vim/builds.html
Since Ron is a big Vim fan (see http://www.mossbayeng.com/~ron/vim/vimrant.html ) you can count on
these tools' working well with Vim.  For some hints on how to use them, read
:help :grep
:help lid
inside Vim.
     Happy Vimming!






VimTip	{{{1 129: Removing automatic comment leaders


     If you include the "r" flag in the 'formatoptions' option (:help 'fo' , :help fo-table ) then the comment leader is inserted
automatically when you start a new line in a comment.  For example, in TeX the "%" character is the comment leader,
and you might type

% This is a tex file.
% The comment leaders on all lines but the first were generated automatically.
% This is the last line of the comment, but Vim will insert the comment leader on the next line.
%

You can get rid of the comment leader (along with anything you may already have typed on the line) without affecting
the indent, if any, by typing "<C-U>" while in Insert mode.

     Related point:  if you want to adjust the indent while in Insert mode, you can use "<C-D>" (to Decrease the indent)
or "<C-T>" (to increase it).  In the docs for Vim 6.0, this is described in the users' manual, :help 30.4 .






VimTip	{{{1 130: disabling default ftplugins


     For an overview of ftplugins (filetype plugins) see

:help ftplugins

If you want to disable all ftplugins, or disable a particular default ftplugin, see

:help :filetype
:help ftplugin-overrule

If you have your own ftplugins, and you want to disable all the default ones, then
do NOT include a check for b:did_ftplugin in your ftplugin files, and add the line

:autocmd BufEnter * let b:did_ftplugin = 1

to your VIMRC file, BEFORE the ":filetype ftplugin on" line.






VimTip	{{{1 131: Scroll alternate window



This mapping allow you to quickly scroll inactive window when displaying several windows concurrently.

nmap <silent> <M-Down> :call ScrollOtherWindow("down")<CR>
nmap <silent> <M-Up> :call ScrollOtherWindow("up")<CR>

fun! ScrollOtherWindow(dir)
	if a:dir == "down"
		let move = "\<C-E>"
	elseif a:dir == "up"
		let move = "\<C-Y>"
	endif
	exec "normal \<C-W>p" . move . "\<C-W>p"
endfun

PS: Original idea and discussion of this tip appeared on vim@vim.org mailing list, I'm just prettified it a little.







VimTip	{{{1 132: window zooming convenience


i frequently have multiple windows open in vim -- this reduces the number of lines each window displays -- i almost always have my windows either all the same size or the current one as big as possible.

the following function can be toggled on or off by typing <Leader>max (i can do this quite quickly); just change the mapping at the bottom to something else if you prefer.

this causes the current window to be as big as possible (moving into another window causes that one to become big) and all the others get very small.  i actually use this ALL the time.  turning it off (by typing the hotkey sequence again) will cause all windows to have the same height.

"toggles whether or not the current window is automatically zoomed
function! ToggleMaxWins ()
  if exists ('g:windowMax')
    au! maxCurrWin
    exe "normal \<c-w>="
    unlet g:windowMax
  else
    augroup maxCurrWin
    " au BufEnter * exe "normal \<c-w>_\<c-w>\<bar>"
    "
    " only max it vertically
    au! BufEnter * exe "normal \<c-w>_"
    augroup END
    do maxCurrWin BufEnter
    let g:windowMax=1
  endif
endfunction
map <Leader>max :call ToggleMaxWins ()<CR>







VimTip	{{{1 133: Windo and Bufdo


i like bufdo and windo but i don't like the fact that the commands end in a different window/buffer than from where i executed them.  these versions (starts with a capital letter) will restore the current window or buffer when the command's done.

for example, to turn on line numbers everywhere, i use :Windo set nu -- :windo set nu does the trick also but leaves me in a different window than where i started.

" just like windo but restores the current window when it's done
function! WinDo(command)
  let currwin=winnr()
  execute 'windo ' . a:command
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" just like bufdo but restores the current buffer when it's done
function! BufDo(command)
 let currBuff=bufnr("%")
 execute 'bufdo ' . a:command
 execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)







VimTip	{{{1 134: View Source in IE6 using VIM


You can change the "View Source" editor of IE6 by adding the following to the Windows Registry. Change the path in case you installed VIM in another location.

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor\Editor Name]
@="C:\\vim\\vim60\\gvim.exe"







VimTip	{{{1 135: Vim buffer FAQ



Vim provides various commands and options to support editing multiple
buffers.  This document covers some of the questions asked about using
multiple buffers with Vim.  You can get more detailed information about Vim
buffer support using ":help windows.txt" in Vim.  You can also use the help
keywords mentioned in this document to read more about a particular command
or option.  To read more about a particular command or option use, ":help
<helpkeyword>" in Vim.

1. What is a Vim buffer?
   A buffer is a file loaded into memory for editing.  All opened files are
   associated with a buffer. There are also buffers not associated with any
   file.

   Help keyword(s): windows-intro

2. How do I identify a buffer?
   Vim buffers are identified using a name and a number.  The name of the
   buffer is the name of the file associated with that buffer.  The buffer
   number is a unique sequential number assigned by Vim.  This buffer
   number will not change in a single Vim session.

   Help keyword(s): :buffers

3. How do I create a buffer?
   When you open a file using any of the Vim commands, a buffer is
   automatically created.  For example, if you use the ":edit file" command
   to edit a file, a new buffer is automatically created.

4. How do I add a new buffer for a file to the buffer list without opening
   the file?
   You can add a new buffer for a file without opening it, using the
   ":badd" ex command.  For example,

       :badd f1.txt
       :badd f2.txt

   The above commands will add two new buffers for the files f1.txt and
   f2.txt to the buffer list.

   Help keyword(s): :badd

5. How do I get a list of all the existing buffers?
   You can get a list of all the existing buffers using the ":buffers" or
   ":ls" or ":files" ex command.  This list is called the 'buffer list'.

   In Vim 6.0, to display all the buffers including unlisted buffers, use
   the ":buffers!" or ":ls!" or ":files!" ex command.

   Help keyword(s): :buffers, :ls, :files

6. How do I delete a buffer?
   You can delete a buffer using the ":bdelete" ex command.  You can use
   either the buffer name or the buffer number to specify a buffer.  For
   example,

       :bdelete f1.txt
       :bdelete 4

   The above commands will delete the buffer named "f1.txt" and the fourth
   buffer in the buffer list.  The ":bdelete" command will remove the buffer
   from the buffer list.

   In Vim 6.0, when a buffer is deleted, the buffer becomes an
   unlisted-buffer and is no longer included in the buffer list.  But the
   buffer name and other information associated with the buffer is still
   remembered.  To completely delete the buffer, use the ":bwipeout" ex
   command.  This command will remove the buffer completely (i.e. the
   buffer will not become a unlisted buffer).

   Help keyword(s): :bdelete, :bwipeout

7. How do I delete multiple buffers?
   You can delete multiple buffers in several ways:

   1. Pass a range argument to the ":bdelete" command. For example,

           :3,5bdelete

      This command will delete the buffers 3, 4 and 5.
   2. Pass multiple buffer names to the ":bdelete" command.  For example,

           :bdelete buf1.txt buf2.c buf3.h

      This command will delete buf1.txt, buf2.c and buf3.h buffers.  In
      this example, after typing ":bdelete buf", you can press <Ctrl-A> to
      expand all the buffer names starting with 'buf'.

   Help keyword(s): :bdelete, :bwipeout

8. How do I remove a buffer from a window?
   You can remove a buffer displayed in a window in several ways:

   1. Close the window or edit another buffer/file in that window.
   2. Use the ":bunload" ex command. This command will remove the buffer
      from the window and unload the buffer contents from memory.  The
      buffer will not be removed from the buffer list.

   Help keyword(s): :bunload

9. How do I edit an existing buffer from the buffer list?
   You can edit or jump to a buffer in the buffer list in several ways:

   1. Use the ":buffer" ex command passing the name of an existing buffer
      or the buffer number.  Note that buffer name completion can be used
      here by pressing the <Tab> key.
   2. You can enter the buffer number you want to jump/edit and press the
      Ctrl-^ key.
   3. Use the ":sbuffer" ex command passing the name of the buffer or the
      buffer number.  Vim will split open a new window and open the
      specified buffer in that window.
   4. You can enter the buffer number you want to jump/edit and press the
      Ctrl-W ^ or Ctrl-W Ctrl-^ keys.  This will open the specified buffer
      in a new window.

   Help keyword(s): :buffer, :sbuffer, CTRL-W_^, CTRL-^

10. How do I browse through all the available buffers?
    You can browse through the buffers in the buffer list in several ways:

    1. To jump to the first buffer in the buffer list, use the ":bfirst" or
       ":brewind" ex command.
    2. To jump to the first buffer in the buffer list in a new window, use
       the ":sbfirst" or ":sbrewind" ex command.
    3. To edit the next buffer in the buffer list, use the ":bnext" ex
       command.
    4. To open the next buffer in the buffer list in a new window, use the
       ":sbnext" ex command.
    5. To edit the previous buffer in the buffer list, use the ":bprevious"
       or ":bNext" ex command.
    6. To open the previous buffer in the buffer list in a new window, use
       the ":sbprevious" or ":sbNext" ex command.
    7. To open the last buffer in the buffer list, use the ":blast" ex
       command.
    8. To open the last buffer in the buffer list in a new window, use the
       ":sblast" ex command.

    Help keyword(s): :bfirst, :brewind, :sbfirst, :sbrewind, :bnext,
                     :sbnext, :bprevious, :bNext, :sbprevious, :sbNext,
                     :blast, :sblast

11. How do I open all the buffers in the buffer list?
    You can open all the buffers present in the buffer list using the
    ":ball" or ":sball" ex commands.

    Help keyword(s): :ball, :sball

12. How do I open all the loaded buffers?
    You can open all the loaded buffers in the buffer list using the
    ":unhide" or ":sunhide" ex commands.  Each buffer will be loaded in a
    separate new window.

    Help keyword(s): :unhide, :sunhide

13. How do I open the next modified buffer?
    You can open the next or a specific modified buffer using the
    ":bmodified" ex command.  You can open the next or a specific modified
    buffer in a new window using the ":sbmodified" ex command.

    Help keyword(s): :bmodified, :sbmodified

14. I am using the GUI version of Vim (gvim), is there a simpler way for
    using the buffers instead of the ex commands?
    Yes.  In the GUI version of Vim, you can use the 'Buffers' menu, which
    simplifies the use of buffers.  All the buffers in the buffer list are
    listed in this menu.  You can select a buffer name from this menu to
    edit the buffer.  You can also delete a buffer or browse the buffer
    list.

    Help keyword(s): buffers-menu

15. Is there a Vim script that simplifies using buffers with Vim?
    Yes.  You can use the bufexplorer.vim script to simplify the process of
    using buffers.  You can download the bufexplorer script from:

        http://lanzarotta.tripod.com/vim.html

16. Is it possible to save and restore the buffer list across Vim sessions?
    Yes.  To save and restore the buffer list across Vim session, include
    the '%' flag in the 'viminfo' option.  Note that if Vim is invoked with
    a filename argument, then the buffer list will not be restored from the
    last session.  To use buffer lists across sessions, invoke Vim without
    passing filename arguments.

    Help keyword(s): 'viminfo', viminfo

17. How do I remove all the entries from the buffer list?
    You can remove all the entries in the buffer list by starting Vim with
    a file argument.  You can also manually remove all the buffers using
    the ":bdelete" ex command.

18. What is a hidden buffer?
    A hidden buffer is a buffer with some unsaved modifications and is not
    displayed in a window.  Hidden buffers are useful, if you want to edit
    multiple buffers without saving the modifications made to a buffer
    while loading other buffers.

    Help keyword(s): :buffer-!, 'hidden', hidden-buffer, buffer-hidden

19. How do I load buffers in a window, which currently has a buffer with
    unsaved modifications?
    By setting the option 'hidden', you can load buffers in a window that
    currently has a modified buffer.  Vim will remember your modifications
    to the buffer.  When you quit Vim, you will be asked to save the
    modified buffers.  It is important to note that, if you have the
    'hidden' option set, and you quit Vim forcibly, for example using
    ":quit!", then you will lose all your modifications to the hidden
    buffers.

    Help keyword(s): 'hidden'

20. Is it possible to unload or delete a buffer when it becomes hidden?
    The following works only in Vim 6.0 and above. By setting the
    'bufhidden' option to either 'hide' or 'unload' or 'delete', you can
    control what happens to a buffer when it becomes hidden.  When
    'bufhidden' is set to 'delete', the buffer is deleted when it becomes
    hidden. When 'bufhidden' is set to 'unload', the buffer is unloaded
    when it becomes hidden.  When 'bufhidden' is set to 'hide', the buffer
    is hidden.

    Help keyword(s): 'bufhidden'

21. How do I execute a command on all the buffers in the buffer list?
    In Vim 6.0, you can use the ":bufdo" ex command to execute an ex
    command on all the buffers in the buffer list.

    Help keyword(s): :bufdo

22. When I open an existing buffer from the buffer list, if the buffer is
    already displayed in one of the existing windows, I want Vim to jump to
    that window instead of creating a new window for this buffer.  How do I
    do this?
    When opening a buffer using one of the split open buffer commands
    (:sbuffer, :sbnext), Vim will open the specified buffer in a new
    window.  If the buffer is already opened in one of the existing
    windows, then you will have two windows containing the same buffer.
    You can change this behavior by setting the 'switchbuf' option to
    'useopen'.  With this setting, if a buffer is already opened in one of
    the windows, Vim will jump to that window, instead of creating a new
    window.

    Help keyword(s): 'switchbuf'

23. What information is stored as part of a buffer?
    Every buffer in the buffer list contains information about the last
    cursor position, marks, jump list, etc.

24. What is the difference between deleting a buffer and unloading a
    buffer?
    When a buffer is unloaded, it is not removed from the buffer list.
    Only the file contents associated with the buffer are removed from
    memory.  When a buffer is deleted, it is unloaded and removed from the
    buffer list.  In Vim 6, a deleted buffer becomes an 'unlisted' buffer.

    Help keyword(s): :bunload, :bdelete, :bwipeout, unlisted-buffer

25. Is it possible to configure Vim, by setting some option, to re-use the
    number of a deleted buffer for a new buffer?
    No.  Vim will not re-use the buffer number of a deleted buffer for a
    new buffer.  Vim will always assign the next sequential number for a
    new buffer.  The buffer number assignment is implemented this way, so
    that you can always jump to a buffer using the same buffer number.  One
    method to achieve buffer number reordering is to restart Vim.  If you
    restart Vim, it will re-assign numbers sequentially to all the buffers
    in the buffer list (assuming you have properly set 'viminfo' to save
    and restore the buffer list across vim sessions).

    Help keyword(s): :buffers

26. What options do I need to set for a scratch (temporary) buffer?
    The following works only in Vim 6.0 and above.  You can set the the
    following options to create a scratch (temporary) buffer:

        :set buftype=nofile
        :set bufhidden=hide
        :setlocal noswapfile

    This will create a buffer which is not associated with a file, which
    does not have a associated swap file and will be hidden when removed
    from a window.

    Help keyword(s): special-buffers, 'buftype'

27. How do I prevent a buffer from being added to the buffer list?
    The following works only in Vim 6.0 and above. You can prevent a buffer
    from being added to the buffer list by resetting the 'buflisted'
    option.

        :set nobuflisted

    Help keyword(s): 'buflisted'

28. How do I determine whether a buffer is modified or not?
    There are several ways to find out whether a buffer is modified or not.
    The simplest way is to look at the status line or the title bar.  If
    the displayed string contains a '+' character, then the buffer is
    modified.  Another way is to check whether the 'modified' option is set
    or not.  If 'modified' is set, then the buffer is modified.  To check
    the value of modified, use

        :set modified?

    You can also explicitly set the 'modified' option to mark the buffer as
    modified like this:

        :set modified

    Help keyword(s): 'modified'

29. How can I prevent modifications to a buffer?
    The following works only in Vim 6.0 and above. You can prevent any
    modification to a buffer by re-setting the 'modifiable' option.  To
    reset this option, use

        :set nomodifiable

    To again allow modifications to the buffer, use:

        :set modifiable

    Help keyword(s): 'modifiable'

30. How do I set options specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can set Vim options
    which are specific to a buffer using the "setlocal" command.  For
    example,

        :setlocal textwidth=70

    This will set the 'textwidth' option to 70 only for the current buffer.
    All other buffers will have the default or the previous 'textwidth'
    value.

    Help keyword(s): 'setlocal', local-options

31. How do I define mappings specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define mappings
    specific to the current buffer by using the keyword "<buffer>" in the
    map command.  For example,

        :map <buffer>  ,w  /[.,;]<CR>

    Help keyword(s): :map-local

32. How do I define abbreviations specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define
    abbreviations specific to the current buffer by using the keyword
    "<buffer>" in the :abbreviate command.  For example,

        :abb <buffer> FF  for (i = 0; i < ; ++i)

    Help keyword(s): :abbreviate-local








VimTip	{{{1 136: Remapping Alt, Ctrl and Caps in Win2k


Since I installed Win2K on my laptop, I had been unable to locate a utilitie that would simply enable me to remap my Crtl Alt and Caps the way I think they should be and the way they were until MS kill all competition in computing, that is Crtl on the left of the letter A, Alt to the left bottom of the letter Z and Caps approximately until the C.

After some research, I came across a tip posted here by juano@mindspring.com. I tried to make sense of it and then downloaded the MS scan keys map at the URL he mentionned.

Extrapolating his tip, I wrote this ASCI file that I named keys2000.reg :


Regedit4
[HKey_Local_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,04,00,00,00,3A,00,38,00,38,00,1D,00,1D,00,3A,00,00,00,00

Once you have saved this file, left click on it from Explorer and answer yes to the prompt "do you want to enter this into the registry".

Reboot and you are done.

A few explanations :04 stands for 3 remappings (Caps lock to Control, Control to Alt and Alt to Caps Lock) plus the closing one which is always required (1 remapping would require 02, 2 would require 03, and so on). 3A,00,38 remaps Caps to Left Alt, 38,00,1D remaps Left Alt to Left Ctrl and 1D,00,3A remaps Left Ctrl to Caps Lock since 3A=Caps, 1D=Left Ctrl and 38=Left Alt.

Based on Juano tip and on this one, I believe a lot of remapping can be done as long as you keep the separators 00 and remember to add one to the number of remappings. What I do not know is how far you can extend this instruction without getting into trouble with the registry. At worst, if you keyboard does not behave as expected, go into the registry and delete this instruction (be careful here since it is easy to confuse this instruction with the Keyboard LayoutS (S for emphasis) which must not be deleted.

Again, thanks to Juano@mindspring.com who got me going and suggested I post my tip. Took me some time to retrieve the VIM Url but fortunately, I had printed his tip.

Regards







VimTip	{{{1 137: automatically wrap left and right


I hate it when I hit left (or h) and my screen flickers.  I want it to go up to the next line.  Ditto fir right (or l).  Below are two functions / mappings to help with that.  I'm pretty sure that if you remove the <silent>, then it will work in 5.x...

nnoremap <silent> <Left>  :call WrapLeft()<cr>
nnoremap <silent> <Right> :call WrapRight()<cr>

nnoremap <silent> h       :call WrapLeft()<cr>
nnoremap <silent> l       :call WrapRight()<cr>

function! WrapLeft()
    let col = col(".")
    
    if 1 == col
        " don't wrap if we're on the first line
        if 1 == line(".")
            return
        endif
        normal! k$
    else
        normal! h
    endif
endfunction

function! WrapRight()
    let col = col(".")
    if 1 != col("$")
        let col = col + 1
    endif
        
    if col("$") == col
        " don't wrap if we're on the last line
        if line("$") == line(".")
            return
        endif
        normal! j1|
    else
        normal! l
    endif
endfunction






VimTip	{{{1 138: Getting name of the function


Hi All,
 
While browsing code one always needs to know which function you are currently looking. Getting the name is very painful when the functions are lengthy and you are currently browsing NOT near to the start of the function. You can get the function's name by using this simple mapping.
 
Just place this in your .vimrc.
 
map _F ma[[k"xyy`a:echo @x<CR>
 
now _F will display which function you are currently in.
 
Enjoy the power of Vim
-Nitin Raut

PS: The working is as follows, mark the current line with a, jump to the previous '{' in the first column, go one line up, yank the line in register x, return to the mark a, echo the value of register x, which is the wanted function name.                  






VimTip	{{{1 139: Alignment: =, LaTeX tables, declarations, etc


Check out

http://www.erols.com/astronaut/vim/textab.html

and see some examples of text alignment (its hopeless to do it here with
proportional fonts).  You'll be able to download textab source, a Windows-based
textab executable, and a scriptfile containing a convenient interface (ttalign.vim).  The textab program coupled with <ttalign.vim> lets you:

1. align C language statements on their = += -= /= etc symbols
2. align C language declararations: separate columns for types, *[, variable
   names, initializations (=), and comments (// or /* .. */)
3. align C/C++ language comments (//, /* .. */)
4. align C/C++ language (ansi) function argument lists
5. align LaTeX tables on their && separators
6. align HTML tables with </TD><TD> separators
7. align on several characters: < ? : | @ ;  (or modify them to handle whatever
   alignment characters you want)






VimTip	{{{1 140: tip using embedded perl interpreter


When writing scripts using the embedded interpreter available if vim has the +perl ore +perl/dyn on 
gives you access to this powerfull and FAST scripting language (especially fast compared to vim 
scripts)  there are some gotchas.

First:
never embed complex perl command in the body of a vim function this will be recompiled and evaled
each time for a tremendous loss of time.instead to it like this

perl << EOF
sub mySub
{
  #some usefull perl stuff
}
EOF

function! MyFunction
perl mySub "an argument", "another"
endfunction

to pass computed argument to your perl sub use the vim exec command
function! MyFunction
exec "perl mySub " . aLocalVar . ", " b:aBufferLocalVar
endfunction

It may be very hard to debug your perl sub since the output of the perl compiler is
somehow lost in the middle of nowhere and the debugger is not available.
When a compilation error occurs in your sub definition you'll get an error message
when you try to call it saying that the sub does not exists.
One thing which I have found very usefull is to write a fake VIM module with stub 
methods which will allow you to use the command line perl interpretor to at least
compile your program.  You could make your stub smart enough to fake a vim
and use the debugger.  Here is a sample for such a fake module defining just
those method which I was using.

package VIM;
use diagnostics;
use strict;
sub VIM::Eval
{
	$_ = shift;
	
	print "Eval $_\n";
	
	{
		  return '^(?!!)([^\t]*)\t[^\t]*\t(.*);"\t([^\t]*)\tline:(\d*).*$' if (/g:TagsBase_pattern/);
		  return $ARGV[0] if (/b:fileName/);
		  return '$3' if (/g:TagsBase_typePar/);
		  return '$1' if (/g:TagsBase_namePar/);
		  return '$4' if (/g:TagsBase_linePar/);
		  return 'Ta&gs' if (/s:menu_name/);
		  return $ARGV[1] if (/g:TagsBase_groupByType/);
		die "unknown eval $_"; 
	}  
}
sub VIM::Msg
{
	my $msg = shift;
	print "MSG $msg\n";
}
sub VIM::DoCommand
{
	my $package;
	my $filename;
	my $line;
    ($package, $filename, $line) = caller;
	
	my $command = shift;
	print "at $filename $line\n";
	print "DoCommand  $command\n";
}
1;


Then you can copy other your perl code in a separate file and add a use VIM; at the top
and your set to debug.

Good Vimming good perling.
Benoit
PS:
this tips are probably true for other scripting languages






VimTip	{{{1 141: Add your function heading with a keystroke


Below is a tip that the C/C++ Newbies may find interesting and handy to use.  The following code will add a function heading and position your cursor just after Description so that one can document as one proceeds with code.

function FileHeading()
	let s:line=line(".")
	call setline(s:line,"/***************************************************")
	call append(s:line,"* Description - ")
	call append(s:line+1,"* Author -      Mohit Kalra")
	call append(s:line+2,"* Date -        ".strftime("%b %d %Y"))
	call append(s:line+3,"* *************************************************/")
	unlet s:line
endfunction

imap <F4>  <esc>mz:execute FileHeading()<RET>`zjA

Where <esc> stands for ^V+ESC and <RET> for ^V+ENTER






VimTip	{{{1 142: Automatic function end commenting for C++ and Java


Some people have a habit of adding the function name as a comment to the end of that function, if it is long, so that he/she knows which function the '}' ends. Here's a way to automate the process.

Use the following abbreviation:
iab }// } // END: <esc>10h%$?\w\+\s*(<cr>"xy/\s*(<cr>/{<cr>:nohl<cr>%$"xpa

If you now end the function with '}//', the follwoing string will be automatically generated: '} //END: functionname'







VimTip	{{{1 143: Use of Vim folds for javadocs



Hi,

The fold-method marker can be effectively use to set the folds in your Java source.  Define some marker and place it inside HTML comments <!-- xx -->.  This way, it does not affect the Javadocs generated without the necessity of a seprate comment line.
e.g.


/**
 * <!-- zz.FOLDSTART class AbcClass -->
 * The class description.
 * ...
 */
public class AbcClass {

    /**
     * <!-- method zz.FOLDSTART someMethod() -->
     * Method description.
     */
    public void someMethod();

    ...

} /* zz.END: AbcClass */

/* Put this at the end of your file */
/* vim:fdm=marker fmr=zz.FOLDSTART,zz.END fdl=2 fdc=2: */

Now, the files will be opened with the methods neatly folded.
You can use "zR" to open all folds (or click on the "+" at the left column).

Sameer.







VimTip	{{{1 144: recording keystrokes by "q" for repested jobs



The most useful feature that I find in VIM is the "recording" feature (:help recording).  I have used this to automatically insert function headers, re-indent lines, and convert some 34 source files into HTML.

This feature is most useful when you want to do some repeated jobs, which you cant do easily using ".".  You can set about writing a function, define a mapping, etc, but then these things might take time.  By recording, you can try out and find the actual keystrokes that does the job.

To start recording, press "q" in normal mode followed by any of "0-9a-z".  This will start recording the keystrokes to the register you choose.  You can also see the word "recording" in the status(?) line.  You can start the key sequences that you want to record.  You can go to insert mode and type if you want.

To stop recording, press "q" in the normal mode.

To playback your keystrokes, press "@" followed by the character you choose.  Pressing "@@" will repeat the same again.

Sameer.







VimTip	{{{1 145: Changing DOS style end of line to UNIX, or vise-versa


Those of us doomed to work in both the Unix and Windows world have many times encountered
files that were create/editted on systems other that the one we are on at the time of our edits.  We
can easily correct the dreaded '^M' at the end of our Unix lines, or make files have more than one
line in DOS by:

To change from <CR><LF> (DOS) to just <LF> (Unix):
:set fileformat=unix
:w

Or to change back the other way:
:set fileformat=dos
:w

It also works for Apple land:
:set fileformat=mac
:w


And to tell the difference:
set statusline=%<%f%h%m%r%=%{&ff}\ %l,%c%V\ %P
                                              ^^^^^  This shows what the current file's format is.

Happy Vimming!






VimTip	{{{1 146: opening multiple files from a single command-line


i use the :split command a lot -- both to open a second window containing the currently edited file and to edit a new file altogether (with the :split <filename> option).  however, i also like to be able to edit more than one file and calling :sp multiple times is inconvenient.  so, i created the following command, function and abbreviation:

function! Sp(...)
  if(a:0 == 0)
    sp
  else
    let i = a:0
    while(i > 0)
      execute 'let file = a:' . i
      execute 'sp ' . file

      let i = i - 1
    endwhile
  endif
endfunction
com! -nargs=* -complete=file Sp call Sp(<f-args>)
cab sp Sp


this retains the behaviour of :sp in that i can still type :sp (the abbreviation takes care of that).  :Sp takes any number of files and opens them all up, one after the other.

the things i have noticed are that this causes 'sp' to be expanded to 'Sp' everywhere, even in search patterns.  also, prepending 'vert' doesn't work.  if there is interest, i'll do that.






VimTip	{{{1 147: How to write a plugin


This tip gives a skeleton for writing a plugin; Vim's help files have plenty
of details (:he plugin, :he write-plugin, :he plugin-details).

# ------------------------------------------------------------------------------
# Exit when your app has already been loaded (or "compatible" mode set)
if exists("loaded_YourAppName") || &cp
  finish
endif

# Public Interface:
#  AppFunction: is a function you expect your users to call
#  PickAMap: some sequence of characters that will run your AppFunction
# Repeat these three lines as needed for multiple functions which will
# be used to provide an interface for the user
if !hasmapto('<Plug>AppFunction')
  map <unique> <Leader>PickAMap <Plug>AppFunction
endif

# Global Maps:
#  
map <silent> <unique> <script> <Plug>AppFunction 
\ :set lz<CR>:call <SID>AppFunc<CR>:set nolz<CR>

# ------------------------------------------------------------------------------

# AppFunction: this function is available vi the <Plug>/<script> interface above
fu! <SID>AppFunction()
..whatever..

# your script function can set up maps to internal functions
nmap <silent> <left> :set lz<CR>:silent! call <SID>AppFunction2<CR>:set nolz<CR>

# your app can call functions in its own script and not worry about name
# clashes by preceding those function names with <SID>
call <SID>InternalAppFunction(...)

# or you could call it with
call s:InternalAppFunction(...)
endf
# ------------------------------------------------------------------------------

# InternalAppFunction: this function cannot be called from outside the
#  script, and its name won't clash with whatever else the user has loaded
fu! <SID>InternalAppFunction(...)
..whatever..
endf

# ------------------------------------------------------------------------------

Plugins are intended to be "drop into <.vim/plugin>" and work.  The problem
that the <Plug>, <SID>, etc stuff is intended to resolve: what to do about
functions that have the same names in different plugins, and what to do about
maps that use the same sequence of characters?  The first problem is solved
with <SID> (a script identifier number) that vim assigns: program with it and
your users will be happier when your stuff works with all their other stuff.
The second problem: what to about those maps is addressed with <Plug>, <unique>,
etc.  Basically the idea is: let the user know that there are clashes and don't
overwrite previously existing maps.  Use the user's preferred map-introducer
sequence (I like the backslash, but there are many keyboards which make
producing backslashes unpleasant, and those users usually prefer something
else).

What I like to do is to have a pair of start/stop maps to reduce my impact on
the namespace.  When the starting map is used, it kicks off a starting function
that introduces all the maps needed.  When the stopping map is used, it not
only removes the maps the starter made but restores any maps the user had had
that would have clashed.  I also use the start/stop pair of functions to set
and restore options that cause my scripts difficulties.

Check out DrawIt.vim's SaveMap() function for a way to save user maps.
Restoring maps with it is easy:

if b:restoremap != ""
 exe b:restoremap
 unlet b:restoremap
endif

So you can see it sets up a string variable with all the maps that the user
had that would have clashed with my application.

One final thing: if your application needs to share information between its
various functions, see if you can use s:varname (a variable that only your
script's functions can access) or b:varname (a variable that anything associated
with the buffer your application is running with can access) instead of using
global variables.

Good luck and happy Vimming!







VimTip	{{{1 148: Make great use of those homemade menus


Accidently discovered that using <alt><Menu Hotletter><cr> (e.g <alt>b<cr> - for the buffer menu) causes the menu to break out in a seperate window.  
Selecting the menu with the mouse and then hitting enter does not seem to do it. 

I will have to learn to add hotletters to my menus now so that the mouse can take a break.

I am a total newbie with vim, but constantly amazed.... 






VimTip	{{{1 149: Automatically update your diff upon writing.


When trying to reconcile differences between files, and using the new
'diff' functionality in Vim 6.0 you may want to automatically update
the differences as you are working along.  A convienent time is when you
write out either of the files you are diff'ing.  This autocmd will take
care of doing that for you.


" If doing a diff.  Upon writing changes to file, automatically update the
  " differences
  au BufWritePost                  *              if &diff == 1
  au BufWritePost                  *              :diffupdate
  au BufWritePost                  *              endif







VimTip	{{{1 150: Generating a column of increasing numbers


You can use the "Visual Incrementing" script from

  http://www.erols.com/astronaut/vim/index.html#VimFuncs

to convert a block of numbers selected via ctrl-v (visual block)
into a column of increasing integers.  Select the column, press :I<CR>,
and the first line's number will be used as a starting value.  Subsequent
lines's numbers will be incremented by one.

If the ctrl-v block is "ragged right", which can happen when "$" is used
to select the right hand side, the block will have spaces appended as
needed to straighten it out.  If the strlen of the count exceeds the
visual-block allotment of spaces, then additional spaces will be inserted.

Example:  Put cursor on topmost zero, select column with ctrl-v, then :I

   vector[0]= 1;       vector[0]= 1;
   vector[0]= 1;       vector[1]= 1;
   vector[0]= 1;  -->  vector[2]= 1;
   vector[0]= 1;       vector[3]= 1;
   vector[0]= 1;       vector[4]= 1;

This script works with both vim 5.7 (:so visincr.vim) or vim 6.0 (source it
as for vim 5.7 or drop it into the .vim/plugin directory).








VimTip	{{{1 151: an ascii table


There is an ascii table in the vim-help files, but it's hard to find.  Thus, I shall give a pointer to it:

:help digraph-table






VimTip	{{{1 152: Spelling checkers for: Dutch, English, German, Hungarian, and Yiddish


Under http://www.erols.com/astronaut/vim/index.html#vimlinks_scripts
are links to spelling checkers for Dutch, English, German, Hungarian,
and Yiddish, all based on the original engspchk.vim.  The spelling
checker provides as-you-type spell checking; with vim6.0 it will avoid
checking on partially typed words.

Provided are several maps:

  \et : add  word under cursor into database for just this file
  \es : save word under cursor into database (permanently)
  \en : move cursor to the next     spelling error
  \ep : move cursor to the previous spelling error
  \ea : look for alternative spellings of word under cursor

To use \ea you will need agrep:

  agrep source: ftp://sunsite.unc.edu/pub/Linux/utils/text/agrep-2.04.tar.Z
  agrep Win exe: http://www.tgries.de/agrep

To use the spell checkers just source it in:

  ex.  so engspchk.vim

To read more about it see

  http://www.erols.com/astronaut/vim/index.html#Spelling







VimTip	{{{1 153: Making Parenthesis And Brackets Handling Easier


1) ++++++++++++++++++++++++++ "Automatic" bracket setting +++++++++++++++++++++++++++++
2) +++++++++++++ Further improvement of parenthesis/bracket expanding +++++++++++++++++
3) ++++++++++++++++++++++++++++ "Late" bracketing of text +++++++++++++++++++++++++++++
4) +++++++++++++++++++++++++++++ Conclusion ++++++++++++++++++++++++++++++++++++++ ++++

=======================================================================================

1) ++++++++++++++++++++++++++ "Automatic" bracket setting +++++++++++++++++++++++++++++ 

To automatically insert a closing parenthesis when typing an opening
parenthesis you can insert the following simple mapping to your vimrc:

	:inoremap ( ()<ESC>i

This ends up with the cursor between the opening and the closing parenthesis
in insert mode.

You can apply this and the following tips, of course, with the kind of parenthesis/bracket
character you want to, i.e. (, {, [, < ..... and, pretty useful as well,
quotation marks ",',.... (to be continued)

2) +++++++++++++++ Further improvement of parenthesis/bracket expanding ++++++++++++++++++

I you are ready with filling the parenthesis/brackets, you likely want to
"escape" from the brackets again to continue coding.
To make this pretty comfortable, I invented the following kind of mappings, which get out
of the last expanded parenthesis/bracket, regardless of the actual type of it, and
enter append mode again.
I mapped this kind of "getaway" with CTRL_j, you may use your favorite keystroke with it.

			...
	:inoremap ( ()<ESC>:let leavechar=")"<CR>i
	:inoremap [ []<ESC>:let leavechar="]"<CR>i
			...
	:imap <C-j> <ESC>:exec "normal f" . leavechar<CR>a

Explanation: The variable "leavechar" contents the actual char which is to "escape" from.


3) ++++++++++++++++++++++++++++ "Late" bracketing of text +++++++++++++++++++++++++++++

Occasionally I later want already written text parts to put in parenthesis.

I use the following macro, which brackets previously visually selected text.
I mapped it with _(.

	:vnoremap _( <ESC>`>a)<ESC>`<i(<ESC>

Furthermore, a sort of mapping for bracketing a *single word* is conceivable.
Because this is not as general like the kind of visual mode mapping, I use
this kind of "word bracketing" only for surrounding the word right behind the cursor in insert mode with **.  I use the following macro to "emphasize" the word i just typed,
for newsgroup articles.

	:imap _* <Esc>bi*<Esc>ea*<Space>


4) ++++++++++++++++++++++++++++++ Conclusion ++++++++++++++++++++++++++++++++++++++++++

Since I use these macros, I never caused a syntax error because of missing
brackets, and furthermore I can quickly insert parenthesis and qutotes into code-
and non-code files.

 JH 04.11.2001







VimTip	{{{1 154: Mappings to facilitate the creation of text


" 
" Mappings to facilitate the creation of text
"
" Author:  Suresh Govindachar sgovindachar@yahoo.com
" Date:     November 5, 2001
"
" While typing text to create a document, I often end up hitting
" <Esc>, issuing some commands (with or without ":") and getting back 
" to typing by issuing a command such as "i", "O", "s" etc.
"
" I looked into using "set insertmode" to speed up such actions, but
" found that too confusing. 
"
" I have come up with a set of mappings that have speeded up my process
" of creating documents.  I have saved these mappings in a file, named
" FullScreenVI.vim, in vim's plugin directory.
"
" Perhaps you will find these mappings helpful too.
"
" Please send me feedback.  
" 

"To allow overriding the Alt key
set winaltkeys=no  
"To enable viewing messages from commands issued using the mappings presented here 
set cmdheight=2    

"The fundamental mapping that makes full-screen editing possible
imap <A-o>  <C-o>
imap <A-;>  <C-o>:

"Basic motions
imap <A-h>  <Left>
imap <A-j>  <Down>
imap <A-k>  <Up>
imap <A-l>  <Right>
imap <A-f>  <PageDown>
imap <A-b>  <PageUp>
imap <A-^>  <Home>
imap <A-$>  <End>

"Numbers for repeats
imap <A-1>  <C-o>1
imap <A-2>  <C-o>2
imap <A-3>  <C-o>3
imap <A-4>  <C-o>4
imap <A-5>  <C-o>5
imap <A-6>  <C-o>6
imap <A-7>  <C-o>7
imap <A-8>  <C-o>8
imap <A-9>  <C-o>9

"Basic searches
imap <A-/>  <C-o>/
imap <A-*>  <C-o>*
imap <A-#>  <C-o>#
imap <A-n>  <C-o>n
imap <A-N>  <C-o>N

"Deleting
imap <A-x>  <C-o>x
imap <A-d>  <C-o>d
imap <A-D>  <C-o>D

"Yanking and putting
imap <A-y>  <C-o>y
imap <A-Y>  <C-o>Y
imap <A-p>  <C-o>p
imap <A-P>  <C-o>P

"Common prefixes:  marking, matching etc.
imap <A-~>  <C-o>~
imap <A-m>  <C-o>m
imap <A-`>  <C-o>`
imap <A-">  <C-o>"
imap <A-%>  <C-o>%
imap <A-h>  <C-o>:h
imap <A-s>  <C-o>:s

"Interacting with the 'outside'
imap <A-!>  <C-o>:!
imap <A-w>  <C-o>:w<CR>
imap <A-e>  <C-o>:e

"Other commands
imap <A-u>  <C-o>u
imap <A-.>  <C-o>.







VimTip	{{{1 155: Decompile Java .class files automatically



Here's a plugin to automatically decompile Java .class files as they're read in.  Tweak the javap flags for what you want to see.  I didn't post this as a script because it's too simple and it's really more useful for demonstrating how to read decompilable files (or other binary files that can be converted to text).

function s:ReadClass(dir, classname)
    execute "cd " . a:dir
    execute "0read !javap -c " . a:classname
    1
    setlocal readonly
    setlocal nomodified
endfunction


autocmd BufReadCmd *.class
    \ call <SID>ReadClass(expand("<afile>:p:h"), expand("<afile>:t:r"))








VimTip	{{{1 156: describe <table name> from vim


i had some trouble with the sqlplus scripts (probably my fault).  but it seemed a little heavy for what i need, usually all i want is a listing of the columns for a given table while i'm whipping on some sql inside vim.

so i wrote a bash script (describe)...

~~~~~~~~~~~~~~~begin describe script
#!/usr/bin/bash

f=aTempFile.sql
u=<uName>
p=<pWord>
d=<dBase>

echo "/* describe for $1"
echo "describe $1;" > $f;
echo "quit;" >> $f;

sqlplus -S $u/$p@$d @$f
rm -f $f;
echo " end describe for $1 */"
~~~~~~~~~~~~~~~end describe script

your path needs to include the script (as well as sqlplus), then from vim you can just type....

:r !describe <tableName>

and you get a listing of the table columns slammed into wherever your cursor was, complete with java/c comments







VimTip	{{{1 157: Incredible new functionality


if you get away from vim and get any other editor that was built *after* 1970....






VimTip	{{{1 158: Using Computer Modern TT as gvim font (Win32)


If you really like the Computer Modern typewriter font (as seen in most TeX distributions) you can use it as the font in gvim! (looks excellent with font smoothing turned on)

First, get hold of the free Blue Sky Type 1 PS versions of the CM fonts from your local CTAN mirror. Unpack to a suitable directory.

Next locate the cmtt8.pfb file and open it (in Vim, naturally ;) - find the line
saying
dup 32 /visiblespace put

and change it to
dup 32 /space        put

that is, inserting enough spaces to keep the file size exactly the same
(IMPORTANT!)

Save the file in Mac format (:set fileformat=mac).

Now install the cmtt.pfm file - in Win9x/NT4, you'll need Adobe Type Manager
(free download), but in Win2k, you can just drop the .pfm file into the Fonts folder.

Now in your _gvimrc:
set guifont=CMTT8:h11:cSYMBOL

(use whatever height you like instead of h11)

..and enjoy! It's the first scalable font I can bear to edit code in... %-)







VimTip	{{{1 159: Keystroke Saving Substituting and Searching


1) ++++++++++++++ Saving Keystrokes for common Searching and Substituting +++++++++++
--- a) Searching  b) Substituting ---------------------------------------------------
2) ++++  Searching for resp. Substituting of the current word under the cursor ++++++
--- a) Searching  b) Substituting ---------------------------------------------------
3) ++ Searching and Substituting for an arbitrary visually selected part of text ++++
--- a) Searching  b) Substituting ---------------------------------------------------
4) ++++++++++++++++++++++++++++++++  Conclusion +++++++++++++++++++++++++++++++++++++

=====================================================================================

1) ++++++++++++++ Saving Keystrokes for common Substituting and Searching +++++++++++

a) Searching ............
Sorry, there is not much that can be saved for common Searching. It's just hitting
/mypattern<RETURN> 

b) Substituting .........
I think, common substitution requires pretty many keystrokes. So I use the
following macro with my favorite substitution options:

:map <F4> :%s//gc<Left><Left><Left>

This ends up with the cursor after the first '/' in the commandline. To complete it,
you only have to enter
->	myoldpattern/mynewpattern<RETURN>

Remark: I mapped it to <F4> (cause of tribute to the <F4> of the good old Norton
Commander editor). You may map it where you want to.


2) ++++  Searching for resp. Substituting of the current word under the cursor ++++++

a) Searching ............
If you don't know how to look for the next occurence of the word under the cursor, you
should *now* type
:help * or
:help star
or refer to the tips vimtip #1 or vimtip #5
((Tip within tip: To make your pattern more visible, look for :help hls))

b) Substituting .........
The following macro extends the one above with automatically inserting the current word
under the cursor into the from - pattern of the :s command.

:map <S-F4> :%s/<C-r><C-w>//gc<Left><Left><Left>

To complete it, just enter
->	mynewpattern<RETURN>

I use this i.e. for reliable and quickly renaming a variable in the entire buffer.
I mapped it to Shift-<F4>. You may map it to the keystroke you want.

Explanation: CTRL-v+CTRL-w expands to the word under the cursor.


3) ++ Searching and Substituting for an arbitrary visually selected part of text ++++

If you want to look or substitute (for) an *arbritary* pattern (which already exists at
least once in your text), the following 2 mappings do it for you.
The advantage is that you dont have to type again or cut & paste the appropriate text
but only have to visually select it.

a) Searching ...........

:vmap / y:execute "/".escape(@",'[]/\.*')<CR>

This immediately finds to the next occurence of the previously visually selected text.


b) Substituting .........

:vmap <F4> y:execute "%s/".escape(@",'[]/\')."//gc"<Left><Left><Left><Left>

Again, as in the mapping in chapter 2), you just have to complete it by entering
-> mynewpattern<RETURN>

Explanation/Discussion:
What both Substituting and Searching in this way generally does is:
- *y*anking the selected text
- Inserting the visually selected via adressing the '"' register with '@"' as a
  parameter of the escape() function going finally into the 'myoldpattern' part.
  The trickery problem is, if you have characters in your myoldpattern, which are
  regular expression chars, they are recognized and threated accordingly.  That
  is most likely not what you wanted.  To escape them, these chars have to be
  declared by the second parameter of the excape() function, which then escapes them
  with a backslash.  The few characters above work for me. If you run into problems,
  you should check for additional regexp chars in your text, and try to escape them
  by adding them to the escape() function parameter.


4) ++++++++++++++++++++++++++++++++  Conclusion +++++++++++++++++++++++++++++++++++++

With the appropriate mappings in your vimrc you can save keystrokes when Searching or
Substituting and avoid typing errors. That way, you can take lunch sooner







VimTip	{{{1 161: Dutch spelling checker


Download at http://www.thomer.com/thomer/vi/nlspchk.vim.gz.

This sciript is based on Charles E. Campbell's English spelling checker script for ViM (http://users.erols.com/astronaut/vim/) and Piet Tutelaers' Dutch word list (http://www.ntg.nl/spell-nl-v5b/) using  Thomas Köhler's script (http://jeanluc-picard.de/vim/gerspchk/create). In other words, I didn't do much.






VimTip	{{{1 162: write plugin with explorer like interfaces


Several plugins use a text base interface based on a special buffer, this is the case of the standard explorer plugin, several bufexplorer plugins, the option buffer and others...
Here is a quick guide in how to do this


Writing a special buf script
	| using a special buffer is a common technic when writing Vim scripts, it is used by
	| explorer, bufexplorer, DirDiff...
	| I'm currently writing one for TagsBase.vim 
	| http://vim.sourceforge.net/scripts/script.php?script_id=100 
	| and I'll use this document to take notes on how to do it.
	| 

Setting up the buffer
	Opening the window TODO

	Using a setup function
		Principle
			| we can use a specific function to open and setup the special buffer. s:SetupBuf()
		Setup Function advantage
			| since the command will be defined in the main script you
			| can use script local functions
	Using a special filetype
		Principle
			| we can also use a new filetype and distribute a syntax and an ftplugin for this 
			| filetype, the only thing needed in this case is to set the
			| filetype after creating the buffer
		Filetype advantage
			| better separations of different parts of your script. If
			| the main function of your plugin is not to have this
			| special buffer then it is nice to avoid clutering it.
	Things which needs to be done to setup the buffer
		The buffer should not be listed and does not correspond to a file
			* setlocal buftype=nofile
			-	options always local to buffer
			* set nobuflisted 		
			* set bufhidden=delete
			* set nomodifiable
		Setup the syntax for this buffer
			| see :help syntax
			| This is usually done in two steps, first describe the
			| syntax groups using :syn commands then setup the
			| hilighting using :hi def link commands.  Usually it is
			| best to link the newly defined groups to predefine ones in
			| order to make the coloring work fine with colorschemes.
			| You'll find the list of predefined group by doing:
			| :help group-name
		Setup the special mappings
			| since we have chosen to use the set nomodifiable option
			| our buffer will never be in insert mode. All our mapping
			| are in Normal, Visual or operator pending, they should
			| therefore use the map, nmap, vmap and omap mapping command
			| plus the associated 'nore' version.  I usually find it
			| better to use the 'nore' version to avoid surprises due to
			| mapping in the user configuration.
			|
			| We also want our mappings to be local to the special
			| buffer so all the commands will use the <buffer> modifier.
			|
			| Finally we want our mappings not to polute the status bar
			| so we use the <silent> modifier
			| 
			| Putting all this together we end up with mapping commands
			| which look like:
			| noremap <buffer> <silent> {lhs} {rhs}
		Setup the special command
			| we will then setup special commands for this buffer.  Like
			| for the mapping there are some precautions to take:
			| we don't want an error message if the command is defined
			| twice so we use the command! variant.
			| We want a command local to our buffer wo we use the
			| -buffer attribute.  The rests of the command attributes
			|  and options depend on the actual command.
			|  So our commands look like:
			|  command! -buffer {attr} {cmd} {rep}
			|  where attr is optional.







VimTip	{{{1 163: Toggle Search Highlighting


" Map H to toggle search highlighting
map H :let &hlsearch = !&hlsearch<CR>






VimTip	{{{1 164: Make non-ASCII characters displayed on console


I had a problem with VIM on the FreeBSD console: it didn't display characters like German umlauts correctly, but escaped them with a tilde. The solution is to teach VIM about printable characters. I use the following on my .vimrc:

set isprint=@,128-255






VimTip	{{{1 165: Deleting a buffer without closing the window


I'm not sure if this functionality is already within Vim, but I sometimes I find it useful to keep a split window from closing when deleting a buffer.  This has already been discussed on the vim@vim.org mailing list.  However, I feel this solution is a little easier to use.


" Put this into .vimrc or make it a plugin.
" Mapping :Bclose to some keystroke would probably be more useful.
" I like the way buflisted() behaves, but some may like the behavior
" of other buffer testing functions.

command! Bclose call <SID>BufcloseCloseIt()

function! <SID>BufcloseCloseIt()
	let l:currentBufNum = bufnr("%")
	let l:alternateBufNum = bufnr("#")

	if buflisted(l:alternateBufNum)
		buffer #
	else
		bnext
	endif

	if bufnr("%") == l:currentBufNum
		new
	endif

	if buflisted(l:currentBufNum)
		execute("bdelete ".l:currentBufNum)
	endif
endfunction







VimTip	{{{1 166: Mapping caps lock to esc in XWindows


(This originally appeared on the vim mailing list as post by Adam Monsen http://groups.yahoo.com/group/vim/message/19856)

If you want to completely swap caps lock and escape, you have to replace the 
"Lock" on caps lock. Drop this file in your home dir:<br>
-----------start------------<br>
! Swap caps lock and escape<br>
remove Lock = Caps_Lock<br>
keysym Escape = Caps_Lock<br>
keysym Caps_Lock = Escape<br>
add Lock = Caps_Lock<br>
------------end-------------<br>
and call it ".speedswapper". Then open a terminal and type<br>
$ xmodmap .speedswapper<br>
and you'll be twice as efficient in vim. Who needs caps lock anyway? The swapping lasts for the duration of the X session, so you can put it in a .xinitrc or similar startup file. As far as other people using my laptop, I'd rather they didn't! Using a Dvorak layout might protect me even more... :)







VimTip	{{{1 167: Using vim as a man-page viewer under Unix


To use vim as a man-page viewer involves setting an environment variable:

    sh, ksh:  export MANPAGER="col -b | view -c 'set ft=man nomod nolist' -"
    csh    :  setenv MANPAGER "col -b | view -c 'set ft=man nomod nolist' -"

Put one of the above two lines into your <.profile> or <.login> file as
appropriate for your shell.

The man pages will then be displayed with vim called as "view" and will use
the <man.vim> syntax highlighting.  I myself use some additional highlighting
which is enabled by putting the following file into <.vim/after/syntax/man.vim>.
I usually use the <astronaut> colorscheme (also available from this archive);
those who use bright backgrounds may find the colors selected for
manSubSectionStart and manSubSection something they'll want to change:

  ---------------------------------------------------------------------
" DrChip's additional <man.vim> stuff

syn match  manSectionHeading    "^\s\+[0-9]\+\.[0-9.]*\s\+[A-Z].*$" contains=manSectionNumber
syn match  manSectionNumber     "^\s\+[0-9]\+\.[0-9]*"              contained
syn region manDQString          start='[^a-zA-Z"]"[^", )]'lc=1      end='"'         contains=manSQString
syn region manSQString          start="[ \t]'[^', )]"lc=1           end="'"
syn region manSQString          start="^'[^', )]"lc=1               end="'"
syn region manBQString          start="[^a-zA-Z`]`[^`, )]"lc=1      end="[`']"
syn region manBQSQString        start="``[^),']"                    end="''"
syn match  manBulletZone        transparent "^\s\+o\s" contains=manBullet
syn case    match
syn keyword manBullet contained o
syn match   manBullet contained "\[+*]"
syn match   manSubSectionStart  "^\*"   skipwhite nextgroup=manSubSection
syn match   manSubSection       ".*$"   contained

hi link manSectionNumber    Number
hi link manDQString         String
hi link manSQString         String
hi link manBQString         String
hi link manBQSQString       String
hi link manBullet           Special
hi manSubSectionStart       term=NONE cterm=NONE gui=NONE ctermfg=black ctermbg=black guifg=navyblue guibg=navyblue
hi manSubSection            term=underline cterm=underline gui=underline ctermfg=green guifg=green
set ts=8
  ---------------------------------------------------------------------
 







VimTip	{{{1 168: Viewing the actual XPM data in GVIM


GVIM has an excellent syntax highlighting for XPM images, but sometimes it's useful to view the actual data. This can be achieved by searching for everything, type in "/." and all characters will be highlighted and therefore the old colouring is lost. To regain the normal highlighting you can search for a non-existent sequence, like "/foo".






VimTip	{{{1 169: <Tab> = <C-I> and <Esc> = <C-[>


     An FAQ on the vim users' mailing list is whether <Tab> and <C-I>
can be mapped to different things.  The answer is no.  As I understand
it, this is a low level issue:  <Tab> and <C-I> are different names
for the same ASCII code, and there is no way for vim to tell them
apart.  Similarly, <Esc> and <C-[> are the same thing.






VimTip	{{{1 170: Repeating a sequence of commands without defining a macro


Imagine.

You have just finished a complicated modification of a file, 
involving numerous replace commands :%s/xxx/yyyy/g, 
and other ex commands.

Then you realize, you have done it a little bit wrong, 
and you have to begin all the operation again, 
just to change one replace string, or do one more operation
"somewhere 10 commands ago".

Or you realize, you will have to do the same stuff tomorrow 
with another file.

or you realize, you want to perform the same sequence
of commands, you have typed a few days ago

You should have made it a macro (normal command q), 
but you haven't.

Nothing is lost yet.

You go to the command line (by typing :)
and press Ctrl+F.
(Ctrl+F in other modes scrolls the screen)

You get a temporary window, listing the history of command line.
It is possible to yank appropriate lines here,
make a new file called $VIMRUNTIME/macros/something.vim
put those lines here, edit them and save

see
:help cedit


Then you can call the macro using 
:source something.vim


You might want to set variable 'history' to a higher
number then default in your vimrc file
like
:set history=300
see
:help history
:help vimrc









VimTip	{{{1 171: Do you know the "g/" and "g?" commands?


Directly from the Vim Todo list:

7   For Visual mode: Command to do a search for the string in the marked area.
    Only when less than two lines. Use "g/" and "g?".


In other words, a way to search for visually selected text !!  :-)

"==== vsearch.vim ====

" Visual mode search

vmap g/ :call VsearchPatternSave()<cr>/<c-r>/<cr>
vmap g? :call VsearchPatternSave()<cr>?<c-r>/<cr>

function! VsearchPatternSave()
  let l:temp = @@
  normal gvy
  let @/ = substitute(escape(@@, '/\'), "\n", "\\\\n", "g")
  let @@ = l:temp
  unlet l:temp
endfunction

"==== END ====


Normally, this file should reside in the plugins directory and be automatically
sourced. If not, you must manually source this file using ':source vsearch.vim'.

In Visual mode, highlight the text for searching.  Then you can use the
default visual key mappings

g/ - search forwards
g? - search backwards

Visual searches behave like normal searches.  The 'n' and 'N' commands
work as they should, and the search history correctly records each search.
Multi-line searches behave as they should (this corrects the 'yank-only'
method mentioned in the Vim help files).  Block visual searches do not work
yet.  Hopefully, someone can figure out a way to do this easily.

I've only tested this on Win2000 and Redhat Linux 7.1.  I'm not really clear
on how the carriage returns are dealt with on other systems.

Anyway, enjoy!






VimTip	{{{1 172: Using Ispell on a highlighted region


Suppose you would like to use Ispell to check a word or region that you've
visually highlighted.  The following macro will do the job.  Just type
Shift-Insert while in visual mode.

vnoremap <S-Insert> <C-C>`<v`>s<Space><Esc>mq:e ispell.tmp<CR>i<C-R>"<Esc>:w<CR>:! xterm -bg ivory -fn 10x20 -e ispell %<CR><CR>:e %<CR><CR>ggVG<Esc>`<v`>s<Esc>:bwipeout!<CR>:!rm ispell.tmp*<CR>`q"_s<C-R>"<Esc>

This is based on Chip Campbell's macro which uses Ispell on the whole file
(in normal mode).

noremap <S-Insert> :w<CR>:! xterm -bg ivory -fn 10x20 -e ispell %<CR><Space>:e %<CR><Space>

Carl Mueller






VimTip	{{{1 173: Switch between splits very fast (for multi-file editing)


I am a Web developer and I use Vim as my primary editor. 

Most programming projects (and Web programming projects, in particular) are spread out over multiple files, which you often want to have open concurrently. If you don't already know, Vim supports this very well! Just use:

:sp name-of-another-file-to-edit

My problems were that (1) it took too long to move between files, and (2) the files were taking up too much room on the screen. 

(1) In order to move to the file in the split above my current window, I was typing Ctrl-W, Up (move up a window) Ctrl-W, _ (maximize the menu). That's four keystrokes (more if you count Ctrl and Shift), and they are all over the keyboard. To help avoid this problem, I created this mapping in my .vimrc:

map <C-J> <C-W>j<C-W>_
map <C-K> <C-W>k<C-W>_

Now I can hold down Ctrl and move between windows with the standard Vim movement keys. Much, much quicker!

(2) By default, Vim displays the current line of each minimized file, which (to me) isn't much help and takes up too much screen real estate. I use this line in my .vimrc:

set wmh=0

This sets the minimum window height to 0, so you can stack many more files before things get crowded. Vim will only display the filename. 

Hope this helps those of you who are working on projects with large numbers of files you're constantly flipping through. Happy Vimming! 






VimTip	{{{1 174: Footnotes


ab (1 [1]<esc>:/^--\s/-1/<cr>o<insert><cr>Footnotes:<cr>----------<cr>[1]
ab (2 [2]<esc>:/^Footnotes\:/+2/<cr>o<insert>[2]
ab (3 [3]<esc>:/^Footnotes\:/+3/<cr>o<insert>[3]
ab (4 [4]<esc>:/^Footnotes\:/+4/<cr>o<insert>[4]
ab (5 [5]<esc>:/^Footnotes\:/+5/<cr>o<insert>[5]







VimTip	{{{1 175: how to make VIM as ur default editor even without root ac.


hi,
if u have installed vim in your home directory somewhere
and u don't have a root account, and you want to
make VIM the default editor for anything u do.
i.e if ur using SQLplus and want to edit a sql command.
normally typing edit brings up the vi editor and not vim editor.
to solve this problem.
define these three variables in your .profile
VIM=<base directory where vim executable is placed>
VIMRUNTIME=<base direcoty where vim runtimes are kept>
EDITOR=$VIM/vim 

note if u have installed vim with another name, say vim.exe then
change EDITOR=$VIM/vim to EDITOR=$VIM/vim.exe

source the .profile and viola. next time u start an editor from any
program u have the vim editor.

Njoy.






VimTip	{{{1 176: Autocheckout from perforce


The following code automatically checks out files from perforce when the user modifies them. It first confirms the check-out with the user.

(Perforce is a commercial version control system.  I imagine this could be modified for RCS, CVS, etc., but I don't use those.)

I'm a vim newbie -- I've used vi since 1984, but just started with vim a couple days ago.  Color me impressed!  Please excuse any stupidity in the code..

Note that this function needs the "P4HOME" environment variable to be set.  I could extract it by invoking "p4 client", but I don't want to invoke p4 every time I start vim.  So I assume the user sets it in the environment.

" Set a buffer-local variable to the perforce path, if this file is under the perforce root.
function IsUnderPerforce()
    if exists("$P4HOME")
        if expand("%:p") =~ ("^" . $P4HOME)
            let b:p4path = substitute(expand("%:p"), $P4HOME, "//depot", "")
        endif
    endif
endfunction
" Confirm with the user, then checkout a file from perforce.
function P4Checkout()
   if exists("b:p4path")
        if (confirm("Checkout from Perforce?", "&Yes\n&No", 1) == 1)
            call system("p4 edit " . b:p4path . " > /dev/null")
            if v:shell_error == 0
                set noreadonly
            endif
        endif
    endif
endfunction

if !exists("au_p4_cmd")
    let au_p4_cmd=1

    au BufEnter * call IsUnderPerforce()
    au FileChangedRO * call P4Checkout()
endif







VimTip	{{{1 177: Highlight matching brackets as one moves in normal mode (plugin)


Check out http://www.erols.com/astronaut/vim/index.html#VimFuncs for
a plugin script which highlights matching brackets.  The script has
two always-on maps:
	\[i   : start [HiMtchBrkt] mode
	\[s   : stop [HiMtchBrkt] mode
The plugin will save all user maps and options that the plugin uses and
will restore them when the mode is stopped.







VimTip	{{{1 178: Making a "derived" colorscheme without copy & paste


Suppose there's a colorscheme that you're pretty fond of, but hate one or two particular aspects about.  For example, I love the "blue" colorscheme that ships with vim, but I find it's colors for the non-active status line to be unreadable.  Here's how to create a colorscheme which extends "blue" without copying it to a new file and editing it.

In my ~/.vim/colors, I created a "my-blue.vim" file with these contents:

"these lines are suggested to be at the top of every colorscheme
hi clear
if exists("syntax_on")
   syntax reset
endif

"Load the 'base' colorscheme - the one you want to alter
runtime colors/blue.vim

"Override the name of the base colorscheme with the name of this custom one
let g:colors_name = "my-blue"

"Clear the colors for any items that you don't like
hi clear StatusLine 
hi clear StatusLineNC

"Set up your new & improved colors
hi StatusLine guifg=black guibg=white
hi StatusLineNC guifg=LightCyan guibg=blue gui=bold

That's all there is to it.






VimTip	{{{1 179: Simplify help buffer navigation



Vim is distributed with comprehensive help system, which has basic hyperlink support - 
you can press <C-]> over |some subject| or 'some option' to read more about particular term.

The following mappings simplify help buffer navigation:
pressing s(or S) will find next(previous) subject from cursor position
pressing o(or O) will find next(previous) option from cursor position
pressing Enter will jump to subject under cursor
pressing Backspace will return from the last jump

Put them into help filetype plugin (like ~/.vim/ftplugin/help.vim on UNIX).

nmap <buffer> <CR> <C-]>
nmap <buffer> <BS> <C-T>
nmap <buffer> o /'[a-z]\{2,\}'<CR>
nmap <buffer> O ?'[a-z]\{2,\}'<CR>
nmap <buffer> s /\|\S\+\|<CR>
nmap <buffer> S ?\|\S\+\|<CR>








VimTip	{{{1 180: Reload your filetype/syntax plugin


Ever tried to write/debug your own  filetype/syntax plugin?

It's an iterative process which involves editing plugin code and testing it on some
sample file. To see changes you made in your plugin simply do :e on sample file.
This will force Vim to reload all buffer-specific files, including your plugin.







VimTip	{{{1 181: get the vim patched source


Hi,
there has been a number of person (including) asking in the vim list how to keep up with Bram's incredible bug correction 
and patch writing skills, but there is a great way to do this!
Use the cvs source which is available at http://sourceforge.net/cvs/?group_id=8
it is kept up to date and its a lot easier than applying all the patch in order.
Benoit






VimTip	{{{1 182: Keep your cursor centered vertically on the screen


i hope i don't hear a collective 'DUH!' from around the world but i just did this and i think it's kinda cool.

in your .vimrc add...

map j jzz
map k kzz

so whenever you go up or down, vim does that and then re-centers.
obviously it doesn't work when you page up/ down.







VimTip	{{{1 183: Select a buffer from those matching a pattern


The :bu command will take a pattern as an argument and jump to the matching buffer.  However, it's not very helpful if there is more than one buffer matching the pattern.  In that case, it will jump to the first match, which may not be what you want.  The following function and user-command will print a list of the matching buffers in the command-line area, and allow you to select one of the matching buffers by number.

"Select from buffers matching a certain pattern
"the 'pattern' argument shouldn't be prepended with a slash

function! BufSel(pattern)
   let bufcount = bufnr("$")
   let currbufnr = 1
   while currbufnr <= bufcount
      if(bufexists(currbufnr))
         let currbufname = bufname(currbufnr)
         if(match(currbufname, a:pattern) > -1)
               echo currbufnr . ":      ". bufname(currbufnr)
         endif
      endif
      let currbufnr = currbufnr + 1
   endwhile
   let desiredbufnr = input("Enter buffer number: ")
   if(strlen(desiredbufnr) != 0)
      exe ":bu ". desiredbufnr
   endif
endfunction

"Bind the BufSel() function to a user-command
command! -nargs=1 Bs :call BufSel("<args>")








VimTip	{{{1 184: How to obscure text instantaneously


Hi,
Lets say your writing some imp. doc. and your colleague
comes along. you don't wan't him to see what you are typing.
so u start fumbling to type :wq! or switch with Alt-TAB. etc.
but wouldn't it be nice to just obsucre the text temporarily,
so that u don't have to quit or swith to another application using Alt-tab.
(and if u don;t have any other window open u can;t even use alt-tab)
well rot-13 comes to help. vim has a built in rot-13 encoder.

jut put the follwoing in your .vimrc

map <F3> ggVGg?

so next time some body comes along just press <F3> and all the buffer will 
be rot-13 encoded. to decode just press <f3> again.
Njoy






VimTip	{{{1 185: Make vim the editor for files with unregistered extensions in Windows


Normally in Windows, if you try to "launch" a file whose extension is not registered with the system, the OS will prompt you for what editor you would like to use to open the file.  A much more appealing solution, in my mind, is to make vim the default editor for any unregistered extension.  

To set vim up as the default editor for unregistered extensions, follow these steps:
1. Copy the following into a file named unregistered.reg
-------------begin unregistered.reg-----------------
REGEDIT4
[HKEY_CLASSES_ROOT\Unknown\shell\Open\Command]
@="d:\\program files\\vim\\vim60\\gvim.exe \"%1\""
-------------end unregistered.reg-----------------

2. Import unregistered into your registry.  This can be done in vim by executing the following
:!regedit "unregistered.reg"

Disclaimer: This has been tested only on NT4.






VimTip	{{{1 186: Making search powerful


My tip is just a bunch of mappings that can be used while searching.








VimTip	{{{1 187: Making search powerful


(Sorry, I think I accidentally added an incomplete tip)

My tip is just a bunch of mappings that can be used while searching.
What it does?
  o. Extend your current search. (kinda emacs search where you can search each occurences 
      one by one and go back to the cursor position.
  o. Scroll/position during mapping.
  o. Other miscellaneous stuffs ;) read on

How to use?
   o. copy and paste the mappings into a file
   o. open vim (like vim .profile)
   o. :so <saved-file>
   o. start using the mappings

Note:
   In case these mappings dont work run like, 'vim -u NONE -U NONE -c "so the-saved-file.vim"'

   Some of my mappings override the default vim bindings. (like Ctrl-A, Ctrl-Q). I
   selected those because, I feel by taking those I can do all the search stuff with
   my left hand.

   One thing I did not like with this is, I usually miss the "search hit bottom" message. I could have
   handled that by complicating the current mappings, but I preferred to make it simple

Mappings Used
/          => regular forward search start
?         => regular backward search start
Rest of the mappings are used during search
Ctrl-A  => search again forward (In normal mode, search forward with the word under cursor)
Ctrl-Q  => search again backward (in normal mode, search backward with the word under cursor)
Ctrl-X  => restore cursor (use at any point of time/during-any-operation mentioned during searching)
Ctrl-F  => search with the word under cursor
Ctrl-G  => incrementally add the letters following the search pattern (in current line)
Ctrl-T Ctrl-T => search for the exact
Ctrl-T Ctrl-Y => search partial (just strips \< and \>)
Ctrl-E  => scroll up during searching
Ctrl-Y  => scroll down during searching
Ctrl-Z Ctrl-Z => position the cursor to mid of screen (like zz in normal)
Ctrl-Z Ctrl-A => position the cursor to top of screen (like zt in normal)
Ctrl-Z Ctrl-X => position the cursor to bottom of screen (like zb in normal)

Misc:
Ctrl-K during search save the current matching line
Ctrl-K in normal mode pastes the saved line

C mappings
Ctrl-V Ctrl-G search for the global variable of the search pattern/word under cursor
Ctrl-V Ctrl-H search for the local variable of the search pattern/word under cursor

" --- cut n paste from here to end of document ---
se nocp incsearch
" core mappings
noremap  / mg/
noremap  ? mg?
ounmap /
ounmap ?
noremap <C-A> mg"gyiw/<C-R>g
cnoremap <C-A> <CR>/<Up>
cnoremap <C-X> <CR>`g
cnoremap <C-Q> <CR>?<Up>

" extending current search mappings
cnoremap <C-F> <CR>yiw<BS>/<C-R>"
cnoremap <C-G> <CR>y/<Up>/e+1<CR><BS>/<C-R>=escape(@",'.*\/?')<CR>

" miscellaneous: copy current line during search and later paste in NORMAL mode
cnoremap <C-K> <CR>"hyy?<Up><CR>/<Up>
noremap <C-K> "hp

" exact/partial search mappings
cnoremap <C-T><C-T> <Home>\<<C-End>\>
cnoremap <C-T><C-Y> <Home><Del><Del><End><Del><Del>

" C global/local variable search mappings
noremap <C-V><C-G> mgyiw<CR>gg/\<<C-R>"\>
noremap <C-V><C-H> mgyiw?^{<CR>/\<<C-R>"\>
cnoremap <C-V><C-G> <CR>yiwgg/\<<C-R>"\>
cnoremap <C-V><C-H> <CR>yiw?^{<CR>/\<<C-R>"\>

" positioning/scrolling during search mappings
cnoremap <C-E> <CR>mt<C-E>`t<BS>/<Up>
cnoremap <C-Y> <CR><C-Y><BS>/<Up>
cnoremap <C-Z><C-A> <CR>zt<BS>/<Up>
cnoremap <C-Z><C-X> <CR>zb<BS>/<Up>
cnoremap <C-Z><C-Z> <CR>zz<BS>/<Up>

" VISUAL mappings
vnoremap / ymg/<C-R>=escape(@",'.*\/?')<CR>
vnoremap ? ymg?<C-R>=escape(@",'.*\/?')<CR>








VimTip	{{{1 188: Searching for more than one word at the same time.


Did you know that with VIM u can search for more
than one word with a single command. 
say you want to search all occurances of "bill" or "ted", or
"harry" in a text.
in normal mode do the following.
/\(bill\)\|\(ted\)\|\(harry\) <Enter>

this will match all instances of either "bill", or "ted", or "harry" in your
text. the key is the \(\) and \| operators.
\(\) group characters in a word and \| is for ORing.

this is so cool u can even use it for replacing text.
to replace all instances of "bill" or "ted" or "harry" with "greg"
do the following
:%s/\(bill\)\|\(ted\)\|\(harry\)/greg/g <enter>
(note :- if u have set the option "gdefault" u don't need the "g" at the
end of the above command)

I don't know of any other editor which can do this, with so much ease.
Rock on VIM
Njoy






VimTip	{{{1 189: Make Ctrl-Backspace delete previous word (like GTK inputs)


Stuff this into your ~/.gvimrc and then you'll be able to type Control-Backspace to delete the previous word.  I had gotten so used to C-BS working a certain way in all my editors with a ceezy input area (like mozilla/galeon, gabber, etc...), that I wanted the same behaviour when I used gvim.

" map control-backspace to delete the previous word
:imap <C-BS>        <Esc>vBc

Simple, I know, but reasonably useful.

--Robert






VimTip	{{{1 190: XP > I-Explorer > HTML Editor < REG files


The issue is permitting other programs, besides NOTEPAD,
be the HTML editor under Internet Explorer. 
(Adding "Edit" as a New Action in the publicly exposed
Files Types for HTM/L does NOT do the job.)

Given below are two REG files for vim. 
Just cut 'em up where indicated.
They have been tested under Windows XP.


-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: Set gvim as HTML editor in Internet Explorer 6.0
; Vim version : 6.0
; Windows version: XP 
; EASY USAGE: name this file iex-vim60.reg and double click on it
; Hard Usage: IMPORT this file using REGEDIT.EXE found in c:\WINDOWS 
; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe"
; Be sure to also reset Explorer>Tools>Internet Options>Programs

; Microsoft documentation
; http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp

; Add Vim in the list of supported HTML editors
[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit\command]
@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""

; Do NOT add to .html, registry for .htm type suffices
;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit\command]
;@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""


; OPTIONAL: Within Internet Explorer "View Source" with gvim
; but prefer to use Edit button (got to add this) on Toolbar
;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]

;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor\Editor Name]
;@="C:\\Program Files\\Vim\\vim60\\gvim.exe"

; ============================================= EOF

-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: UNINSTALL gvim as HTML editor in Internet Explorer 6.0
; Vim version : 6.0
; Windows version: XP 
; EASY USAGE: name this file iex-vim60-uninstall.reg and double click on it
; Hard Usage: IMPORT this file using REGEDIT.EXE found in c:\WINDOWS 
; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe"
; Be sure to also reset Explorer>Tools>Internet Options>Programs

; Microsoft documentation
; http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp


[-HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[-HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

[-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]


; ============================================= EOF
-------------------------------------------------------CUT HERE---------------

Happy Vimming...






VimTip	{{{1 191: Transposing


You can easily move lines with these maps using <C-Up> and <C-Down> (only in GUI version :( )
(Works in normal, insert, and visual mode, but you can't add a count to them)
" Transposing lines
nmap <C-Down> :<C-u>move .+1<CR>
nmap <C-Up> :<C-u>move .-2<CR>

imap <C-Down> <C-o>:<C-u>move .+1<CR>
imap <C-Up> <C-o>:<C-u>move .-2<CR>

vmap <C-Down> :move '>+1<CR>gv
vmap <C-Up> :move '<-2<CR>gv

" Transpose chars (like Ctrl-T in emacs, shell...)
imap <C-F> <Esc>Xpa






VimTip	{{{1 192: Latex Help for VIM


LaTeX Help for aucTeX `translated' as vim help file.

Installing

:help add-local-help






VimTip	{{{1 193: Insert the current filename at cursor postion.


I found this one good for when I was starting to learn Java, it simply inserts the current filename, at the cursor position, when you are in insert mode.  Honestly, its a mish-mash of some other tips I found here, but I thought it might be useful.

imap \fn   <C-R>=expand("%:t:r")<CR>

Enjoy!






VimTip	{{{1 194: Inserting text in multiple lines


Do you know the I key in visual-block mode?

Suppose you have
let a=2
let b=3
let c=4

You want to make these variables script-wise. Then you move to over a, hit <C-v>, press jj and now press I.
You will be in insert mode before a
Now enter s:<Esc>, and when you press <Esc>, b and c will have the s: prefix too.
See |v_b_I|

Happy vimming!
Gergely Kontra






VimTip	{{{1 195: Switching between files


When you edit multiple files, you often need to change windows.
You can set up vim in windows and gvim to switch between windows with the commonly used Ctrl-Tab and Ctrl-Shift-Tab
The mappings
nmap <C-Tab> <C-w>w
nmap <C-S-Tab><C-w>W
(They wrap around)
See also |Ctrl-w|






VimTip	{{{1 196: FileName Completion in Shell Scripts


In shell scripts, you often define environment variables for diff directory names.
i.e.
JAVA_HOME=/opt/java/jdk1.4
PATH=/usr/local/bin:/bin....

Normally typing Ctrl-X Ctrl-F is used to complete FileName under cursor.
But this does not work if used on lines given above.
This is because vim treats "=" sign as a valid filename character.
Since the actual possibility of "=" being in any filename is very less, this
char can be removed from the list of valid filename char.

set isfname-==

putting the above line in .vimrc will remove "=" from the list of valid filename chars.
thus u can easyly complete filenames using <Ctrl-X> <Ctrl-F>
Njoy






VimTip	{{{1 197: Open file in already running vim from elsewhere


If you want edit new file, and you  want do it  in alrady running vim, instead of launching another instance, you may use --remote argument:

gvim first_file
gvim --remote +split first_file

:he --remote
It requires X windows (but works in terminal version of vim there too) or MS windows and built-in client-server mechanism. If there are several instances of vim already running, you may choose to which you talk using --servername
:help --servername






VimTip	{{{1 198: Pasting code with syntax coloring in emails


When sending code snippets or diffs to your colleagues either for code review or for something else as email, how nice and clear it will be if you can paste it with the Vim syntax highlighting? I am sure they will be impressed and feel much easier to read the code. It is also very easy and fast (once you practice it) to do this.

This probably works only on windows and requires you to use Internet Explorer and an email client that understand RTF content coming from clipboard, such as Outlook or Outlook Express. At least that would make the process faster. I haven't tried on any other combination though. This is what you need to do:

- Open the file containing the code/code snippet/diff etc. in gvim. If you use dark background for GVim (like me), then I would suggest you to change your color scheme temporarily to something else that has a white background or just use the "-U NONE" as below:

    gvim -U NONE <file>

- Convert the file into HTML by using the following command at the colon prompt as below:

    :runtime syntax/2html.vim

- The above step will open a new window with the HTML content in it. You might want to just save it with the suggested name or write into a temporary file as:

    :w! c:/tmp/t.html

- Open the IE browser window and open the above temp file "c:/tmp/t.html".
- Now you select all (press ^A) and copy it (^C).
- You are ready to paste it with syntax coloring in any application that accepts RTF content from clipboard, including Outlook or Outlook Express mail composing window.







VimTip	{{{1 199: maximize window and return to previous split structure


Say you have layed out a complex window split structure, and want to temporarily open 1 window with max dimensions, but don't want to lose your split structure.  The following function and mappings let you toggle between the split windows and on window maximized. The mappings prevent the default behavior of calling :only and losing your finely tuned splits.

Put this bit in your vimrc file, change mappings if you don't want to override the defaults:

nnoremap <C-W>O :call MaximizeToggle ()<CR>
nnoremap <C-W>o :call MaximizeToggle ()<CR>
nnoremap <C-W><C-O> :call MaximizeToggle ()<CR>

function! MaximizeToggle()
        if exists("s:maximize_session")
                source s:maximize_session
                call delete(s:maximize_session)
                unlet s:maximize_session
                let &hidden=s:maximize_hidden_save
                unlet s:maximize_hidden_save
        else
            	let s:maximize_hidden_save = &hidden
                let s:maximize_session = tempname()
                set hidden
                mksession! s:maximize_session
                only
        endif
endfunction







VimTip	{{{1 200: Bouncing Parentheses (during insertion)


When one is inserting parentheses some folks like to see the cursor
bounce off the matching parenthesis.  To do that, put the following
map into your <.vimrc> file:

    inoremap ) )<c-o>%<c-o>:sleep 500m<CR><c-o>%<c-o>a

Adjust the time delay (its 500 milliseconds above) to suit your needs.






VimTip	{{{1 201: The meaning of life


Use this tip if you need to discover the meaning of life, the universe and everything.

Simply do:
:h 42






VimTip	{{{1 202: debugging window autocommands


Don't know how people debug autocommands, but I just found out that you can debug (at least) those that result due to window close by just doing a debug quit, i.e.,

:debug quit

Vim will let you step into the autocommands. Try it to believe.






VimTip	{{{1 203: Make make more helpful


I find this a very useful command to use.
Add the below 4 lines to your vimrc.
Then instead of "make" use "Make".

" Command Make will call make and then cwindow which
" opens a 3 line error window if any errors are found.
" if no errors, it closes any open cwindow.
:command -nargs=* Make make <args> | cwindow 3






VimTip	{{{1 204: Some mappings for using cscope with vim.


These mappings can make using cscope a fun. You can copy the word under the cursor in one window, and search for it from other window.

" Copy and paste the word under cursor
map <silent> <C-Space> :let@m=expand("<cword>")<CR>

" Use the C-Space word as the search criterion
map <C-F6> :cscope find s <C-R>=@m<CR><CR>
map <C-F5> :cscope find c <C-R>=@m<CR><CR>
map <C-F7> :cscope find g <C-R>=@m<CR><CR>







VimTip	{{{1 205: Computing a sum of numbers in vim


"Sometimes you need to sum a some numbers in vim.  There *are* some plugins
"that can do the job.  But what if the numbers are not in a columns or are on
"the same line or are sacttered all across the file? You might also need to
"sum all the numbers in file that look like '1234$', or '54565 Eu'  ignoring others.
"
"There is a very simple trick, using (my favourite) command 
":s
"
"First you define following function

:let g:S=0 		"In global variable S we later find the result

:function! Sum(number)		"The function is defined with a '!',
				"so it does not complain during debugging
				"when you are redefining the function
	:let g:S=g:S+a:number	"we accumulate the result in global variable S
	:return a:number	"function returns the argument, so after a :s
				"command the text remains the same
:endfunction

"you can do issue those few commands from a command line, 
"or create a small file and put it into your plugin directory,
"or write those few commands into a file end issue a command :so %



"how to use this little function:
"let's suppose you have a simple column of numbers like
"
"10
"20
"30
"
"you issue command like:
:let S=0
:%s/[0-9]\+/\=Sum(submatch(0))/
"the command finds the first number on the line and adds it to the S
"
"the result is displayed 
:echo $S

"!!!! don't forget to do
:let g:S=0 
"before use.

"you can also use \zs and \ze atoms in a regular expression to 
"delimit the number, so submatch(0) returns only a number and 
"the text remains unchanged after 'substitute'


"for starter on the wonderfull world of regular expressions see:
:help usr_27.txt

"for the definition of the search pattern see 
:help :s
:help pattern

"for replacement strings begining with \= and special function submatch(0)see 
:help sub-replace-special

"for the *ultimate* guide through the world of regular expressions see book:
"Mastering Regular Expressions
"Powerful Techniques for Perl and Other Tools
"by Jeffrey E.F. Friedl
"from O'REILLY

"the book does not write about vim, yet here you can learn that
":s command is the most powerfull command you can find in a text editor. 
"(with the possible exception of :global command)







VimTip	{{{1 206: Highlight doubled word errors in text


An error I sometimes make while working on a LaTeX file is the repetition of a
word as in "the the". Most often, such doubled words come about through a
careless edit. Doubled words are hard to spot when the first word of the
doubled pair is the last word on one line, and the second word of the pair is the
the first word on the next line. There is an example of such an error in the last 
sentence. Vim's syntax mechanism can be used to highlight doubled words as an error.

To obtain this highlighting for TeX and LaTeX files, place the following two lines:

       syn match texDoubleWord "\c\<\(\a\+\)\_s\+\1\>"
       hi def link texDoubleWord Error

in a file called tex.vim in the directory that shows up last in your
runtimepath (:set runtimepath? to check). This will often be 
either ~/.vim/after/syntax/tex.vim or $VIM/vimfiles/after/syntax/tex.vim 

The same effect can be obtained for files of a different filetype, say html,
by putting the same lines in a file called html.vim in the same location.

For more on the runtimepath, :he runtimepath.
For more on syntax highlighting, :he syntax






VimTip	{{{1 207: editing databases with Vim/Perl/DBI


Perl's Data-Base-Independent (DBI) module provides programming language level
access to a lot of databases.

Vim hosts an embedded Perl interpreter. So it is only a matter of some key
strokes to interactively issue DB commands from within Vim or to search, edit,
and replace database contents including retrieval and storage. Of course
"create table" scripts can be worked upon in Vim as well as storing recurring
patterns in Vim functions or Perl modules.


Prerequisites: Vim needs to be compiled with Perl support enabled. See the
|if_perl.txt| manual page! The CPAN module DBI as well as an appropriate
database driver has to be installed with Perl in order to execute these Vim
commands:

" connect to perl's dbi module:
:perl use dbi;

" connect to the database:
:perl $dbh = dbi->connect( "DBI:mysql:$DBNAME:$HOST",$USER,$PASSWORD,
                                        { raiseerror => 1});

" perform a simple query:
:perl $result = $dbh->selectall_arrayref("show tables;");

" insert the list of tables into the current buffer's top:
:perl $curbuf->Append(0, map($_->[0], @{$result}));

In MySql the command "show tables;" results in a list of table names. Inserted
into a Vim buffer this results in one line per table.


You can find more on my web page
http://members.chello.at/intelliware/dbEdit








VimTip	{{{1 208: Alter the display of buffers in the buffers menu


If you use the buffers menu, here's where you can change how the buffernames are displayed:

menu.vim, function s:BMMunge

OLD:   let name2 = name2 . ' (' . a:bnum . ')'

displays:
  
  .vimrc (1)
  menu.vim (2)


NEW:    let name2 = '&' . a:bnum . '. ' . name2 

displays
  
  1. .vimrc 
  2. menu.vim
(with the 1 and the 2 underlined)

which is more useful, because you can (almost) always pick the buffer you want with one keystroke, the buffernumber, until you get to buffer 10 anyway.

Roger







VimTip	{{{1 209: backtracking your movements in a file


If you are jumping from one line to another a lot.
You may find the "Ctrl-o" command handy.
Usually u can set markers in a buffer to keep track of your
movements.
but Ctrl-o makes it even easier. it takes you back sequentially to
all your previous cursor locations in a buffer.
just press ctrl-o in normal mode and u will go to your last cursor position.

Njoy






VimTip	{{{1 210: compiling the actual file with gcc


if you use  set makeprg=gcc\ -o\ %<\ % in your .vimrc, and your actual file is file.c,  then :make will compile file.c with the output file. (gcc file.c -o file).






VimTip	{{{1 211: Rotate color themes


This tip is for those who like to change their vim color themes pretty often.  I like different themes just for a change in my work environment.  To achieve this just add the following to your .vimrc or _vimrc file.

let themeindex=0
function! RotateColorTheme()
	let y = -1	
	while y == -1 
		let colorstring = "#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
		let x = match(colorstring,"#",g:themeindex)
		let y = match(colorstring,"#",x+1)
		let g:themeindex = x+1
		":echo x y g:themeindex
		if y == -1
			let g:themeindex = 0
		else
			let themestring = strpart(colorstring,x+1,y-x-1)
			echo("Setting Theme to-> ".themestring)
			return ":so $VIMRUNTIME/colors/".themestring
		endif
	endwhile
endfunction

Change the value of colorstring above by changing the line
let colorstring = "#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
You can add your favorite color themes in this string so that you can rotate between them.  Just make sure that any string that you add is in between the # as shown above.  Just follow the format above and things will work.

Then assign a key to roate the theme.  
map <F8> :execute RotateColorTheme()

Dunno if there are better ways to do the same.  I just did a "help eval" and wrote the above.  






VimTip	{{{1 212: Setting file attributes without reloading a buffer



While creating scripts and others executable files with Vim it is needed to set UNIX executable bit on the file.
You can do this from inside Vim with :!chmod a+x %. The % represents current buffer's filename.
The problem is that Vim will notice attribute changes and prompt you to reload a file. If you do this, your undo history for the file will be lost.

The following function facilitate changing executable attributes without reloading a buffer.
Thanks to Bram for the algorithm for this function.

fun! SetExecutableBit()
	let fname = expand("%:p")
	:checktime
	exec "au FileChangedShell " . fname . " :echo"
	:silent !chmod a+x %
	:checktime
	exec "au! FileChangedShell " . fname
endfun

" Create an EX command that will call the function.
command -nargs=0 Xbit call SetExecutableBit()

Now you can type :Xbit to make the file executable!







VimTip	{{{1 213: delet all lines containt TXT


I needed this one when I was editing an ldif file:

I needed to delete all lines containing "profile":

:g/profile/d

very handydandy






VimTip	{{{1 214: Current buffer based menus


If you have different menus for different filetypes, and you want to have only the menu relevant to current buffer displayed, you can use this approach:

in .vimrc:
au BufEnter * if exists('b:BuffEnter')|exec b:BuffEnter|endif
au BufLeave * if exists('b:BuffEnter')|exec b:BuffLeave|endif

In appropriate ftplugin/?.vim, there are assigned commands to create or destroy the menus - here typed in directly, may be of course call to a menu-generating function or whatever.

let b:BuffEnter='amenu C.added ...'
let b:BuffLeave='unmenu! C|unmenu C'








VimTip	{{{1 215: Edit configuration files for a filetype


When you open a file, vim may load several scripts to customize itself for editing the file type the file is associated with (for example a file "test.c" is associated with the filetype "c").
Such configurations include the setting of syntax highlighting colors (:help syntax) and support for indentation (:help filetype-indent-on).
When you start to override these files for yourself, it can sometimes be confusing, which file sets a specific option.
The following function can be used, to edit the configuration files which are associated with a specific filename. It open a buffer for all files which get loaded.
If I invoke it with ':call Edit_ft_conf("test.c")', for example, I end up with the following buffers / windows:
  1  a   "[No File]"                    line 1
  2  a   "test.c"                       line 1
  3  a=  "/usr/local/share/vim/vim60/syntax/c.vim" line 1
  4  a   "~/.vim/after/syntax/c.vim"    line 1
  5 #a=  "/usr/local/share/vim/vim60/indent/c.vim" line 1
  6 %a=  "/usr/local/share/vim/vim60/ftplugin/c.vim" line 1


Here comes the function:

" Edit filetype configuration files
" Usage: ':call Edit_ft_conf("file")'
" Purpose: open all scripts which get loaded implicitly by opening "file"
"   (syntax highlighting, indentation, filetype plugins, ..)
"   The order of windows reflects the order of script loading (but "file" is
"   the topmost window)
fun! Edit_ft_conf(name)
    " we may not do this with a loaded file, since this won't trigger the
    " configuration file loading as desired.
    " try calling with 'call Edit_ft_conf("nonexistingfile.<EXT>")' if this
    " gives you troubles
    if bufexists(a:name) && bufloaded(a:name)
        echo "!Attention: buffer for " . a:name . " is loaded, unload first."
        return
    endif
    " split-open the file with verbose set, grab the output into a register
    " (without clobbering)
    let safereg = @u
    redir @u " redirect command output to register @u
    exec "silent 2verbose split " . a:name
        " verbose level 2 suffices to catch all scripts which get opened
    redir END
    " Parse register @u, looking for smth like: 'sourcing"/usr/local/share/vim/vim60/syntax/c.vim"'
    let pos = 0
    let regexp = 'sourcing "[^"]\+"'
    while match(@u,regexp,pos) >= 0
        let file = matchstr(@u,regexp,pos)
        let pos = matchend (@u,regexp,pos)
        let file = strpart(file,10,strlen(file)-11)
        exec "silent below split " . file
    endwhile
    " restore the register
    let @u = safereg
endfun








VimTip	{{{1 216: calculate equations from within vim


The following map and function calculates equations using the program 'bc' (found on most linux systems, available for most systems).  Visually select the equation you want to calculate, then hit ;bc - if the selection ends with an '=' sign, the answer will be appended after the equal, otherwise, the answer is echoed as a message.  The code to put in a vimrc and source is at the end.

Equations can span multiple lines, and the full bc syntax is probably supported.  Additionally, sin (), cos (), etc, are transformed into the names used by bc (s () c (), etc).

Here are some example lines:

2 * sqrt (2) = 

3 * (2 - 1) + 4.0 ^ 6 = 

4 / 3 = 

3 + 
   4 -
      2 * (1 / (3 + 2)) = 

define rad (x) {
  return (x / 180) * 4 * atan (1)
}
cos (rad (45)) = 

Select each of these in turn (continguous non-blank lines, and hit ;bc for each), and this is what you get:
2 * sqrt (2) = 2.82842712474619009760

3 * (2 - 1) + 4.0 ^ 6 = 4099.000000

4 / 3 = 1.33333333333333333333

3 + 
   4 -
      2 * (1 / (3 + 2)) = 6.60000000000000000000

define rad (x) {
  return (x / 180) * 4 * atan (1)
}
cos (rad (45)) = .70710678118654752440


Fun, no?  Here is the code you need to put in your vimrc file:

vnoremap ;bc "ey:call CalcBC()<CR>
function! CalcBC()
	let has_equal = 0

	" remove newlines and trailing spaces
	let @e = substitute (@e, "\n", "", "g")
	let @e = substitute (@e, '\s*$', "", "g")

	" if we end with an equal, strip, and remember for output
	if @e =~ "=$"
		let @e = substitute (@e, '=$', "", "")
		let has_equal = 1
	endif

	" sub common func names for bc equivalent
	let @e = substitute (@e, '\csin\s*(', "s (", "")
	let @e = substitute (@e, '\ccos\s*(', "c (", "")
	let @e = substitute (@e, '\catan\s*(', "a (", "")
	let @e = substitute (@e, "\cln\s*(", "l (", "")

	" escape chars for shell
	let @e = escape (@e, '*()')

	" run bc, strip newline
	let answer = substitute (system ("echo " . @e . " \| bc -l"), "\n", "", "")

	" append answer or echo
	if has_equal == 1
		normal `>
		exec "normal a" . answer
	else
		echo "answer = " . answer
	endif
endfunction







VimTip	{{{1 217: Translate &#nnn; in html source to readable ascii


I found a website *cough*Tivoli.com*cough* that likes to obfuscate some of its help file web pages using &#nnn; instead of normal ascii.  If you load the source with Vim (in Opera you can just designate Vim as your source viewing program), you can :so the following code to make it readable.

let n = 32
while n < 127
    if n == 38
        silent! exec '%s/&#38;/\&amp;/g'
    elseif n == 47
        silent! exec '%s/&#47;/\//g'
    else
        silent! exec '%s/&#' . n . ';/' . nr2char(n) . '/g'
    endif
    let n = n + 1
endwhile

Disclaimer: I hacked this together in about 10 minutes (or possibly longer :).  It worked suitably for the website I wrote it for (or possibly "against" :).  Your Milage May Vary.

See :help eval, :help silent, :help exec, :help :s







VimTip	{{{1 218: Check for comments, independent of the filetype


For some scripts it might be useful to detect, whether a specific position in a buffer is inside
of a comment or not. Syntax highlighting can save us the work for parsing the comments ourselves.

The command
  :echo synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name")
echoes the group used for *highlighting* the character at the current cursor position, see ':help synIDtrans()'. It will usually be "Comment" if the cursor is inside of a comment, so
   synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") == "Comment"
detects, independent of the filetype (which have their own group 'names' for comments), if the cursor is inside a comment or not.
The expression
  synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") =~ 'Comment\|Constant\|PreProc'
will detect additionally, if the cursor is inside of a string or some preprocessor statement.








VimTip	{{{1 219: make from command line, open vim on errors


A simple alias (*csh) or shell function (bash) will let you run make from your shell, then automatically open vim or gvim on the errors (if there were any):

csh or tcsh:

alias Make 'make \!* |& tee make.errors || gvim -q make.errors -c :copen'

bash:

Make () { command make "$@" |& tee make.errors || gvim -q make.errors -c :copen ; }

If you use vanilla sh or ksh or even cmd.exe, you can probably do the same - add a not if you have ideas.








VimTip	{{{1 220: Regexp: Match every word except 'foo'


This is a regular expression that matches all words except 'foo'
\v<(foo>)@!\k+>

\v 		Very magic
<		Start-of-word
(Foo>)	The atom 'Foo' followed by end-of-word
@!		Match (with zero length) when the previous atom doesn't
match.
\k+		Match one or more Keywords
>		Match end-of-word.

This is a kool example of using \@! in the middle of a regexp.
The non-magic version is:
\<\(foo\>\)\@!\k\+\>







VimTip	{{{1 221: indenting "throws" in java


I want to indent java files like this:

    int x(int y, int z)
        throws Exception
    {
        [...]
        return something;
    }

By default vim will properly indent "throws" line, but following "{" will not be deindented back to the method declaration.

The following indentexpr does the trick:
let &indentexpr='getline(v:lnum)=~"^\\s*{" && getline(v:lnum-1)=~"^\\s*throws\\s" ? cindent(v:lnum)-&sw : cindent(v:lnum)'

It just checks that the current line starts with "{" and the previous line starts with "throws" and if that is the case, it subtracts one shiftwidth from the number returned by cindent.






VimTip	{{{1 222: Building vim with color on HP-UX


Following the normal steps of running "./configure" and "make" to build
vim on an HP-UX 10.20 will result in vim being linked with the termlib
library.  This library does not support certain termcap capability
codes, such as the "Co" code used to query the number of colors
supported by the terminal.  Consequently, vim will not display colors
when used with a color terminal such as a color xterm.

One solution to this is to run the configure script with the
"--with-tlib=curses" option, like this:

    ./configure --with-tlib=curses

This will cause vim to be linked with the HP-UX curses library, which
does support the color termcap capability codes.

Note that the xterm that comes standard with HP-UX 10.20 does not
display color character attributes.  To see colors when running vim in a
terminal window, you will also need to install a color terminal emulator
such as a recent xterm.






VimTip	{{{1 223: Reverse Selected Text


Suppose you want to reverse some text - I don't know why you would want to - maybe you're dyslexic.  Anyway, I had a need, so this mapping will reverse visually selected text.  Put the mapping in your vimrc or otherwise source it, then visually select the word or words, and hit ;rv - really only works with selections on one line:

vnoremap ;rv c<C-O>:set revins<cr><C-R>"<esc>:set norevins<cr>









VimTip	{{{1 224: Shifting blocks visually


I use the < and > commands on blocks a lot, and it has always annoyed me that if you want to shift more than one 'shiftwidth', you have count how many 'shiftwidth's you want to enter the '[count]>', or restore the selection with "gv". So I've cooked up two mappings that come in very handy:

:vnoremap < <gv
:vnoremap > >gv

These mappings will reselect the block after shifting, so you'll just have to select a block, press < or > as many times as you like, and press <ESC> when you're done to unselect the block.

I know it's not rocket science, but it sure has helped me a lot.






VimTip	{{{1 225: vim can interact with xdvi


 vim can interact with the tricks that the latest xdvi does:

 * If one clicks at some place in xdvi, vim automatically jumps to the
   corresponding line in the LaTeX source file ("reverse search")
 * Also, from inside vim, one can jump to the corresponding line in xdvi
   which becomes highlighted ("forward search").

 Here is how to do it:

 * Reverse search:
   We start a vim server by:  vim --servername xdvi
   We start xdvi(k) on file.dvi by:
      xdvik -editor "vim --servername xdvi --remote +%l %f" file.dvi
   At the desired location in xdvi, we press:   <ctrl><left_mouse>
   Then, vim will jump to the corresponding line in the source file.

 * Forward search:
   Inside vim, we type, for example,  _g  which is the following mapping:
        (the following should be a single line)

   map _g  :execute "!xdvik -name xdvi -sourceposition " . line(".") . expand("%") . " " . expand("%:r") . ".dvi" <cr><cr>

    [the command to go to the point of xdvi that corresponds to line, eg, 77
     of the source file is (no space after 77)
       xdvik -name xdvi -sourceposition 77file.tex file.dvi  ]

  For the above to work one needs:
  1) A recent version of xdvi or xdvik (>22.39 I think)
  2) The package srcltx.sty and \usepackage{srcltx} (which should  be
     commented out when one finishes and is ready for printing etc).
  3) Our version of vim should have been compiled with +clientserver
     (however, my vim doesn't have it and still works, so try it before
      Bram finds out what is happening and fixes it)








VimTip	{{{1 226: Edit file under cursor after a horizontal split


I use the command 'gf' quite often. But with this command the current buffer is hidden. To avoid that I use the following mapping :

map gw <Esc>:sp %<CR> gf

With this mapping the file under the cursor is opened after a horizontal split.






VimTip	{{{1 227: Power of :g


:g is something very old and which is very powerful. I just wanted to illustrate the use of it 
with some examples. Hope, it will be useful for someone.

Brief explanation for ":g"
-------------------------
Syntax is:
    :[range]:g/<pattern>/[cmd]
You can think the working as, for the range (default whole file), execute
the colon command(ex) "cmd" for the lines matching <pattern>. Also, for all
lines that matched the pattern, "." is set to that particular line (for
certain commands if line is not specified "." (current line) is assumed).

Some examples
-------------
Display context (5 lines) for all occurences of a pattern
    :g/<pattern>/z#.5
    :g/<pattern>/z#.5|echo "=========="
    << same as first, but with some beautification >>
Delete all lines matching a pattern
    :g/<pattern>/d
Delete all blank lines (just an example for above)
    :g/^\s*$/d
Double space the file
    :g/^/pu =\"\n\"
    :g/^/pu _
    << the above one also works >>
Copy all lines matching a pattern to end of file
    :g/<pattern>/t$
Yank all lines matching a pattern to register 'a'
    0"ay0:g/<pattern>/y A
Increment the number items from current line to end-of-document by one
    :.,$g/^\d/exe "normal! \<c-a>"
Comment (C) lines containing "DEBUG" statements
    g/^\s*DEBUG/exe "norm! I/* \<Esc>A */\<Esc>"
A Reverse lookup for records
(eg: An address book, with Name on start-of-line and fields after a space)
    :g/<patern>?^\w?p               "if only name is interested
    :g/<patern>/ka|?^\w?p|'ap       "if name and the lookup-line is interested
    :g/<patern>/?^\w?|+,/^[^ ]/-1p  "if entire record is interested
Reverse a file (just to show the power of 'g')
    :g/^/m0

Foot note 1: use :v to negate the search pattern
Foot note 2: Some explanation of commonly used commands with :g
 :2,8co15 => Copy lines 2 through 8 after line 15
 :4,15t$  => Copy linesa 4 through 15 towards end of document (t == co)
    :-t$  => Copy previous line to end of document
     :m0  => Move current line to the top of the document
:.,+3m$-1 => Move current line through cur-line+3 to the last but one line
             of the document
Foot note 3: Commands used with :g are ex commands, so a help search should
             be,
                :help :<help-topic>
                eg. :help :k







VimTip	{{{1 228: Deleting nested reply threads in emails


I find the following setting useful when replying to email threads that have lots of lines like the following:
> blah
> > blah
> > > blah

autocmd FileType mail map <F8> :%g/^> >/d<CR>

When replying to a mail and you want to remove everything except what the person you are directly replying to wrote just press F8.
From the example above, you would just be left with
> blah

What it does is simply match any line starting with > > and deletes it.  It's not perfect as sigs and other debris may remain but it takes a lot of the grunt work out of replying to mails.
The autocmd only maps F8 when using mails, this is handy if you use F8 for other things as I do.

:help autocmd
:help map
:help :g







VimTip	{{{1 229: First thing to try before asking help


I've seen several questions asked in the reflector which is available in the help files. 
Yeah, I know the help is huge. But, you can try this command to show a list of related
topics you are trying:
   :he <topic><c-d>
It is "some topic" followed by the key sequence Ctrl-D. For eg:
   :he xterm<c-d>
will show all the help topics matching xterm. Then you can do completion/copy-n-paste
the topic you are searching. Of course you can cycle through all the topics through 
repeated <TABS>, but if the number of hits are huge, it is cumbersome.

Enjoy vimming beginners!!!
-Arun







VimTip	{{{1 230: copy current file to another location from within vim


I work on jsp pages in my source tree but I have to copy the jsp files over to the tomcat directory in order to view my changes.The following mapping will copy the file being edited to another location.

command Cpage silent !cp '%:p' "c:/Progra~1/Tomcat/webapps/console/pages/%"

Explanation:

% refers to the current buffer
%:p refers to the path to the file 
silent suppresses the command prompt window.

Usage:

:Cpage







VimTip	{{{1 231: Localized color schemes


i frequently like to edit multiple files in the same vim session.  however, if i come into vim from another window i frequently hit 'i' and start typing in whatever buffer is currently being used -- this is often the wrong one (requires <esc>, undo, go the other buffer and . to redo).

one way to work around this for me is to use a different color scheme depending on what file i'm working on:

au BufEnter * if (exists("b:colors_name")) | let b:current_colors=colors_name | execute "colorscheme " . b:colors_name | endif

au BufLeave * if (exists("b:current_colors")) | execute "colorscheme " . b:current_colors | endif

if you define b:colors_name with a particular color scheme name, then the above autocommands will switch to that colorscheme when you enter that window and will return to the original color upon departure.

inside ftplugin/java.vim, for example, i might have b:colors_name set to 'morning', causing all java files to have a distinguishing color scheme.






VimTip	{{{1 232: Search JDK help for keyword at cursor


 If you are using the Win32 version of Vim you can use this tip to search the Jdk help for the keyword under the cursor.
You need the winhlp32 version of the Jdk docs from this URL - http://www.confluent.fr/javadoc/indexe.html.
It is a 16mb D/L and approx 85mb unzipped!

I added a command to the popup menu 
:amenu PopUp.JavaHelp	:!start winhlp32 -k <cword> F:\jdk\winhelp\JDK13.HLP <CR

And also made a keymapping
map J :!start winhlp32 -k <cword> F:\jdk\winhelp\JDK13.HLP <CR>

Trivial yes, but I find it quite useful.






VimTip	{{{1 233: Some tips for using Vim to write Lisp code


For some tips on how to use Vim for writing Lisp code, see http://www.lisp-p.org/i000/15-vim.






VimTip	{{{1 234: Vi(M) Command Line tips & tricks


Hi VIMMERs

These tips save me wearing out my delicate little fingers with unnecessary keystrokes.
They assume Unix, but I also use them on a Windows Unix Shell (MKS) as well

# When I know the file i want to edit is the most recent file in a directory

alias -x vew='vi `l\s -t * | head -1 `'

#When I know the file I want to edit contains a unique keyword
#this is actually in a little shell script call ed vg where the keyword is passed as parameter $1
#/bin/sh
#name vg
vi.exe  $(grep -isl $1 *) &

# some variations
alias -x vp='vi `l\s -t *.@(pl|cgi)| head -1 `'

#execute the most recent script (I call this from within VIM with a mapped button)
alias -x xew='`l\s -t *.pl | head -1 `'

Cheers zzapper








VimTip	{{{1 235: Toggle highlight word under cursor, to find cursor.


When the screen has scrolled such as during a search, it may be difficult to find the cursor.  :help %# explains the pattern one can use to highlight the word around the cursor, which gives a bigger target to look for on the screen.  I have this in my .vimrc:

function VIMRCWhere()
    if !exists("s:highlightcursor")
        match Todo /\k*\%#\k*/
        let s:highlightcursor=1
    else
        match None
        unlet s:highlightcursor
    endif
endfunction
map <C-K> :call VIMRCWhere()<CR>

This means that in "normal" mode ctrl-k will toggle the highlight.  Todo is a hightlight group whch is particularly easy to see.
For further information see ":help s:", ":help match",  ":help exists()"  and ":help funtion".






VimTip	{{{1 236: Menu for inserting special characters


First, thanks for the script printascii.vim.

When looking at the ascii table, I found some characters I'd like to have inserted when editing.
Add the following lines in your _gvimrc and you can select them via menu.
(change the names of the menu if you don't have German installed or don't like my titles).
I also made some abbreviations to get separation lines in documentation or code files,
e.g.
abb dotlin ^M
abb cdotlin /**/^M
abb fdotlin ^M
abb cfdotlin /**/^M
abb dlin =======================================================================^M
abb cdlin /*===================================================================*/^M
abb lin -----------------------------------------------------------------------^M
abb clin /*-------------------------------------------------------------------*/^M
abb ulin _______________________________________________________________________^M
abb culin /*___________________________________________________________________*/^M
abb Ulin ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯^M
abb cUlin /*¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯*/^M

(you have to substitute ^M with CTRL_V CTRL_M or delete it)

20imenu Editieren.Sonderzeichen.open\ angle\	«	<C-R>=nr2char(171)<CR>
20nmenu Editieren.Sonderzeichen.open\ angle\	«	a<C-R>=nr2char(171)<CR><ESC>
20imenu Editieren.Sonderzeichen.close\ angle\	»	<C-R>=nr2char(187)<CR>
20nmenu Editieren.Sonderzeichen.close\ angle\	»	a<C-R>=nr2char(187)<CR><ESC>
20imenu Editieren.Sonderzeichen.start\ mark\		<C-R>=nr2char(132)<CR>
20nmenu Editieren.Sonderzeichen.start\ mark\	 	a<C-R>=nr2char(132)<CR><ESC>
20imenu Editieren.Sonderzeichen.end\ mark\	\		<C-R>=nr2char(148)<CR>
20nmenu Editieren.Sonderzeichen.end\ mark\	\	 	a<C-R>=nr2char(148)<CR><ESC>
20imenu Editieren.Sonderzeichen.fat\ dot\	\		<C-R>=nr2char(149)<CR>
20nmenu Editieren.Sonderzeichen.fat\ dot\	\		a<C-R>=nr2char(149)<CR><ESC>
20imenu Editieren.Sonderzeichen.etc\	\	\		<C-R>=nr2char(133)<CR>
20nmenu Editieren.Sonderzeichen.etc\	\	\	 	a<C-R>=nr2char(133)<CR><ESC>
20imenu Editieren.Sonderzeichen.!underscore\	\	¯	<C-R>=nr2char(175)<CR>
20nmenu Editieren.Sonderzeichen.!underscore\	\	¯ 	a<C-R>=nr2char(175)<CR><ESC>
20imenu Editieren.Sonderzeichen.copyright\	\	©	<C-R>=nr2char(169)<CR>
20nmenu Editieren.Sonderzeichen.copyright\	\	©	a<C-R>=nr2char(169)<CR><ESC>
20imenu Editieren.Sonderzeichen.paragraph\	\	§	<C-R>=nr2char(167)<CR>
20nmenu Editieren.Sonderzeichen.paragraph\	\	§	a<C-R>=nr2char(167)<CR><ESC>
20imenu Editieren.Sonderzeichen.noitamalcxe\	¡	<C-R>=nr2char(161)<CR>
20nmenu Editieren.Sonderzeichen.noitamalcxe\	¡	a<C-R>=nr2char(161)<CR><ESC>








VimTip	{{{1 237: If you prefer vertical splits


This is just in case there's somebody else who likes to work in a maximized vim window on a high resolution desktop. If you follow good coding practice and make sure your programs use only 80 characters in each row, have you noticed how much space lies unused on the right?

I find that the following settings keep me from ever seeing another horizontal split, unless I specifically ask for it.

cabbrev split vsplit
cabbrev hsplit split
cabbrev sta vertical sta
cabbrev help vertical help
cabbrev new vnew
cabbrev right botright

; A more heavyweight solution for ^W^]
function! ToggleSplit (dir)
    let currFname = bufname ("%")
    let old = winnr ()

    " Window navigation to ensure the correct window is 'last'.
    if (a:dir == "u")
        wincmd k
        let back="j"
    elseif (a:dir == "d")
        wincmd j
        let back="k"
    elseif (a:dir == "l") 
        wincmd h
        let back="l"
    elseif (a:dir == "r")
        wincmd l
        let back="h"
    endif

    if (winnr () == old)
        echo "Ouch"
        return
    endif

    exec "wincmd " . back

    quit

    if (back == "j" || back == "k")
        let orientation = "vsplit"
    else
        let orientation = "split"
    endif

    if (back == "j" || back == "l")
        let dir = "below"
    else
        let dir = "above"
    endif

    exec dir . " " . orientation " " . currFname
endfunction
noremap ^W^] ^W^]:silent call ToggleSplit ("d")<CR>

; Optional.
set splitright
; In which case the above mapping becomes:
noremap ^W^] :set splitbelow<CR>^W^]:silent call ToggleSplit ("u")<CR>:set nosplitbelow<CR>
; Or you could just
set splitbelow
; :-)

; Very elegant and almost perfect, but it screws up if you want to run a command with ranges :-)
;noremap : :vertical<Space>

; EOF






VimTip	{{{1 238: Very basic session persistence


I use the following code in my plugins dir to ease session persistance. If I want my session to persist I use :mks! and then whenever I open the Session.vim file, my session is restored. If I am working from a restored session and I close VIM, the session is saved automatically. Drawback is that it makes editing the Session.vim file a bit cumbersome ;)

  au BufRead Session.vim so %
  au VimLeave * call SaveCurrentSession()

  function! SaveCurrentSession()
    if v:this_session != ""
      exe "mksession! " . v:this_session
    endif
  endfunction






VimTip	{{{1 239: Scroll using arrow keys like browser: map shift-up and shift-down


You can make Vim scroll the text using the shifted up/down arrows, sort of like your browser (except with shifted keys :), by mapping Shift-Up to Ctrl-Y and Shift-Down to Ctrl-E.

    map <s-Down> <C-E>
    map <s-Up> <C-Y>

Shift-Down will then scroll down (like moving a scroll-bar down, or like moving a cursor at the bottom of a window down), and Shift-Up will then scroll up (like moving a scroll-bar up, etc).

If you'd rather think about the text moving down/up instead of the cursor moving up/down, you can of course swap the mappings.

If you normally use j and k for cursor movement, and rarely use the arrow keys, you can map the arrow keys directly, in which case I'd probably map the shifted arrow keys back to cursor movement:

    map <down> <c-e>
    map <up> <c-y>
    map <s-down> j
    map <s-up> k

See :help ctrl-e, :help ctrl-y, and :help key-mapping.

See also :help i_ctrl-o and :help map-modes for how to set up these mappings for use in other modes (like insert mode :).

(Vim by default maps s-Down and s-Up to Ctrl-F and Ctrl-B, for both normal and visual mode.  Keep this in mind if you change some of the above mappings to "nmap", 'cause you'll probably also want to look in to "vmap".)







VimTip	{{{1 240: Hideall for Vim


Xemacs has a hide all function which can make all the function in your C file a fold and close them. And here is something small to achieve similiar under Vim.

func! HideAll()
   syn region myFold start="{" end="}" transparent fold
   syn sync fromstart
   set foldnestmax=1
   set foldmethod=syntax
endfunc

amenu Whatever.Hide\ all :call HideAll()<CR>






VimTip	{{{1 241: "Hide" Folding Markers



I wanted to start using folding without having to get used to
seeing the (default) markers, a.k.a {{{ and }}}. So, here are 
2 autocmd's that will make them fade to black....bg=black fg=black

au BufRead,BufNewfile   * syn match fmrkr '"*{{{\|"*}}}'                 | 
                        \ syn cluster vimCommentGroup contains=fmrkr     | 
                        \ hi fmrkr term=NONE guibg=black   guifg=black 
                        \                    ctermbg=black ctermfg=black

au BufRead,BufNewfile   * syn match fmrkr '"*{{{\|"*}}}'
                        \ containedin=vimLineComment contained           | 
                        \ hi fmrkr term=NONE guibg=black   guifg=black
                        \                    ctermbg=black ctermfg=black

They both accomplish the same thing, but with different methods, so
simply pick one and see those annoying (at least to me) markers fade away.
I just tried it out with vim files, but you can easily modify it for
any other filetypes.

Thanks to Colin's lead with ':help c-syntax'    for the 1st au.
Thanks to Benji's lead with ':help containedin' for the 2nd au.
Understanding most of the syntax.txt document file would also be helpful.

To figure out what highlighting group the Marker is in, I would suggest
using Chip's vimtip#99.

Happy Vimming!






VimTip	{{{1 242: The power of "\_" in reg-ex


One of the most uncelebrated feature of vim 6.0 is the ability to span a search across multiple lines.

\_^   maps a begining of line anywhere in search pattern. 
\_$   ---"----- end           ----------------------"-------------------------.
\_s  ---"------ space                   ------------"------------------------- .

e.g  /{\_s will map all white spaces and new-line chars after a "{"

The \_ can be appended to other objects as well. such as \_U,  \_L,  \_. (this one's risky) .

See :help pattern for more details.
Njoy 







VimTip	{{{1 243: Develop vim modules on Win


We're trying to develop txt2pdf.vim http://vim.sourceforge.net/scripts/script.php?script_id=283 on Win.
It's a very simple module to save the current file and convert it to PDF using our txt2pdf tool http://www.sanface.com/txt2pdf.html
On our Windows 2000 we've developed it. It works good.
Today we've tested the module on Linux. Surprise: it doesn't work.
Default Win Vim configure save on Win text in Win way: EOL \r\n.
A Vim module made in this way can't work on Linux (probably on every Unix OS).
If you want to make a Vim module on Win and you want it can work also on Unix (we hope the same rula can work also on different OS) you've to save the Vim module with Unix EOL (\n).

Please send us (sanface@sanface.com) your notes about other OS (e.g. OpenVMS).






VimTip	{{{1 244: Ask vim where an option was set.


     When things go wrong, it is sometimes hard to figure out why.  For example,
an option might be set in the system vimrc file, in a personal vimrc file, in a
plugin (global or local), or interactively.  Vim will tell you where the current
value was set if you ask:

:verbose set history?

will tell you the current value of the 'history' option, and where it was set.






VimTip	{{{1 245: Working with Unicode (platform-independent)


Here are the main options you will want to set if you want to work with Unicode files in (g)vim (see at bottom what help tags to look for)

if has("multi_byte")
     set encoding=utf-8                       " how vim shall represent characters internally
     setglobal fileencoding=utf-8         " empty is also OK (defaults to same as 'encoding'). Or you may want to set one of the ucs encodings (which
                                                          " may use less disk space if you use only "alphabetic" scripts such as Latin, Greek, Cyrillic, Hebrew or Arabic, and
                                                          " not "ideographic" scripts like Chinese, Japanese or Korean. With the ucs encodings it is usually better
     set bomb                                      "  to also set 'bomb' on ('byte-order-mark" option, irrelevant for utf-8 but not for ucs)
     set termencoding=iso-8859-15    " or whatever is appropriate to your locale (iso-8859-15 is Latin1 + Euro currency sign)
     set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
         " or whatever is appropriate to the kinds of files you want to edit
         " 'fileencodings' defines the heuristic to set 'fillencoding' (local to buffer) when reading an existing file. The first one that matches will be used.
         " ucs-bom is "ucs with byte-order-mark"; it must not come after ucs-8 if you want it to be used
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

In "replace" mode, one utf character (one or more data bytes) replaces one utf character (which need not use the same number of bytes)
In "normal" mode, ga shows the character under the cursor as text, decimal, octal and hex; g8 shows which byte(s) is/are used to represent it
In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even with dead keys if you have them, e.g. âêîôû  äëïöü)
  - any character which has a "digraph" (there are a huge lot of them, see :dig after setting enc=utf-8) can be entered with a Ctrl-K prefix
  - any utf character at all can be entered with a Ctrl-V prefix, either <Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <= bbbbbbbb <= 7FFFFFFF

Unicode can be used to create html "body text", at least for Netscape 6 and probably for IE; but on my machine it doesn't display properly as "title text" (i.e., between <title></title> tags in the <head> part).

Gvim will display it properly if you have the fonts for it, provided that you set 'guifont' to some fixed-width font which has the glyphs you want to use (Courier New is OK for French, German, Greek, Russian and more, but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than those of, e.g. Lucida Console: the latter can be annoying if you need bold Cyrillic writing).

see:

:h utf8
:h 'enc'
:h 'fenc'
:h 'fencs'
:h 'tenc'
:h 'bomb'
:h 'guifont'
:h ga
:h g8
:h i_Ctrl-V_digit

Happy Vimming !
Tony.






VimTip	{{{1 246: Working with Unicode (the same, rewritten for legibility)


1. Where to look for help
-------------------------
:h utf8
:h encoding-values
:h 'enc'
:h 'fenc'
:h 'fencs'
:h 'tenc'
:h 'bomb'
:h 'guifont'
:h ga
:h g8
:h :dig
:h i_Ctrl-V_digit
:h has()

2. What to do (These are *examples*. Modify them to suit your work environment.)
-------------
if has("multi_byte")
     set encoding=utf-8
     setglobal fileencoding=utf-8
     set bomb
     set termencoding=iso-8859-15
     set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

3. What the above does
----------------------
* has("multi_byte") checks if you have the right options compiled-in. If you haven't got what it takes, it's no use trying to use Unicode.

* 'encoding' sets how vim shall represent characters internally. Utf-8 is necessary for most flavors of Unicode.

* 'fileencoding' sets the encoding for a particular file (local to buffer); :setglobal sets the default value. An empty value can also be used: it defaults to same as 'encoding'. Or you may want to set one of the ucs encodings, It might make the same disk file bigger or smaller depending on your particular mix of characters. Also, IIUC, utf-8 is always big-endian (high bit first) while ucs can be big-endian or little-endian, so if you use it, you will probably need to set 'bomb" (see below).

* 'bomb' (boolean): if set, vim will put a "byte order mark" at the start of ucs files. This option is irrelevant for most non-ucs files (utf-8, iso-8859, etc.)

* 'termencoding' defines how your keyboard encodes what you type. The value you put there will depend on your locale: iso-8859-15 is Latin1 + Euro currency sign, but you may want something else for, say, an Eastern European keyboard.

* 'fileencodings' defines the heuristic to set 'fileencoding' (local to buffer) when reading an existing file. The first one that matches will be used (and, IIUC, if there is no match, Vim falls back on Latin1). Ucs-bom is "ucs with byte-order-mark"; it must not come after utf-8 if you want it to be used.

4. Additional remarks
---------------------
* In "replace" mode, one utf character (one or more data bytes) replaces one utf character (which need not use the same number of bytes)

* In "normal" mode, ga shows the character under the cursor as text, decimal, octal and hex; g8 shows which byte(s) is/are used to represent it.

* In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even with dead keys if you have them, e.g. French circumflex, German umlaut, etc.);
  - any character which has a "digraph" (there are a huge lot of them, see :dig after setting enc=utf-8) can be entered with a Ctrl-K prefix;
  - any utf character at all can be entered with a Ctrl-V prefix, either <Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <= bbbbbbbb <= 7FFFFFFF.

* Unicode can be used to create html "body text", at least for Netscape 6 and probably for IE; but on my machine it doesn't display properly as "title text" (i.e., between <title></title> tags in the <head> part).

* Gvim will display it properly if you have the fonts for it, provided that you set 'guifont' to some fixed-width font which has the glyphs you want to use (Courier New is OK for French, German, Greek, Russian and more, but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than those of, e.g. Lucida Console: the latter can be awkward if you need bold Cyrillic writing).

Happy Vimming !
Tony.







VimTip	{{{1 247: Preexisting code indentation


Using tabs as elementary unit in your code indentation has two advantages: first, you may modify 'tabstop' and immediately all the indentations depths are modified according to it; second, your file will be smaller.

But how can we change some already-written code in order to convert spaces to tabs. Very simple!
Suppose your old code has an indentation unit of 2 spaces
:ret! 2
:x
will replace every 2-spaces to one tab, independently from your current tabstop value, and will save the modified file.
Then, if you open again the file with tabstop=2, the file will look as before but it will be smaller. If you open the file with tabstop=4, the code vill have a more indented look, and so on...

Cheers! 






VimTip	{{{1 248: Auto-save the current buffer periodically.


I have no  idea if this was implemented  in vim 5.3 or not,  but you can
definitely  do the  following  kludge  in 6.x  by  using CursorHold  and
localtime:

- When you  start reading a file,  set a buffer variable  to the current
  time:

  au BufRead,BufNewFile * let b:start_time=localtime()

- Set a  CursorHold event  to check  to see if  enough time  has elapsed
  since the last save and save if not:

  au CursorHold * call UpdateFile()

- Define a function to save the file if needed:

  " only write if needed and update the start time after the save
  function! UpdateFile()
    if ((localtime() - b:start_time) >= 60)
      update
      let b:start_time=localtime()
    else
      echo "Only " . (localtime() - b:start_time) . " seconds have elapsed so far."
    endif
  endfunction

- Reset the start time explicitly after each save.

  au BufWritePre * let b:start_time=localtime()

Obviously, you  should get rid of  the else portion once  you're certain
that this does indeed do what you wanted.

The  thing  to  note  is  that  the  CursorHold  will  only  fire  after
'updatetime' milliseconds  of inactivity have  elapsed. So, if  you type
rapidly for  one and  a half  minutes non-stop,  it won't  actually save
anything until you STOP activity long  enough. This may be what you want
anyway because it won't interrupt your activity with a forced save.

The actual save-delay can be changed from '60' to another number (in seconds) or a variable or anything like that.  This entire functionality can be easily wrapped inside a nice script which enables/disables this on a per-buffer basis (maybe with maps etc.).  If desired, I can provide that also.






VimTip	{{{1 249: C/C++: Quickly insert #if 0 - #endif around block of code


One of my favorite macros that I use in vim (and vi) inserts a #if 0 #endif sandwich
around a block of code.  I always map this to the 2 key sequence ;'  which is the
semi-colon followed by the single quote.  Look at your keyboard, you will notice
these keys are adjacent to one another.  I like this mapping because it's very fast,
my fingers easily roll from one key to the next, obviously YMMV.

To use this mapping, go to the line of code that you want the '#if 0' to be on, type
ma to mark this line with the marker a, then move to the line that should be last line
just above the '#endif' and press ;'

    " insert #if 0 - #endif around block of code
    map ;' mz'aO<Esc>i#if 0<Esc>'zo<Esc>i#endif<Esc>

--
David Thompson
dat1965@yahoo.com






VimTip	{{{1 250: One big window


If you like to see your files in fullscreen, and you have to edit more files, you can do the following.
* Use only one window
* Open further files with :e
* type :nm <A-Up> :bp!<CR>
* type :nm <A-Down> :bn!<CR>
* type :nm <C-F4> :bd!<CR>
You can of course change the keys.
Now to switch between windows, you can press Alt-Up, and Alt-Down
(Just in the GUI, if you use console, don't use Alt key)
Another idea is to map them to Ctrl-Tab, and Ctrl-Shift-Tab
To close the current file you can press Ctrl-F4






VimTip	{{{1 251: c/c++: align #endif with corresponding #if/#ifdef


If you try to impose any sort of alignment on your preprocessor directives, rather than just starting them on column 0, this mapping will align the #endif 'correctly' when you type '#en', start a new line, and bring you back to the correct alignment to edit code.

inoremap <buffer> #en X<BS><Esc>?#if<CR>"zy0^Og0"zpDa#endif<CR>X<BS><Esc>?#end?-1<CR>^"zy0^O0"zpDa

I am reasonably sure this is insensitive to vim options...






VimTip	{{{1 252: python script to align statements


i know there's some awk scripts out there that do the same thing, and if i were a real trooper i would have
written this in vims internal language but...

i wrote a python script to align statements.

i put this in my .vimrc:
map L :!lineUp.py<cr>   " of course lineUp.py is somewhere in my path

and i have this python file somewhere in my path:
http://ophinity.com/res/dotFiles/lineUp.py

so now i can just pipe the offending lines thru my code:
:5, 10 !lineUp.py 
or using the mapping above, visually select the lines and press 'L'








VimTip	{{{1 253: The power of | (v75|r- actually...)


'|' as you may well be aware is the goto column motion, and that "75|" will place your cursor on column 75 of the current line.

That in itself is pretty handy at times, but some true power arises when used in conjuction with visual mode and replace. Or you could just say a sneaky trick :)

v75|r-
will repace from the cursor to the end of line with '-'
*breakdown*
v to turn on visual mode
75 for the count
| *bar* to goto column
r to enter repace
- to specify the char to replace.

A handy and quick way to make a noticable section of your code (or whatever).

A handy way to use this (formated to just drop into DrChip's CStubs):
"// -[Feral]---------------------------------------------------------------
"// <cursor>
	elseif wrd == "//"
		exe "norm! a -[AuthorId]\<esc>$lv75|r-$a\<cr>\<esc>$a "

"// -[Feral:146/02@08:31]--------------------------------------------------
"// <cursor>
	elseif wrd == "///"
		exe "norm! s -[AuthorId:\<C-R>=strftime('%j/%y@%H:%M')\<CR>]\<esc>$lv75|r-$a\<cr>\<esc>$a "

"/* -[Feral:146/02@08:31]--------------------------------------------------
" * <cursor>
" * -------------------------------------------------------------------- */
	elseif wrd == "/*"
		exe "norm! a -[AuthorId:\<C-R>=strftime('%j/%y@%H:%M')\<CR>]\<esc>$lv75|r-$a\<cr>\<cr>\<esc>2lv72|r-$a */\<esc>k$a "


Have to love VIM!






VimTip	{{{1 254: Using \%[] to easily match parts of a word.


This code fragment is suitable to drop into DrChip's CStubs.
After much searching I was unable to find a tip nor script number to referance, I believe where I found Dr. Chip's CStubs originally : http://users.erols.com/astronaut/vim/vimscript/drcstubs.vim
Thank you Dr. Chip! (=


If you have ever wanted to match parts of a word you may have considered something like:
if wrd == "re" || wrd == "ret" || wrd == "retu" || wrd == "retur"
   "do something

Althought the above works well enough it is a pain to maintain and add new words (not to mention its just a touch messy ;) )

A more elegant (and easier to use I believe) method would be to use \%[] as part of a pattern.

For instance, "\\<re\\%[tur]\\>" will match "re", "ret", "retu" or "retur"

*breakdown*
\\< = start of word
re = first letters of word we want to require to match
\\%[tur] = optionally match chars bewteen the braces, i.e. 't', 'tu' or 'tur'
\\> = end of word

So, we can use this as a pattern for match like so (In DrChip's CStubs)

elseif match(wrd, "\\<re\\%[tur]\\>") > -1
    exe "norm! bdWireturn\<Esc>"

Which, I think, is a little better than the longer alternative:
"  vs
elseif wrd == "re" || wrd == "ret" || wrd == "retu" || wrd == "retur"
    exe "norm! bdWireturn\<Esc>"


Just another one of those VIM things that made me smile :)






VimTip	{{{1 255: arbitrary tags for file names


This definitely work on linux and there is probably some windows equivalent.
I've started working with tomcat and many many .jsp files.  I find this trick to be very helpful.

find -name '*.jsp' -printf '%f\t%P\t1\n' |sort > jsp.tags

This will create a file called jsp.tags with tag entries for each .jsp file.  Within Vim I use 

:set tags+=jsp.tags

Now I can to simple :tag file.jsp to quickly switch b/w the many, many .jsp files.

One important note.  The utility sort will use the value of LC_COLLATE to sort according to your
locale.  This will give Vim issues.  So try "LC_COLLATE=C sort" instead of plain "sort"






VimTip	{{{1 256: Opening current Vim file in your Windows browser


Hi Vimmers

open current file in browser

map ,f   :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>

open http link under cursor in your browser

map ,i   :update<CR>: !start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>

Note use of cWORD (not cword) meaning OUTER Word

Works for me in XP & 98
(Original came from a posting by Ralf Arens)

zzapper






VimTip	{{{1 257: fast page up/down.


i discovered a cool way to move between pages of the same document in vim 6.1. press a number in -normal mode- and the page up/down. the document will move with that number of pages up/down.if the number is greater that the nr of pages, document will move to begin/end of file.
i didn't test it on other version. 






VimTip	{{{1 258: how long is the current word?


ever wondered how long the current word is?  this can be quite useful when editing data files.
simply add the following to your .vimrc

nmap <C-_> :echo 'word' expand("<cword>") '  wordlen =' strlen(expand("<cword>"))<CR>

and it will tell you the word under the cursor, and how long it is.

and for things that arent words, this addition to your .vimrc works on sections of a line that have been hightligted in visual mode

vmap <C-_> "-y:echo 'word' @- '  wordlen =' strlen(@-)<CR>

again you see the "word", and its length
this may also work on vim 5.x, but i havent checked to make sure.






VimTip	{{{1 259: removing the toolbar (icons) from gvim


Change good or bad usually  encounters interia from people in excepting it. 
gvim 6.0 is the first version that introduced the icons shortcut in shape of a toolbar under the menu.
when we upgraded to the new and improved vim 6.1 from vim 5.7 some of people in our company encountered some problems with their syntax highlighting
and some of them objected on the new toolbar which displayed icons for some common tasks for people more used to GUI.

I finally figured out how to remove this new feature since I also didn't see much use for it

Here is for all those who haven't figured it out yet

In your .gvimrc include the following two lines

unmenu ToolBar
unmenu! ToolBar

Doing this from an open gvim does not remove them but grays them out but doing from gvimrc does the job

I was also trying to remove the menus at the top and almost succeeded with a similar technique but somehow the Buffer menu item stays there no matter what. IMHO it is a bug but it could very well be a feature ;)

I tried this 

unmenu *
unmenu! *

even added this line after the above two but didn't help
unmenu Buffers

I hope this benefits you all as much as I have benefitted from all your tips







VimTip	{{{1 260: gvim-->mouse-->popup menu


This tip is for those who prefer to do some of the common
operations like cut/copy/paste etc using mouse. All u have to do is
 
 :set mousemodel=popup

by this u get a popup menu on right click of your mouse and u can
do all the common operations like undo, cut, copy, paste, select etc
using mouse.

u can also customise your popup menu by editing $VIMRUNTIME/menu.vim








VimTip	{{{1 261: Close windows from  Gvim poup menu


To close windows from the popup menu add these lines to your .gvimrc

:amenu PopUp.Close.\ Window :confirm close<CR>
:amenu PopUp.Close.\ Other  :confirm only<CR>

You obviously need ':set mousemodel=popup' in your .gvimrc as well :=)






VimTip	{{{1 262: Bored of ur arrow shapped mouseptr?


here is how u can change the shape of ur mouseptr in gvim.

:set mouseshape=n:pencil

this will change the shape of the mouseptr to pencil in normal mode.
u can choose different shapes for different modes. see :h mouseshape

Want more shapes?

Then look for the file cursorfont.h in ur X11/ directory.
This file contains lots of cursor shape #define definitions, like
.
#define XC_heart 62
.
now :set mouseshape=n:62 will set the shape of the mouseptr to heart
in normal mode.

-ncr






VimTip	{{{1 263: color active line


This tip shows how to color the active line, the line in which the cursor is, for better reading.
You should try possibility 2 before 1, IMHO it is mostly usable.

possibility 1:
     :au! CursorHold * let @/ = '\%' . line('.') . 'l.*'
     :set ut=500

explanation:
     After 500 ms of waiting for you to hit a key, vim sets the search register to a pattern that matches the current line.

problem:
     Register / holds the search pattern, so you cannot have color the active line and search.
     Therefore another solution:

possibility 2:
     :highlight CurrentLine guibg=darkgrey guifg=white     (or whatever colors you want)
     :au! Cursorhold * exe 'match CurrentLine /\%' . line('.') . 'l.*/'
     :set ut=100

explanation:
     This solution uses 'match' to highlight a string, it does not interface with the current search pattern.

addition:
     Turning the highlighning off:
          :au! Cursorhold
          :match none
     The order of these commands are important. If :match none is executed first, the autocommand would
     almost immediately execute another match command.

references to vim help:
     :help Cursorhold
     :help 'ut'
     :help /\%l
     :help "/
     :help \%








VimTip	{{{1 264: F5 Compile and Run, F8 Compile (ala Visual Studio)


I love vim, it's my default editor on my Sun, Windows, Linux and *BSD boxen.  That said, I hate having to flip windows to compile while doing the write->compile->debug loop.

If you're used to Visual Studio and the ability it has to just hit F5 to compile and run the current file or F8 to compile or step through the code you'll appreciate this...

This is my Windows version of this scriplet/tiplet.  For other platforms, you'll want to change the IF ELSE loops.  You should actually never see the "Unsuccessful" message from the compile/run loop unless the compiler completely bombs out.   This is from my _vimrc... 


map <F5> :call CompileRunGcc()<CR>

map <F8> : call CompileGcc()<CR>

func! CompileRunGcc()
		exec "w"   "Save the file
		exec "!gcc % -o %< && cr 10 && IF EXIST %<.exe (%<) ELSE banner -c = Compile Unsuccessful "  
		exec "i" "jump back where we were
		
	
endfunc

func! CompileGcc()
		exec "w"
		exec "!gcc % -o %<  && IF EXIST %<.exe (cr 5 && banner -c # Success) ELSE banner -c # Compile Unsuccessful "
		exec "i"
	
endfunc






VimTip	{{{1 265: Fast help in full window


You can get fast access to help by writing small script

#!/bin/bash
vim -c "help $1" -c only

now name it eg. vih and from cl

$ vih makeprg






VimTip	{{{1 266: use -S command line switch



The -S switch could be used to simplify common idiom: start Vim and source a script file:
gvim -c ":so foobar.vim" got translated into gvim -S foobar.vim

Yes, this tip is trivial but I still see the -c ":so x" way too often. Time to update your mind!






VimTip	{{{1 267: selectively displaying abbreviations


Hi Vimmers,
abbreviations have always been one of the most useful parts of vi(m), trouble is when you've got too many you forgot what you called them.

You can of course list the whole lot with

:ab<cr>

But did you know that you can type the first few letters of your abbreviations and get a list of just thos abs eg

:ab php<cr>
gives me all my php abs
&
:ab perl<cr>
gives me all my perls

also try control-D instrad of <cr>

zzapper








VimTip	{{{1 268: Get cursor position as byte percentage instead of line percentage


On line 300 of a thousand line file, Vim will show you that you're 30% through the file.  But what if most of the lines have one character in them, and some of them have twenty thousand?  Sometimes it comes in handy to know your percentage through the file in terms of current-byte / total-bytes.  I looked through the Vim docs and couldn't find a way to do this, so I wrote a Vim function to show it.

Put this in your .vimrc:

function! Percent()
    let byte = line2byte( line( "." ) ) + col( "." ) - 1
    let size = (line2byte( line( "$" ) + 1 ) - 1)
    " return byte . " " . size . " " . (byte * 100) / size
    return (byte * 100) / size
endfunction

(Uncomment the first return to see intermediate values.)

And put this somewhere in your "set statusline=...":

    %{Percent()}%%

See "help statusline", "help eval".







VimTip	{{{1 269: Syntax highlighting is "out of sync", seems to correct itself with refresh ??


This one has come across the 'vim' users mailing list many times, and probably
comp.editors as well...

Summary:
see :help :syn-sync
and search for 'sync' in your favorite syntax file in $VIMRUNTIME/syntax

Long Version:
The syntax highlight code utilizes a certain synchronization method to efficiently
figure out syntax highlighting, specifically if you aren't at the very beginning or
end of a file.  The specific setting is 'syntax sync'.  For various file types the
method is set by default in this is setup in the syntax file and one can vary
the degree of trouble which VIM goes to to try and figure this out.  As an example
for C, from $VIMRUNTIME/syntax/c.vim:

if exists("c_minlines")
  let b:c_minlines = c_minlines
else
  if !exists("c_no_if0")
    let b:c_minlines = 50	" #if 0 constructs can be long
  else
    let b:c_minlines = 15	" mostly for () constructs
  endif
endif
exec "syn sync ccomment cComment minlines=" . b:c_minlines

Where c_minlines is the minimum number of lines that VIM goes backward
to try to find the start of a comment for syntax highlighting.  If that line which
starts a comment is outside of that range, highlighting will appear wrong.

You can easily set up something like this in your .vimrc:
let c_minlines=500
or even bigger, but realize that it is a performance trade-off and that
syntax highlighting will slow things down.







VimTip	{{{1 270: Insert a single character


Using Insert mode to insert a single character feels clumsy (you need
3 keypresses for one character), so here's a slightly easier way:

:nmap <space> i_<esc>r

Now, when in Normal mode, just press space followed by what
it is you want to insert.

BUG: Repeating the insertion with . doesn't work.







VimTip	{{{1 271: easy (un)commenting out of source code


Something that I do quite alot is comment out blocks of text, only to uncomment that same block later. The following mappings have proven useful to me. They can be applied using visually selected blocks, or with motion keys.

" lhs comments
map ,# :s/^/#/<CR>
map ,/ :s/^/\/\//<CR>
map ,> :s/^/> /<CR>
map ," :s/^/\"/<CR>
map ,% :s/^/%/<CR>
map ,! :s/^/!/<CR>
map ,; :s/^/;/<CR>
map ,- :s/^/--/<CR>
map ,c :s/^\/\/\\|^--\\|^> \\|^[#"%!;]//<CR>

" wrapping comments
map ,* :s/^\(.*\)$/\/\* \1 \*\//<CR>
map ,( :s/^\(.*\)$/\(\* \1 \*\)/<CR>
map ,< :s/^\(.*\)$/<!-- \1 -->/<CR>
map ,d :s/^\([/(]\*\\|<!--\) \(.*\) \(\*[/)]\\|-->\)$/\2/<CR>

The commands to comment a selection of text are as follows, begining with begining-of-line comments:

    ,#    shell, perl, etc
    ,/     c++
    ,>    email quote
    ,"     vim
    ,%    latex, prolog
    ,!      assembly?... add single !
    ,;      scheme
    ,-      don't remember this one... add --
    ,c     clears any of the previous comments

Here are the wrapping comments, each line wrapped individually:

    ,*      c
    ,(       Standard ML
    ,<      html
    ,d      clears any of the wrapping comments







VimTip	{{{1 272: automaticaly formating pasted text (p=`])


In times past I used a nice editor that had the neat feature of automatically setting pasted text to the proper indent level. Recently I've begun to miss this so I went looking in the help and camp up with....

=`]

which will format to the end of the pasted text... Perfect to call right after you past something as the cursor ends up at the top of the pasted text, thus the mapping:

:map <c-p> =`]

" by the by the above may should be nmap and I am pretty sure c-p is unused, your mileage will vary no doubt.

However I wanted the formatting to automatically be done so it was two simple (once I figured out how!) nnoremap:

" [Feral:185/02@14:27] map c-p to what p was (past with no formatting), map p to p and = to end of pasted text.
:nnoremap p p=`]
:nnoremap <c-p> p

This simply (as the comment hints at) maps normal mode p to what p did (paste) then = to `] (last character in the previously changed text). While ctrl+p just does what p did. (just in case you find you don't want a bit of text auto formatted.).

reference:
:h :nnoremap
:h p
:h =
:h `]

Whatever the name of this idea is, tis something I find handy :)

Happy VIMing






VimTip	{{{1 273: Fast fixing of email quotations (too long lines)



When using VIM as your editor of choice, even for email processing - as I do - it is often unpleasing how some MUA's quote the email body produced by mailers such as Outlook. The lines often span across multiple visual lines and its difficult to reply on certain parts of it.

With VIM, you can quickly fix those quotations to maintain a proper 75 char break. For example, when using Mutt, put this line in your .muttrc, or use a custom .vimrc_mail for it:

set editor="vim -c 'set fo=tcrq' -c 'set tw=76'"

For other MUA's this has to be fitted. However, now, when your quoted email is displayed, you can use this VIM sequence to fix it:

1. move cursor to first line of broken paragraph
2. press 'V' and move to the last line of the paragraph you want to fix
3. press 'g' and then 'q'. The marked text will wrap around to your specified textwidth (76 in our case) and the quotations will be preserved across the lines







VimTip	{{{1 274: Some useful mappings for TeX


You know, TeX requires a lot of additional formatting code. I'm tired of opening and closing braces, brakets,
 \beginning and \ending etc. I particularly hate typing \begin and \end.
To help myself and to save a few(not a few) keystrokes I naturaly came up to some solutions, which I wish to share with
other TeXnicians and TeXperts whhich use Vim.
"===============================cut here=========================
"=============== you can put it in ~/.vim/after/ftplugin/tex.vim ===============
"
" Note: i_<C-L>
" This constructs a skeleton of a TeX environment.
" You write a line like this:
" floatingfigure:ht<C-L>
" and after you press <C-L>, you get:
"
" \begin[ht]{floatingfigure}
" 
" \end{floatingfigure}
" -- INSERT --
" 
" where floatingfigure is the desired environment
" ht are options
" : is delimiter; in fact, you can use whatever delimiter you want
" as long it is not in &iskeyword option.
inoremap <buffer> <C-L> 
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%o\endpO
inoremap <buffer> { {}i
inoremap <buffer> [ []i
inoremap <buffer> ^ ^{}i
inoremap <buffer> _ _{}i
inoremap <buffer> \( \(\)hi
inoremap <buffer> \[ \[\]hi

" Note: v_<C-L>
" For this to work, you have to write on a blank line the name of
" the desired environment and options (see i_<C-L>) and visual select
" (from top to bottom) this and following lines.
" After pressing <C-L> the selected lines will be surrounded
" with begin/end skeleton of the environment.
vnoremap <buffer> <C-L> o
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%gvoo\endp
"	vnoremap <buffer> { di{}P
"	vnoremap <buffer> [ di[]P
vnoremap <buffer>  di^{}P
vnoremap <buffer>  di_{}P
vnoremap <buffer> \( di\(\)hP
vnoremap <buffer> \[ di\[\]hP

" This makes "two spaces after a comma" before every :write
au BufWritePre *.tex %s/,\(\S\)/, \1/ge

"==================== You can put this in your ~/.vimrc ========================
" If cursor is inside braces and not before comma, blank or opening brace,
" exit the brace block and stay in insert mode.
" If cursor is outside braces, it inserts a space or perform an abbreviation
" as normal.
function! CleverSpace()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	let CharAfterCursor = strpart( getline('.'), col('.'), 1)
	if CharOnCursor !~ ',\|\s\|(' && CharAfterCursor =~ ')\|]\|}'
		normal x
	endif
endfunction
inoremap <Space> <Space>:call CleverSpace()<LF>a

" I use the last function not only for LaTeX but also in C sources.






VimTip	{{{1 275: Some useful mappings for TeX


You know, TeX requires a lot of additional formatting code. I'm tired of opening and closing braces, brakets,
 \beginning and \ending etc. I particularly hate typing \begin and \end.
To help myself and to save a few(not a few) keystrokes I naturaly came up to some solutions, which I wish to share with
other TeXnicians and TeXperts whhich use Vim.
"===============================cut here=========================
"=============== you can put it in ~/.vim/after/ftplugin/tex.vim ===============
"
" Note: i_<C-L>
" This constructs a skeleton of a TeX environment.
" You write a line like this:
" floatingfigure:ht<C-L>
" and after you press <C-L>, you get:
"
" \begin[ht]{floatingfigure}
" 
" \end{floatingfigure}
" -- INSERT --
" 
" where floatingfigure is the desired environment
" ht are options
" : is delimiter; in fact, you can use whatever delimiter you want
" as long it is not in &iskeyword option.
inoremap <buffer> <C-L> 
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%o\endpO
inoremap <buffer> { {}i
inoremap <buffer> [ []i
inoremap <buffer> ^ ^{}i
inoremap <buffer> _ _{}i
inoremap <buffer> \( \(\)hi
inoremap <buffer> \[ \[\]hi

" Note: v_<C-L>
" For this to work, you have to write on a blank line the name of
" the desired environment and options (see i_<C-L>) and visual select
" (from top to bottom) this and following lines.
" After pressing <C-L> the selected lines will be surrounded
" with begin/end skeleton of the environment.
vnoremap <buffer> <C-L> o
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%gvoo\endp
"	vnoremap <buffer> { di{}P
"	vnoremap <buffer> [ di[]P
vnoremap <buffer>  di^{}P
vnoremap <buffer>  di_{}P
vnoremap <buffer> \( di\(\)hP
vnoremap <buffer> \[ di\[\]hP

" This makes "two spaces after a comma" before every :write
au BufWritePre *.tex %s/,\(\S\)/, \1/ge

"==================== You can put this in your ~/.vimrc ========================
" If cursor is inside braces and not before comma, blank or opening brace,
" exit the brace block and stay in insert mode.
" If cursor is outside braces, it inserts a space or perform an abbreviation
" as normal.
function! CleverSpace()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	let CharAfterCursor = strpart( getline('.'), col('.'), 1)
	if CharOnCursor !~ ',\|\s\|(' && CharAfterCursor =~ ')\|]\|}'
		normal x
	endif
endfunction
inoremap <Space> <Space>:call CleverSpace()<LF>a

" I use the last function not only for LaTeX but also in C sources.






VimTip	{{{1 276: Function signature previewer


Have you ever tried to call a function which parameters you have forgotten?
Especially those long named and with long parameter list GTK+ functions
like gtk_menu_item_image_from_stock_new(..........) !!!
By accident I saw a function in Vim help. It's name was PreviewWord and it allowed
one to jump in the preview window to the tag for the word cursor is on.
I _slightly_ modified this function not to need tags file, but to search included files instead.
I wrote another function, which uses the above said one, which triggers PreviewWord
when you open the parenthesis after a function name.
Here it is:
" Note:
" This is literally stolen from Vim help. The only changes are:
" (1) if w != ""               becomes       if w =~ "\k"
" (2) exe "silent! ptag " . w  becomes       exe "silent! psearch " . w
" * The first change prevents PreviewWord of searching while cursor is on some
"   non-keyword characters, e.g. braces, asterisks, etc.
function! PreviewWord()
	if &previewwindow			" don't do this in the preview window
		return
	endif
	let w = expand("<cword>")		" get the word under cursor
	if w =~ "\k"				" if there is one ":ptag" to it

		" Delete any existing highlight before showing another tag
		silent! wincmd P			" jump to preview window
		if &previewwindow			" if we really get there...
			match none			" delete existing highlight
			wincmd p			" back to old window
		endif

		" Try displaying a matching tag for the word under the cursor
		let v:errmsg = ""
		exe "silent! psearch " . w
		if v:errmsg =~ "tag not found"
			return
		endif

		silent! wincmd P			" jump to preview window
		if &previewwindow		" if we really get there...
			if has("folding")
				silent! .foldopen		" don't want a closed fold
			endif
			call search("$", "b")		" to end of previous line
			let w = substitute(w, '\\', '\\\\', "")
			call search('\<\V' . w . '\>')	" position cursor on match
			" Add a match highlight to the word at this position
			hi previewWord term=bold ctermbg=green guibg=green
			exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
			wincmd p			" back to old window
		endif
	endif
endfunction
au! CursorHold *.[ch] nested call PreviewWord()

" Note:
" When you open a parenthesis after a function name, and at the
" line end, that function's definition is previewed through PreviewWord().
" This is inspired from Delphi's CodeInsight technology.
" Something similar (PreviewClassMembers) could be written for
" the C++ users, for previewing the class members when you type
" a dot after an object name.
" If somebody decides to write it, please, mail it to me.
function! PreviewFunctionSignature()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	if col(".") == col("$")
		call PreviewWord()
	endif
	return "("
endfunction
inoremap <buffer> ( <C-R>=PreviewFunctionSignature()<LF>







VimTip	{{{1 277: Function signature previewer


Have you ever tried to call a function which parameters you have forgotten?
Especially those long named and with long parameter list GTK+ functions
like gtk_menu_item_image_from_stock_new(..........) !!!
By accident I saw a function in Vim help. It's name was PreviewWord and it allowed
one to jump in the preview window to the tag for the word cursor is on.
I _slightly_ modified this function not to need tags file, but to search included files instead.
I wrote another function, which uses the above said one, which triggers PreviewWord
when you open the parenthesis after a function name.
Here it is:
" Note:
" This is literally stolen from Vim help. The only changes are:
" (1) if w != ""               becomes       if w =~ "\k"
" (2) exe "silent! ptag " . w  becomes       exe "silent! psearch " . w
" * The first change prevents PreviewWord of searching while cursor is on some
"   non-keyword characters, e.g. braces, asterisks, etc.
function! PreviewWord()
	if &previewwindow			" don't do this in the preview window
		return
	endif
	let w = expand("<cword>")		" get the word under cursor
	if w =~ "\k"				" if there is one ":ptag" to it

		" Delete any existing highlight before showing another tag
		silent! wincmd P			" jump to preview window
		if &previewwindow			" if we really get there...
			match none			" delete existing highlight
			wincmd p			" back to old window
		endif

		" Try displaying a matching tag for the word under the cursor
		let v:errmsg = ""
		exe "silent! psearch " . w
		if v:errmsg =~ "tag not found"
			return
		endif

		silent! wincmd P			" jump to preview window
		if &previewwindow		" if we really get there...
			if has("folding")
				silent! .foldopen		" don't want a closed fold
			endif
			call search("$", "b")		" to end of previous line
			let w = substitute(w, '\\', '\\\\', "")
			call search('\<\V' . w . '\>')	" position cursor on match
			" Add a match highlight to the word at this position
			hi previewWord term=bold ctermbg=green guibg=green
			exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
			wincmd p			" back to old window
		endif
	endif
endfunction
au! CursorHold *.[ch] nested call PreviewWord()

" Note:
" When you open a parenthesis after a function name, and at the
" line end, that function's definition is previewed through PreviewWord().
" This is inspired from Delphi's CodeInsight technology.
" Something similar (PreviewClassMembers) could be written for
" the C++ users, for previewing the class members when you type
" a dot after an object name.
" If somebody decides to write it, please, mail it to me.
function! PreviewFunctionSignature()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	if col(".") == col("$")
		call PreviewWord()
	endif
	return "("
endfunction
inoremap <buffer> ( <C-R>=PreviewFunctionSignature()<LF>







VimTip	{{{1 278: all the right moves


One of the principles of effective text editing is moving around very efficiently.
Following are some pointers which may help u do that.

    h      move one character left
    j       move one row down
   k       move one row up
   l         move one char. right.
   w       move to begining of next word
   b       move to begining of previous word
   e       move to end of word
   W     move to begining of next word after a whitespace
   B      move to begining of pervious word before a whitespace
   E      move to end of word before a whitespace.
 
(All the above movements can be preceeded by a numeric value . i.e  '4j' will move 4 rows down )

   ^        move to first non blank char of the line.
   g_      move to last non blank char of the line.
   0        moev to begining of line
   $        move to end of line.
   gg      move to first line.
   G        move to last line.
   nG      move to "n"th line.
   H        top of screen.
  M         middle of screen
   L        bottom of screen
    Ctrl-D   move half page down
    Ctrl-U   move half page up.
    Ctrl-B   page-up
    Ctrl-F   page down.

     Ctrl-o  last cursor position.
     '[a-z,0-9,A-Z]    jump to the marker. (u can set a marker on line by :-   m[a-zA-Z,0-9] and then jump back to it by '[a-z,A-Z0-9]

      n   next matching search pattern
      N  previous matching search pattern
      *    next word under cursor
     #    previous word under cursor.
     g*   next matching search pattern under cursor.
     g#  previous matching search pattern under cursor.







VimTip	{{{1 279: On Windows, make GVim the default action for double-click with "unknown file types"


I find myself installing the following registry modification for all my PC's now (even other people's PC's).  It applies to Microsoft Windows machines only.  The following is also for Windows 9x...  NT or XP or 2000 may require modifications (which I don't care to understand!).

The problem: You double-click on a file that doesn't have a 'registered type' and that pesky "What program should I use?" dialog pops up.  Even worse, depending on the installation, the GVim icon may not be listed, and one has to browse to the executable...  and then the type becomes forever bonded to being editted with GVim (if that box is checked).  The standard Vim 6.1 installation does include a "right click to edit" menu item for all files, but a double-click is so much faster!

The solution: What if unregistered types would just automatically open up in GVim?  Well, they can..  with a little registry trickery.

How to Install it: 

Step 1. Create a text file called "vimalways.reg" and paste the below text into it.  

Step 2.  Important NOTE: You will have to edit the pathname to correspond to the pathname of your GVim.exe.  The text below works fine for a GVim 6.1 default installation.

Step 3: Save the file.

Step 4: Right-click on the file and select "install".  Then you are done!


------ vimalways.reg  ------- cut here ------snip---snip---
REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell]
 
[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\Open with &GVim]
@="Open with &GVim"

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\Open with &GVim\command]
@="\"C:\\vim\\vim61\\gvim.exe\" \"%1\""

----end of file---- cut here----- snip---snip----

Note 1.  This can't be de-installed automatically, and if you want to remove it, you'll have to edit the registry by hand (annoying, but easy).

Note 2.  Keep this file around, so when you upgrade your GVim, all you have to do is modify the pathname (to say, for example, vim62) and then install it again.



Ok, thanks for playing!  
And thanks to the author(s) of Vim and GVim.
If it weren't for them, I'd still be using elvis or stevie!
 






VimTip	{{{1 280: Integration with PyUnit testing framework



Vim has a wonderful ability to integrate with external tools, like compilers, make, ctags etc.
That's one of the reasons we love it.

PyUnit can be seen as a "compiler" for the Python test code. 
To understand it, Vim should be told about the language
the PyUnit speaks. This could be done with 'errorformat' option:

setlocal efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m

This magic spell enables Vim to parse unittest.TextRunner's output and to enter quick-fix mode.
To run all your unit tests at once you'll need to setup 'makeprg' option and provide a runner.
I'm using this setup:

setlocal makeprg=./alltests.py

And contents of the alltests.py (for the sake of completeness):


#!/usr/bin/env python2

import unittest
import sys
sys.path.append('unittests')

modules_to_test = (
	'fooTest', 
	'barTest',
	'bazTest',
)

def suite():
    alltests = unittest.TestSuite()
    for module in map(__import__, modules_to_test):
        alltests.addTest(unittest.findTestCases(module))
    return alltests

if __name__ == '__main__':
    unittest.main(defaultTest='suite')

============== end of the alltests.py file ========================

While talking about it, I'd also suggest to add a couple of mappings.
In the end, my vim/files/ftplugin/python.vim looks like this:

setlocal makeprg=./alltests.py\ -q
setlocal efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
iabbr <buffer> sae self.assertEquals
iabbr <buffer> sar self.assertRaises



For details see :help quick-fix,  :help 'efm' and  :help 'makeprg'.
See also:  http://c2.com/cgi/wiki?PythonUnit

Many thanks to Stefan Roemer who patiently spent quite some time to build 'efm' for me.







VimTip	{{{1 281: Stateful zz


Do you find yourself hitting 'zz' all the time in order to see some context of what you're 
currently working on? If so, then this tip might be for you. If you add the following line
in your vimrc, you can toggle zz mode by pressing <Leader>zz. 

" maintain a constant zz state, second call will toggle it back off
map <Leader>zz	:let &scrolloff=999-&scrolloff<CR>










VimTip	{{{1 282: Folding with Regular Expression


Well, I've tried to understand some of the folding scripts, but life's
too short. Instead, I added the following lines to my vimrc file.

set foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\|\|(getline(v:lnum+1)=~@/)?1:2
map \z :set foldmethod=expr foldlevel=0 foldcolumn=2<CR>

The first line is an extension of foldexpr=(getline(v:lnum)=~@/)?0:1
The second line (re)sets the foldmethod to expr(ession) plus.

First search for /regexp/, then fold everything else with \z
Use zr to reveal more context (before/after) lines.

You could add (getline(v:lnum-2)=~@/)\|\|(getline(v:lnum+2)=~@/)?2:3
but it will take longer as folded lines (the majority) evaluate the full expression.

What could be easier?






VimTip	{{{1 283: Turn on syntax coloring in Mac OS X


This tip is actually for vim 6.1. To turn on syntax coloring in Mac OS X enter the following commands, or place them in your $HOME/.vimrc file.

:set term=builtin_beos-ansi
:syntax on








VimTip	{{{1 284: Mapping to print syntax highlighted buffer in B&W


I use this mapping to print syntax highlighted C++ code in B&W
This tip needs vimscript #233 print_bw. 

The mapping is as follows
map <C-p> :color print_bw<CR>:hardcopy<CR>:color sean<CR>:syn on<CR>

Change ":color sean" to whatever is your chosen color scheme.
Need to change line 7 of print_bw from "syntax reset" to "syntax off"
<C-p> on a syntax highlighted buffer turns off syntax highlighting , sets the colors to B&W, prints the buffer, resets the color scheme and turns on syntax highlighting again.









VimTip	{{{1 285: Don't use the escape key!


Vim (any vi really) is a dream for touch typists... Until you want to switch from insert mode to normal mode.  Then you've got to reach way up to whack the escape key.

Or at least that's what I was doing until I realized that (drum roll please)

                    Esc is exactly equivalent to control-[  (that's the control key plus the left square bracket key)


That little bit of knowledge, plus mapping my caps lock to another control key, was what turned my fascination with Vim into true love.  You never have to lose track of the home row again!

For Xfree86 users - you can make the capslock key another control key by adding

Option "XkbOptions" "ctrl:nocaps"

to the InputDevice section of your XF86Config file.

For Windows NT/2000 users  - use the following .reg file to do the same thing:

REGEDIT4

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00







VimTip	{{{1 286: Recover after doing something... ugly.


I was once editing a file and wanted to test something. The test was meant to add a line at the end of the file, from outside vim. All was fine, but instead of >>, I wrote >. You can imagine what happened... :)

If you happen to do something like that, the solution is:

:recover






VimTip	{{{1 287: Cool trick to change numbers


In the gvim if you want to decrement any number just put ur curcor on that number in Esc mode and pres <CTRL> X






VimTip	{{{1 288: A keymapping to generate Java setters and getters automatically


This mapping makes it much simpler to write new java classes by simplifying some of the dull repetative coding (ie setters and getters).

To use, first write a basic class with the following format:

public class MyClass
{

     private <type> <varname> = <initvalue>;
     private <type> <varname> = initvalue>;

     // getters


     // setters

}


Note the getters/setters comment -- they are important as they are used to place the getters and setters.

The mapping is:

map jgs mawv/ <Enter>"ty/ <Enter>wvwh"ny/getters<Enter>$a<Enter><Enter>public <Esc>"tpa<Esc>"npbiget<Esc>l~ea()<Enter>{<Enter><Tab>return <Esc>"npa;<Enter>}<Esc>=<Enter><Esc>/setters<Enter>$a<Enter><Enter>public void <Esc>"npbiset<Esc>l~ea(<Esc>"tpa <Esc>"npa)<Enter>{<Enter><Tab>this.<Esc>"npa=<Esc>"npa;<Enter>}<Esc>=<Enter>`ak


(the above should be one long line with no spaces between the end of the lines above).

To use this to generate a class go to the variable that should have a setter/getter and place the curser at the beginning of the 'private':

   private <type> <variable> = <initvalue>'
   ^

Then type:

jgs

this will create the first getter/setter and then move up to the next variable.  You can just keep typing jgs until all the  getters/setters have been generated.

This should mapping isn't perfect and someone could probably make it a little cleaner.  It could also relatively easily be adapted to C++.  Please feel free to send me any feedback/enhancements as I am trying to compile a list of these.








VimTip	{{{1 289: Alternative <escape> that allows you to do a "quick and dirty insert" and get out into normal mode


This is an alternative key combo for the escape key from the one mentioned by David A. Rogers in vimtip #285.

I do a lot of editting in Vim, and I've always found myself in situations where I had to "do a quick insert" - basically (from normal mode), change into insert mode, type in one quick word, then <esc> out, then navigate elsewhere.

As has been rightly observed by a lot of people, the <esc> key can sometimes be a little bit out of the way. But that's no problem for ViM, is it?

At first, I thought of editting the ViM source code itself, in order to come up with a command that could do things like say "let me jump into insert mode, type a few quick words, then escape out into normal mode when i press something like double <space>".

It was only later when reading through the section in Jesse Goerz's "Beginner's Guide to ViM" on remapping (http://newbiedoc.sourceforge.net/tutorials/vim/mapping-vim.html) that I got inspired to retake a look at using remapping as an alternative instead.

This is what I came up with.. Use whatever is comfortable for you - single or double <Shift-space>

:map! <S-space> <esc>
:map! <S-space><S-space> <esc>

With this quick combo ("Shift", + <space>), one can easily (and might I add, intuitively) "do a quick insert" and exit quickly out into normal mode. I guess I always thought the <space> would be a good way to do this sort of thing, since it is after all, so intuitive in the typing process. So why not make it such that it can "escape" you out into normal mode as well? Just type 'i', to go into insert mode, type in your stuff, and once you're done, hit Shift-space!







VimTip	{{{1 290: Text Processing With Integrated Spell Checking


I have written an HTML document to help others use Vim as a basic text processing application. It discusses how to integrate spell checking, dictionary, and thesaurus applications. It also talks about wrapping lines, indentation, justification, and the vim settings that effect the behavior of these operations. The document can be found at:
   http://www.highley-recommended.com/text-processing.html

Everything has been tested with UNIX, Linux, Windows, and Windows with Cygwin patforms.






VimTip	{{{1 291: ^P & auto filling of variables and text


Do you know you can auto fill the variable and names as you type your code ? This will help most of the programmers, who always try hard to remember the variable names and browse through all the files to find out the variable name. 
   Use Ctrl+P and Ctrl+N to autofill the variables names etc. Just practice, you will feel the ease of using vim






VimTip	{{{1 292: vim + cscope + cygwin


I've found that vim + cscope + cygwin does not work. The problem seems to be that in 

sprintf(cmd, "exec %s -dl -f %s", prog, csinfo[i].fname);

vim execs cscope with the "-dl" options, causing it to fail. It is probably a cscope bug, but a simple workaround is top build vim without thad "d":

sprintf(cmd, "exec %s -l -f %s", prog, csinfo[i].fname);

seems to work for me!








VimTip	{{{1 293: remember where you had ended reading help



You could jump to the last place you had been while reading Vim help files if you add this to your
.vimrc file:

au BufLeave * if &ft == "help" | mark H | endif

Then use 'H to go to the mark H.

To work between Vim runs 'viminfo' option should be setup to save file marks.
See :help 'viminfo' and :help file-marks for more information.







VimTip	{{{1 294: Use Ctrl-S to save current or new files.


I wanted to have a single key stroke that would save existing files, or call the file browser.
Here's a key map for Ctrl-S to accomplish that (place in vimrc file):

if has("gui_running")
  " If the current buffer has never been saved, it will have no name,
  " call the file browser to save it, otherwise just save it.
  :map <silent> <C-S> :if expand("%") == ""<CR>:browse confirm w<CR>:else<CR>:confirm w<CR>:endif<CR>
endif


Tom Kimpton






VimTip	{{{1 295: Line/word/file/whatever completion


In addition to vimtip #291 you can use whole <C-x> completion mode. It can complete whole lines (<C-x>l, then <C-p>, <C-n>), filenames (<C-f>), keywords, words from custom dictionary and many, many others. During coding it usually saves a LOT of key strokes ;) This mode has many other powerful features, for example when completing word (by <C-x><C-p> or just by <C-p>) you can continue completion with another <C-x><C-p>. For example, after writing such text:

this is first line
second line is here

Placing cursor at third line and pressing <C-x>l will double last line - <C-n>, <C-p> in this moment can be used to manipulate completed line. Or, instead of completing whole line you can press 'f' and then complete by <C-p> which will result in 'first' word. After that you can <C-x><C-p> to get 'line' word (since this is next word after 'first'). Try yourself for other powerful combinations.






VimTip	{{{1 296: Attach the currently open file to email


This is very simple, but most people don't seem to take advantage of this. Often you have some file (source code or other text file) already open in an existing vim session and you need to attach it with an email. It is very simple.
    - First copy the filename into clipboard. For this I put the following mapping in vimrc and press <F2>:
         nnoremap <F2> :let @*=expand("%:p")<cr>
    - Go to your email compose window and use your regular file attachment menu (Insert->File in outlook) and press ^V (or whatever key to paste clipboard) and press Enter.

That is all there to it. If you are on windows and your email client doesn't accept forward-slashes, then you might want to change the map to:

         nnoremap <F2> :let @*=substitute(expand("%:p"), "/", "\\", "g")<cr>

HTH,
Hari






VimTip	{{{1 297: Start in insert mode without loosing your escape key


There are two parts to this, each is fairly simple.

First, I want to start in insert mode.  Well "set im!" in my vimrc did the job, but I lost the escape key.
Second, I have found that often times, when I'm in command mode, I hit escape trying to get back into insert mode.  I am always rewarded with a beep, telling me once again I made that mistake.

So I mapped esc in command mode to set insert mode (":set im") and I mapped esc in insert mode to unset insert mode (<c-o>:set im)  Well then I realized if you hit "i" in command mode, escape woulding work the first time.  So here's the code to add to your vimrc:

set im!                      " start in insert mode
map <esc> :set im!<cr>       " escape in command mode goes to insert mode
map i :set im!<cr>           " i in command mode goes to insert mode
map! <esc> <c-o>:set im!<cr> " escape in insert mode goes to command mode

see :help insert






VimTip	{{{1 298: Changing case with regular expressions


I stumbled across this factoid on a website about vi. I haven't been able to locate it in the Vim documentation, but it works in Vim, and it's very handy.

There are times that you might like to go through a file and change the case of characters that match some arbitrary criteria. If you understand regular expressions well, you can actually do this fairly easily.

It's as simple as placing \U or \L in front of any backreferences in your regular expressions. Vim will make the text in the backreference uppercase or lowercase (respectively).

(A "backreference" is a part of a regular expression that refers to a previous part of a regular expression. The most common backrefernces are &, \1, \2, \3, ... , \9). 

Some examples that demonstrate the power of this technique:

Lowercase the entire file - 
:%s/.*/\L&/g

(& is a handy backreference that refers to the complete text of the match.)

Uppercase all words that are preceded by a < (i.e. opening HTML tag names):
:%s/<\(\w*\)/<\U\1/g

Please add a note if you know where this is in the documentation. I have done Ctrl-D searches on upper, lower, \U, and \L with no luck. 






VimTip	{{{1 299: Open file under cursor.


A little thing that I did and found quite useful:

function! OpenFileUnderCursor()
	let FileName = expand("<cfile>")
	let OldPath = getcwd()
	silent cd %:p:h
	execute "silent sp +e " . FileName
	execute "silent cd " . OldPath
endfunction

map! silent <M-e> :call OpenFileUnderCursor()<CR>

Then use Alt+E on a filename to open it (relative to the directory the current file resides in).






VimTip	{{{1 300: Making a tags file for IDL (Interactive Data Language)


I have recently began using the tags features of vim (:help tags) with my fortran codes and come to appreciate their power.  I also do a lot of coding in IDL (Interactive Data Language), but found that ctags did not have native support for IDL.  If you take the time you can learn how to get ctags to support IDL, but I found, after a search of usenet, that someone else has already done this and written a perl script called idltags.  It is part of an emacs package (is anyone still reading?) that you need to download, called idlwave, which is located at:
                      http://idlwave.org/
and currently (I don't know if this will change) the direct download link is
                      http://idlwave.org/download/idlwave.tar.gz
In the usenet pages the maintainer, JD Smith, was suggesting that idlwave had outgrown idltags and was not sure it was still needed, so I don't know how long it will be available.







VimTip	{{{1 301: Edit files in path, or related.


You can write a little shell function that will let you easily edit any file that is in the path, or which's location can be retrieved with the whereis tool. This is something similar to what I have in /etc/profile:

function vvim() { vim `whereis $1|cut -d: -f2` }
function ggvim() { gvim `whereis $1|cut -d: -f2` }

Then just type, for example, "vvim ls", and you'll start vim with /bin/ls and /usr/share/man/ls.1.gz loaded :)
(it's not very useful to edit /bin/ls, but you get the ideea ;)






VimTip	{{{1 302: Use gvim in kmail


To automatically open gvim to edit in kmail, "-f" command line option must be used .
In kmail configuration go to the composer settings , and write in the "use external editor" field the following 
command :
"gvim -f %f"  
Without -f option gvim would work in background and editing would not have any effect on kmail.






VimTip	{{{1 303: Statusline Tab Level Function Ruler TVIM


I use this function to let me know if my cursor is on a TAB column.
The t* on the ruler means I am not. But t3 means the cursor is on tablevel 3
~vimrc  ----------------------- My Ruler ------------------------ r4,c13,t3
~vimrc  ----------------------- My Ruler ------------------------ r4,c14,t*
If you want to change a tab level you can drag or push the first character
of a line to a desired tab level. (more on that later)
This ruler replacement will let you know where you are, whether you
like to use space tabs (see vimtip #12 ) or regular tabs.  My function is set
to four space tabs stops and only goes 9 levels but can be easily modified.

Actually I just wanted to learn how to use a function in my _vimrc
and this was my first attempt.  Add this to your _vimrc

"--------------------cut------------------
set laststatus=2
"This makes sure the ruler shows.  See    help laststatus
set statusline=%f\ ---------\ My\ Ruler\ ----------\ r%l,c%c,t%{ShowTab()}
"See help statusline  (I toggle between 12 helpful rulers -- more on that later)
fu ShowTab()
    let TabLev='*' 
    let Col=(col(".")) 
    if Col == 1 | let TabLev='0' | en  
    if Col == 5 | let TabLev='1' | en
    if Col == 9 | let TabLev='2' | en
    if Col ==13 | let TabLev='3' | en
    if Col ==17 | let TabLev='4' | en
    if Col ==21 | let TabLev='5' | en
    if Col ==25 | let TabLev='6' | en
    if Col ==29 | let TabLev='7' | en
    if Col ==33 | let TabLev='8' | en
    if Col ==37 | let TabLev='9' | en
return TabLev
endf
"The ruler (statusline) shows a t* unless you are on col 1,5,9,13,...
"-------------------cut-------------------

This function ShowTab() gets called and updates the ruler with every cursor
move but it does not slow things down as I type.  Perhaps a speed typist 
may complain :-)
In case I write something else you may search on the key word TVIM
Best Wishes        TVIM Tamed Vim        paradocs@frontiernet.net






VimTip	{{{1 304: fold braces and javadoc


If you'd like to have javadoc folded together with areas in braces try that
<pre>
set foldmethod=syntax
set foldenable
syn region foldBraces start=/{/ end=/}/ transparent fold 
syn region foldJavadoc start=,/\*\*, end=,\*/, transparent fold keepend
</pre>
and play a bit with:
<pre>
set foldlevel=0
set foldnestmax=10
</pre>
parameters






VimTip	{{{1 305: Best of VIM Tips (VIM's best Features)


Here's a necessarily cryptic list of "MY" Best Vim Tips that I've gleaned
from http://vim.sf.net/  & comp.editors  
http://groups.google.com/groups?safe=off&group=comp.editors

updated version at http://www.rayninfo.co.uk/vimtips.html
------------------------------------------------------------------------------
# Absolutely essential
------------------------------------------------------------------------------
vim.sf.net         : Visit frequently
comp.editors    : "VIM" dominated newsgroup
* # g* g#          : find word under cursor (forwards/backwards)
%                   : match brackets {}[]()
matchit.vim      : % now matches tags <tr><td><script> etc
<C-N> <C-P>   : word completion in insert mode 
<C-X><C-L>    : Line complete SUPER USEFUL
/<C-R><C-W>   : Pull <cword> onto search/command line
:set ignorecase # you nearly always want this
:syntax on    : colour syntax in Perl,HTML,PHP etc
:h slash<C-D> : type control-D and get a list all help topics containing
                   slash (plus use TAB for Help completion)
------------------------------------------------------------------------------
# MAKE IT EASY TO UPDATE/RELOAD_vimrc 
:nmap ,s :source $VIM/_vimrc
:nmap ,v :e $VIM/_vimrc
------------------------------------------------------------------------------
#VISUAL MODE Mappings
:vmap sb "zdi<b><C-R>z</b><ESC> : wrap <b></b> around VISUALLY selected Text
:vmap st "zdi<?= <C-R>z ?><ESC>  : wrap <?=   ?> around VISUALLY selected Text
------------------------------------------------------------------------------
# Exploring
:Ex                             : file explorer note capital Ex
\be                             : builtin buffer explorer
:ls                             : list of buffers(eg following)
:cd ..                          : move to parent directory
------------------------------------------------------------------------------
# Great
guu                             : lowercase line
gUU                             : uppercase line
gf                              : open file name under cursor (SUPER)
ga                              : display hex,ascii value of character under cursor
ggVGg?                          : rot13 whole file
CTRL-A,CTRL-X                   : increment,decerement number under cursor
                                  win32 users must remap CNTRL-A
CTRL-R=5*5                      : insert 25 into text
------------------------------------------------------------------------------
# Makes all other tips superfluous
:h 42                           
:h holy-grail                  
:help!                        
------------------------------------------------------------------------------
# Markers & moving about
'.               : jump to last modification line (SUPER)
`.               : jump to exact spot in last modification line
<C-O>            : retrace your movements in file (old)
<C-I>            : retrace your movements in file (new)
:ju(mps)
:help jump-motions
:history          : list of all your commands
------------------------------------------------------------------------------
# Abbreviations & maps
:map   <f7>   :'a,'bw! c:/aaa/x
:map   <f8>   :r c:/aaa/x
:map   <f9>   :w<CR>:!c:/php/php.exe %<CR>
:map   <f11>  :.w! c:/aaa/xr<CR>
:map   <f12>  :r c:/aaa/xr<CR>
:ab php           : list of abbreviations beginning php
:map ,            : list of maps beginning ,
# For use in Maps
<CR>             : carriage Return for maps
<ESC>            : Escape
<LEADER>         : normally \
<BAR>            : | pipe
------------------------------------------------------------------------------
# List your Registers
:reg             : display contents of all registers
"1p....          : retrieve numeric buffers
------------------------------------------------------------------------------
# Useful trick
"ayy@a            : execute "Vim command" in a text file 
yy@"              : same thing using unnamed register 
------------------------------------------------------------------------------
# Get output from other commands
:r!ls.exe        : reads in output of ls
!!date           : same thing
:%!sort -u       : use an external program to filter content
------------------------------------------------------------------------------
# Multiple Files Management
:wn              : write file and move to next (SUPER)
:bd              : remove file from buffer list (SUPER)
:sav php.html    : Save current file as php.html and "move" to php.html
:sp fred.txt     : open fred.txt into a split
:e!              : return to unmodified file
:w c:/aaa/%      : save file elsewhere
:e #                 : edit alternative file
:e %
:rew                : rewwind to first file in ARGS
:bn                 : next file
:bp                 : next file
:brew
------------------------------------------------------------------------------
# Recording (BEST TIP of ALL)
qq  # record to q
your commands
q
@q to execute
@@ to Repeat
# editing a register/recording
"ap
<you can now see register contents, edit as required>
"add
@a
------------------------------------------------------------------------------
# _vimrc essentials
:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe
:set shiftwidth=3
------------------------------------------------------------------------------
# launching Win IE
:nmap ,f :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>
:nmap ,i :update<CR>: !start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>
------------------------------------------------------------------------------
# FTPing from VIM
cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html 
cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html
gvim ftp://209.51.134.122/public_html/index.html
------------------------------------------------------------------------------
# appending to registers (use CAPITAL)
# yank 5 lines into "a" then add a further 5
"a5yy
10j
"A5yy
------------------------------------------------------------------------------
[I     : show lines matching word under cursor <cword>
------------------------------------------------------------------------------
#Conventional Shifting
:'a,'b>>
# visual shifting (builtin-repeat)
:vnoremap < <gv 
:vnoremap > >gv
------------------------------------------------------------------------------
# searching
/^joe.*fred.*bill/ : normal
/^[A-J]\+/         : search for lines beginning A-J followed by at leat 1 A-J
/forum\(\_.\)*pent   search over possible multiple lines
/fred\_s*joe/i    : any whitespace including newline
/fred\|joe        : Search for FRED OR JOE
------------------------------------------------------------------------------
#substitution
:%s/fred/joe/igc            : general substitute command
:%s/\r//g                   : Delete DOS returns ^M
:'a,'bg/fred/s/dick/joe/gc  : VERY USEFUL
:s/\(.*\):\(.*\)/\2 :  \1/  : reverse fields separated by :
:%s/^.\{-}pdf/new.pdf/  non greedy matching (ie to first pdf)
:s/fred/<c-r>a/g substitute "fred" with contents of register "a"
:%s/^\(.*\)\n\1/\1$/  delete duplicate lines
# non-greedy matching \{-} 
:%s/^.\{-}pdf/new.pdf/
:help /\{-} 
:s/fred/<c-r>a/g substitute "fred" with contents of register "a"
# multiple commands
:%s/\f\+\.gif\>/\r&\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/suck\|buck/loopy/gc  : ORing
:s/__date__/\=strftime("%c")/ : insert datestring
------------------------------------------------------------------------------
# global command
:g/^\s*$/d       :delete all blank lines
:g!/^dd/d        : delete lines not containing string
:v/^dd/d         : delete lines not containing string
:g/fred/,/joe/d  : not line based
:v/./.,/./-1join : compress empty lines
:'a,'b g/^Error/ . w >> errors.txt
:g/cmap\|form/p  : ORing
------------------------------------------------------------------------------
# Paste register *
:redir @*   : redirect commands to paste
:redir END
"*yy        : yank to paste
"*p         : insert paste buffer
------------------------------------------------------------------------------
# Formatting text
gq<CR>
gqap  (a is motion p paragraph (visual mode))
------------------------------------------------------------------------------
# Operate command over multiple files
:argdo %s/foo/bar/
:bufdo %s/foo/bar/ 
:windo %s/foo/bar/ 
------------------------------------------------------------------------------
# Command line tricks
gvim -h
ls | gvim -   : edit a PIPE!!
# vg.ksh (shell script)
# vi all files in directory containing keyword $1 and jump to $1
gvim.exe -c "/$1"  $(grep -isl "$1" *) &
------------------------------------------------------------------------------







VimTip	{{{1 306: Open a web-browser with the URL in the current line


function! Browser ()
    let line = getline (".")
    let line = matchstr (line, "http[^ ]*")
    exec "!netscape ".line
endfunction

map <Leader>w :call Browser ()<CR>






VimTip	{{{1 307: annoying "Hit any key to close this window..."


i use gvim and bash heavily under win98.
i have

let $HOME = substitute($HOME, '\\', '/', 'g')
set shell=bash\ --rcfile\ \"$HOME\"_bashrc\ -i

in my _vimrc, and something like

function br()
{
if [ $1 ]; then
        explorer.exe ${1//\//\\}
    else
        explorer.exe ${PWD//\//\\}
    fi
}

in my _bashrc. when i finish editing one html file,
i simply type :!br %

everything works fine now. but when :!br % executes,
one console window will bump out and wait me to press some
key to contiue. i consider this quiet annoying. i want the console window
to disappear automatically if no fault has happened.
does anyone know how to achieve this?
thanks.






VimTip	{{{1 308: Move through wrapped lines.


If you don't like the fact that when you press Up and Down on a wrapped line, you get to the next phisical line instead of the next line on the screen, you can do something like this:

imap <silent> <Down> <C-o>gj
imap <silent> <Up> <C-o>gk

nmap <silent> <Down> gj
nmap <silent> <Up> gk







VimTip	{{{1 309: close vim you left open remotely


Vim 6 has this cool client-server protocol. I use it all the time to edit a file in an existing gvim, like so
$ gvim --remote [filename]

Today I left myself logged in at the console at work, and when I got home I realized I had left vim running with files  unsaved. I think I even left it in insert mode. I wanted to edit these files at home. So I ssh'd to the machine and started playing with the --remote commands.

:help was a bit cryptic
   --remote-send {keys}         Send {keys} to server and exit.

After a lot of failed attempts, I finally succeeded in getting the remote vim to save its buffers and quit. 

$ DISPLAY=:0 vim --servername GVIM --remote-send '<ESC>:wqa<CR>'

A couple of notable things. Then environment variable DISPLAY has to be the display of the remote vim, and you have to be able to open that display. The client-server stuff is done through X.

The <CR> is important. This part eluded me for a long time. The {keys} are just like keys you would press if you were editing at the console, and you have to press enter, or vim won't do anything.

Check your .swp files to make sure vim really closed the files it was editing. Vim provides little feedback as to the success or failure of what you're trying to do remotely. Nonetheless, it's clearly a useful feature to have available.








VimTip	{{{1 310: showing ascii value of the current character in decimal, hex, and octal


dont know if you guys know this or not, but i was trying to make the word "hello" to upper case by trying "gaUw" (=
which didnt work but it showed the decimal, hex, and octal of the char under the cursor... ncie to know.






VimTip	{{{1 311: Open the folder containing the currently open file


Occasionally, on windows, I have files open in gvim, that the folder for that file is not open. This key map opens the folder that contains the currently open file. The expand() is so that we don't try to open the folder of an anonymous buffer, we would get an explorer error dialog in that case.

if has("gui_running")
 if has("win32")
    " Open the folder containing the currently open file. Double <CR> at end
    " is so you don't have to hit return after command. Double quotes are
    " not necessary in the 'explorer.exe %:p:h' section.
    :map <silent> <C-F5> :if expand("%:p:h") != ""<CR>:!start explorer.exe %:p:h<CR>:endif<CR><CR>
  endif
endif

Tom.







VimTip	{{{1 312: Copy, Cut, and Paste


PS: copy, cut, and paste are the words from (usually) gui editor.

Ever try to cut (or copy) some lines and paste to another place?
If you need to count the lines first, then try these to eliminate counting task.

Cut and Paste:

1. Place the cursor at the beginning of the block you want to CUT.
2. Mark it with md
3. Go to the end of the block.
4. Cut it with d'd
5. Go to the new location that you want to PASTE those text.
6. Press P.

Copy and Paste:

1. Place the cursor at the beginning of the block you want to COPY.
2. Mark it with my
3. Go to the end of the block.
4. Cut it with y'y
5. Go to the new location that you want to PASTE those text.
6. Press P.

The name of the mark used is related to the operation (d:delete or y:yank).
I found that those mark names requires minimal movement of my finger. ;)







VimTip	{{{1 313: printing using kprinter (unix + kde)


just add 
set printexpr=system('kprinter'\ .\ '\ '\ .\ v:fname_in)\ .\ delete(v:fname_in)\ +\ v:shell_error
to your ~/.vimrc; further on all your printing will be piped through the nice and consistent print-dialog of kde.

lg,
tomte






VimTip	{{{1 314: Insert and back...


this is related to vimtip #289 in terms of programmers (like I) too lazy to move their hands to reach the far far away <esc> key.... joking! :)
  actually the less your hands move around the faster you type, and the fester you type the more time you have on your hands to think of "what" you type...

here is a small snippet from my mappings file, ready to speed things up:
// the key overloading might be a somewhat confusing at first....

--cut---
imap <S-Space> <esc>l
imap <C-CR> <esc>o
imap <S-CR> <esc>O

nmap <S-Space> i
nmap <space><space> i
nnoremap <CR> o
nmap <S-CR> O

---uncut---

Good luck!!






VimTip	{{{1 315: "Smart <home>"


to make it faster to navigate through indented code here is a common way to "go home"...

---cut---
fun! s:SmartHome()
    if col('.') != match(getline('.'), '\S')+1
        norm ^
    else
        :call cursor(line('.'),2)
        norm h
    endif
endfun
inoremap <silent><home> <C-O>:call <SID>SmartHome()<CR>
nnoremap <silent><home> :call <SID>SmartHome()<CR>
vnoremap <silent><home> :call <SID>SmartHome()<CR>

---uncut---

what this snippet does is make the <home> key behave as it does in such IDEs as PythonWin or MSVisualStudio, and that is first go to the first non whitespace, and then to the first char on the line.






VimTip	{{{1 316: Using /pattern/ search in a script


There are a number of ways you can search for a pattern in a script.   The search function is the typical way to search for a pattern.  But, it has limited options.  In particular, there are no options to control the position of the cursor after it matches the pattern.   

Instead you can use :normal command.  The secret is to add a <CR> (^M) on the end of the command.   For example, to search for "pattern" and move the cursor to the end of the matching pattern issue the command:

:normal /pattern/e+1^M

where ^M is a real carriage return.  It can be entered with <c-v><c-m>.

Another use is when you want to enter a bunch of normal commands together.  For example, if you were looking to find a '{' to highlight and delete a C block.  The '{' may not be on the same line so you can't use the "f" normal command.   

:normal V/{/^M%d

A drawback to using the normal command is that if the pattern does not match then it is difficult to detect.  Also, you can get in trouble with the wrapscan setting.

For more information about these commands look at

:help /
:help normal
:help search()






VimTip	{{{1 317: Mozilla Vim Keybindings


If you use VIM you like the h, j, k, and l movement keys.  I found myself annoyed at not having these movement keys available when browsing web pages.  Moving to the arrow keys on a laptop is annoying to just scroll the page.  

Locate your mozilla/res/builtin directory (varies by platform). You could search for htmlBindings.xml to find it. (ie. locate htmlBindings.xml.   

On Mac OS X it's inside the Mozilla application bundle.  /Applications/Mozilla/Mozilla.app/Contents/MacOS/res/builtin. 

Create a new XML file called userHTMLBindings.xml, making it executable for all users and making sure the CRLF format is the same as htmlBindings.xml.  i.e. on Mac OS X most files use \r but Vim writes \n instead. You can either save the file with Vim as a Mac formatted file or use tr '\n' '\r' < input.xml > output.xml to convert the file.

Place the following XML into the userHTMLBindings.xml file.

<?xml version="1.0"?>

<bindings id="htmlBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="browserUser">
    <handlers>
      <handler event="keypress" key="h" command="cmd_scrollLeft"/>
      <handler event="keypress" key="j" command="cmd_scrollLineDown"/>
      <handler event="keypress" key="k" command="cmd_scrollLineUp"/>
      <handler event="keypress" key="l" command="cmd_scrollRight"/>
    </handlers>
  </binding>
    </bindings>


There are many more bindings one could configure to get Vim like keybindings.  You can read http://www.mozilla.org/unix/customizing.html#keys for more information.

PS.  I love the keymaster/gatekeeper xul reference in the xul URL above.  It's from the original GhostBusters movie.  ;-)




  






VimTip	{{{1 318: Extended Bracket and Parenthesis + extras for perl


This is an extension of vimtip #153
I found this tip useful, but the jump seemed out of place for me, I couldn't enter just one ' or ", and so I created an improvement
Basically, I set it up so that when you're in perl and have a non keyword charcter, (except for @, $ and % for perl) and you type a { you get:
{
       | <- cursor
}
Where as, when I have a keyword I get:
word{}
With the cursor in the middle, for hashes in perl.  I can jump out of any block, except the "" or '' blocks, by typing their closing charcter.  So } jumps me out past the next } in the file.

Warning, this search may wrap around.

Finally, I made it so that, using the alt key, 
<Alt-'> inserts a '
<Alt-/> inserts a "
<Alt-[> inserts a [
<Alt-]> inserts a ]
<Alt--> inserts a {
<Alt-=> inserts a }
<Alt-,> inserts a <
<Alt-.> inserts a >

"########################################
" File -		matchMe.vim
" Date -		Wednesday, August 21, 2002
"########################################

" This code fixes my problem with 
" does the one format for perl and still keeps hashes
function! InsertBrackets()
	let fileType = &ft

	if fileType == 'perl'
		let col = col('.') - 1
		if !col || getline('.')[col - 1] !~ '\k' && getline('.')[col - 1] !~ '\$' && getline('.')[col - 1] !~ '@' && getline('.')[col - 1] !~ '%'  && getline('.')[col - 1] !~ '#'  
			return "{\<cr>\<bs>}\<esc>ko"
		else
			return "{}\<esc>i\<c-o>:echo \<cr>"
		endif
	else
		return "{\<cr>\<bs>}\<esc>ko"
	endif
endfunction

" This code jumps out of the brackets
function! JumpNext(normChar)
	let ret = "\<space>\<esc>ma\<left>/\\".a:normChar."\<cr>mb`ai\<del>\<esc>`bi\<right>"
	return ret
endfunction

" mappings
inoremap " ""<esc>i<c-o>:echo <cr>
inoremap ' ''<esc>i<c-o>:echo <cr>
inoremap < <><esc>i<c-o>:echo <cr>
inoremap ( ()<esc>i<c-o>:echo <cr>
inoremap [ []<esc>i<c-o>:echo <cr>
inoremap { <c-r>=InsertBrackets ()<cr>
inoremap > <c-r>=JumpNext(">")<cr>
inoremap ) <c-r>=JumpNext(")")<cr>
inoremap ] <c-r>=JumpNext("]")<cr>
inoremap } <c-r>=JumpNext("}")<cr>
inoremap <m-[> [
inoremap <m-]> ]
inoremap <m-/> "
inoremap <m--> {
inoremap <m-=> }
inoremap <m-,> <
inoremap <m-.> >
inoremap <m-'> '

"########################################
" End Of File
"########################################

If you have any other suggestions, drop a note...






VimTip	{{{1 319: text formatting (lining up ='s,('s etc))


some time onw would like to reformat text like
a=1;
foo=2;
longstring=1;
c=2

to

a              =1;
foo           =2;
longstring  =1;
c              =2;

Note I am not sure wether the code above is displayed properly in your browsers what  is basically shows is all the ='s are lined up in a single column
and this  is how we achive it
0f=20i<space><esc>020lvf=hx
and this is what it does
0                             goes to first column
f=                             finds next occurance of = on current line
20i<space><esc>         inserts 20 spaces before =
0                               goesback to first column
20l                             forward 20 column
vf=hx                         deletes everything up to the = sign








VimTip	{{{1 320: Borland pageup/down behavier


borlandbehavier = the cursor keeps the same xy position during pageup/down

Im new to VIM scripting, im sure it can be done smarter? 
I read vimtip #105 and it gave me a clue of how BorlandPageUp/Down could be done.


" i could'nt find any get_number_of_visible_lines function, so i made my own.
function GetNumberOfVisibleLines()
    let cur_line = line(".")
    let cur_col = virtcol(".")
    normal H
    let top_line = line(".")
    normal L
    let bot_line = line(".")

    execute "normal " . cur_line . "G"
    execute "normal " . cur_col . "|"
    return bot_line - top_line
endfunc

" noremap <PageUp> 39<C-U>:set scroll=0<CR>
function! MyPageUp()
    let visible_lines = GetNumberOfVisibleLines()
    execute "normal " . visible_lines . "\<C-U>:set scroll=0\r"
endfunction

" noremap <PageDown> 39<C-D>:set scroll=0<CR>
function! MyPageDown()
    let visible_lines = GetNumberOfVisibleLines()
    execute "normal " . visible_lines . "\<C-D>:set scroll=0\r"
endfunction

" BorlandPascal pageup/down behavier! 
" todo: when hitting top/bottom of file, then restore Y to lastY
noremap <PageUp> :call MyPageUp()<CR>
noremap <PageDown> :call MyPageDown()<CR>







VimTip	{{{1 321: Centura swap with upper/lower line behavier


I was once forced to use a windows development suite called "Centura". 
The only good thing i remember was its swap current_line with upper/lower line.

function! MySwapUp()
    let cur_col = virtcol(".")
    normal ddkkp
    execute "normal " . cur_col . "|"
endfunction

function! MySwapDown()
    let cur_col = virtcol(".")
    normal ddp
    execute "normal " . cur_col . "|"
endfunction

" swap lines and preserve cursorx
" todo: in visual mode, perform swap with line before/after the selection
noremap <S-Up> :call MySwapUp()<CR>
noremap <S-Down> :call MySwapDown()<CR>







VimTip	{{{1 322: text template with placeholders


Many scripts/ftplugin provide text or code templates. Sadly none of the marks the places where you are supposed to "fill in the form".
My own code templates for C/C++ insert a triple percent (%%%) where you are supposed to enter something. I mapped ;; to find the next %%% and change them. 
All the template mappings are insert-mode only, while the "skip to next placeholder" is both insert and normal mode enabled.

A complete for-loop template for C++ looks like:

:imap <buffer> ;fo <C-O>mzfor( %%%; %%%; %%%)<CR>{ // %%%<CR>%%%<CR>}<CR><C-O>'z;;

The command to go to the next placeholder is this:

:imap <buffer> ;; <C-O>/%%%<CR><C-O>c3l
:nmap <buffer> ;; /%%%<CR>c3l


Every time I need a for-loop ;fo produces this ( _ is the cursor position) :
for( _; %%% ; %%%)
{ // %%%
  %%%
}

Now I enter starting value (i=0):
for( i=0_; %%% ; %%%)
{ // %%%
  %%%
}

and go to the condition using ;;
for( i=0; _ ; %%%)
{ // %%%
  %%%
}

and so forth.

The choice of %%% proved to be almost universal, it even works in MATLAB or LaTeX where % is the comment character.

Even if you forget to replace one %%%, that's not a problem as the compiler flags is as a syntax error (except MATLAB and LaTeX, of course).

It made my life easier, maybe it works for you.







VimTip	{{{1 323: using folders with latex


set foldmarker=\\begin,\\end
set foldmethod=marker 

this is useful with big latex document 






VimTip	{{{1 324: Search and replace in files named NAME


I'm not sure if there is a simple way to do this from within Vim, but, I wrote this simple script that does it. It basically searches for files named NAMED (whatever name pass) for a given string and replaces that with a given string:
find_replace.sh NAMED "string_to_find" "string_to_replace"

This is all done from the command line without opening Vim.

Of course one could do things like:
                    :let n = 1
                    :while n <= argc()      " loop over all files in arglist
                    :  exe "argument " . n
                    :  " start at the last char in the file and wrap for the
                    :  " first search to find match at start of file
                    :  normal G$
                    :  let flags = "w"
                    :  while search("foo", flags) > 0
                    :    s/foo/bar/g
                    :    let flags = "W"
                    :  endwhile
                    :  update               " write the file if modified
                    :  let n = n + 1
                    :endwhile

As suggested in the Vim help files :-) but, I wanted to go and find only these files... here is the script:
      1 #!/bin/sh
      2 # Luis Mondesi < lemsx1@hotmail.com >
      3 # DESCRIPTION:
      4 #   it uses vim to replace a given string for 
      5 #   another in a  number of files
      6 #
      7 # usage:
      8 #   find_replace.sh file "string" "replace"
      9 #
     10 if [ $1 -a $2 -a $3 ]; then
     11     for i in `find . -name "$1" -type f | xargs grep -l $2`; do
     12         # how do search and replace
     13         # the screen might flicker... vim opening and closing...
     14         vim -c ":%s/$2/$3/g" -c ":wq" $i
     15     done
     16     exit 0
     17 fi
     18 # I should never reach here
     19 echo -e "USAGE: find_replace.sh file 'string' 'replace' \n\n"
     20 exit 1








VimTip	{{{1 325: Errorformat for java/ant/junit/cygwin/bash


If you program in Java and use Jakarta ant for builds *and* if you have the
bash shell, this tip will make your development experience a little
smoother.

This tip will result in a working compile/edit/debug system (in Win32
vim/gvim and in Cygwin vim) that takes you to the exact lines where the
build fails, whether the failure is a compilation error or a junit test
failure.  If you use bash on a linux box, you shouldn't have to change very
much to get everything to work.

There are 6 sections:
1. set up your build script
2. set up makeprg
3. set up shell options
4. set up path formatting options
5. set up your errorformat
6. set up key mappings

Set up build script
-------------------
Add the following script to your path (I use /usr/local/bin/):

mymake:
#!/bin/bash
cd /work/
ant -emacs $* 2>&1 | tr '\\' / | tr ^M ' ' | sed -u -n -f /usr/local/bin/testerrors.sed | tee /tmp/errors

Comment: sed -u is non-standard, use the code at:
http://mail.gnu.org/pipermail/bug-gnu-utils/2002-May/000192.html to get
the -u option for sed (this avoids waiting for the build output to get to
the screen)

testerrors.sed:
# This assumes that all your junit test cases are in a com.* package
/^Running com\./ {
    # duplicate the line
    s!\(.*\)!\1\
\1!
    P

    # turn the test package into a directory path for %D errorformat
    s!.*\(com\..*\)\.[A-Za-z_][A-Za-z0-9_]*!\1!
    s!\.!/!g
    s!.*!Entering: /work/src/&!

    # print the line and go on
    p
    n
}

# just pass any unmatched lines through
p

Set up makeprg
--------------
Add the following lines to your vimrc:
  autocmd BufNewFile,BufRead /work/*.java set makeprg=mymake
  autocmd BufNewFile,BufRead ?:/work/*.java set makeprg=mymake

Set up shell options
--------------------
Add the following lines to your vimrc:
  " in order to have bash as the shell for win32 vi.exe and gvim.exe, you have
  " to set these options, and also build vimrun.exe in the cygwin environment
  " so that the system() call is executed via bash, not cmd.exe -- the command
  " to build vimrun.exe is "make -f Make_cyg.mak vimrun.exe"
  set shell=bash.exe
  set shellcmdflag=-c
  set shellslash

Also to use this environment in Win32 gvim, you must recompile vimrun so
that gvim invokes the shell via bash, not via cmd.exe.

Set up path formatting options
------------------------------
Add the following lines to your vimrc:
  " allows DOS file names from UNIX (Cygwin) vim
  set isfname+=\

Set up your errorformat
-----------------------
Add the following lines to your vimrc:
  " the "\%DEntering:\ %f," rule relies on a sed script which generates
  " "Entering: " messages for each test class run (the directory name is
  " generated from the test class package and a hard-coded src root)

  " the "%\\C" at the start of the exception matching line tells to match
  " case-exact (the exception mathching lines rely on the %D rule that sets
  " up the correct directory from the package structure)

  " ant/junit/javac errorformat
  set errorformat=
      \%-G%.%#build.xml:%.%#,
      \%-G%.%#warning:\ %.%#,
      \%-G%\\C%.%#EXPECTED%.%#,
      \%f:%l:\ %#%m,
      \C:%f:%l:\ %m,
      \%DEntering:\ %f\ %\\=,
      \%ECaused\ by:%[%^:]%#:%\\=\ %\\=%m,
      \%ERoot\ cause:%[%^:]%#:%\\=\ %\\=%m,
      \%Ecom.%[%^:]%#:%\\=\ %\\=%m,
      \%Eorg.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejava.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejunit.%[%^:]%#:%\\=\ %\\=%m,
      \%-Z%\\C\	at\ com.mypkg.%.%#.test%[A-Z]%.%#(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.setUp(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.tearDown(%f:%l)\ %\\=,
      \%-Z%^\ %#%$,
      \%-C%.%#,
      \%-G%.%#

NOTE: Make sure that the character before "at" is an actual Tab character in
the three long -Z lines above

Here is an annotated version:
  set errorformat=
      " don't treat the build.xml diagnostic as an error
      \%-G%.%#build.xml:%.%#,

      " don't treat warning lines as errors
      \%-G%.%#warning:\ %.%#,

      " don't treat lines containing "EXPECTED" as errors
      \%-G%\\C%.%#EXPECTED%.%#,

      " look for this standard error format
      \%f:%l:\ %#%m,

      " look for this standard error format (with C: on front)
      \C:%f:%l:\ %m,

      " look for special sed-generated "Entering" lines while running tests
      \%DEntering:\ %f\ %\\=,

      " look for exceptions that were thrown in the tests, use the exception
      " description as the error message (don't know how to also include the
      " exception name in the error message)
      \%ECaused\ by:%[%^:]%#:%\\=\ %\\=%m,
      \%ERoot\ cause:%[%^:]%#:%\\=\ %\\=%m,
      \%Ecom.%[%^:]%#:%\\=\ %\\=%m,
      \%Eorg.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejava.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejunit.%[%^:]%#:%\\=\ %\\=%m,

      " using the "Entering" directory and the filename/line number provided
      " in the exception trace, go to the test method where the exception
      " was thrown
      \%-Z%\\C\	at\ com.mypkg.%.%#.test%[A-Z]%.%#(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.setUp(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.tearDown(%f:%l)\ %\\=,

      " empty lines terminate searching for further exception lines
      \%-Z%^\ %#%$,

      " any line can intervene between the start of an exception printout
      " and the line where it ends (last in list so that it is matched if
      " none of the other exception trace patterns match)
      \%-C%.%#,

      " all other lines are not errors
      \%-G%.%#

Set up key mappings
-------------------
Add the following lines to your vimrc:
  nmap <F10> :clist<CR>
  nmap <F11> :cprev<CR>
  nmap <F12> :cnext<CR>

This allows for quick error navigation.


NOTES
-----
Vim treats the "Entering: /work/src/..." messages in a weird way.  If there
are any actual errors, then these error lines are ignored by the :cnext and
:cprev commands, but if there are no real errors, then :cnext and :cprev
roll through these "Entering:" messages as if they were errors, but since
they don't include any line numbers, the cursor position is never moved.

I thought that this was strange, but even stranger, it is programmed
directly into the vim error handling code to function exactly this way.
There were no comments, and nobody responded on the vim mailing list, so I
just decided to live with it.

The upshot of it all is that if you see an error like "Entering:", chances
are that your build succeeded and all the tests ran without a problem.


Hope this helps...

Mail me with bugs at jdsumsion at earthlink.net.






VimTip	{{{1 326: Help for VIM Help (VIM QuickRef)


Type 
:help quickref
or
:h quic  

And get a VIM Command Quick Reference Page brilliant for beginners & oldtimers alike

type
:h help to learn how to use help

Other Help Tips

# help for help
:h visual<C-D><tab>     : obtain  list of all visual help topics
                        : Then use tab to step thru them
:h ctrl<C-D>            : list help of all control keys
:h :r                   : help for :ex command
:h CTRL-R               : normal mode
:h \r                   : what's \r in a regexp
:h i_CTRL-R             : help for say <C-R> in insert mode
:h c_CTRL-R             : help for say <C-R> in command mode
:h v_CTRL-V             : visual mode
:h tutor              : VIM Tutor

These are also listed in my Best Of VIM Tips vimtip #305






VimTip	{{{1 327: key mappings


I use my left thumb for the alt key and right for the space. Using this combo, you can get
some useful key maps for which you don't have to move your hands. I find I have to turn
my hand a little to press the left ctrl key. 

These are some maps i use for C programming.

map ' `
map <C-f> :w<C-m>:!make<C-m>
map <M-]> <C-]>                                         Tags
map <M-[> <C-t>                                          Tags
map <M-u> :!ctags -R *<C-m>                                          Build Tags
map <M-c> I/*<Esc>A*/<Esc>                                          Comment current line
map <M-d> ^xx$xx                                          Delete comment for a single line
map <M-l> [{zf%                                          Fold upto the enclosing brace level
map <M-o> zo                                           open fold
map <M-i> zc                                          close fold
map <M-.> :cn<C-m>                                          Go to next error in list
map <M-,> :cp<C-m>                                          previous error in list

imap <Tab> <C-p>                                                  Complete word
inoremap <S-Tab> <Tab>                                                  Tab
inoremap { <CR>{<CR>                                                  Brace and line
inoremap } <CR>}                                                  brace and line. saves one enter stroke



imap <M-j> <Esc>                                                  Escape. Don't want to move my hand to esc key.
imap <M-k> <C-y>                                                  Copy line from above.
imap <M-q> /*  */<Esc>hhi                                        Comment selected lines

noremap <M-r> ddko{<C-m>}<Esc>kpko             Convert a simple statement to a compound statement. And place cursor above prev line.
noremap <M-k> ddko{<C-m>}<Esc>kpo             Same as above but place cursor below old line.

vnoremap <M-j> <Esc>                   
vnoremap <M-c> di/*<C-m>/<C-m><Esc>kkp           Commented selected text



nmap <M-n> :noh<CR>                       No hilight


Bye,
    Nithin.






VimTip	{{{1 328: Vim in Microsoft Visual Foxpro


You can tell MS VFP to use an external
editor for editing project files.
To tell MS VFP to use Vim:

start regedit
locate
[HKEY_CURRENT_USER
 \Software
  \Microsoft
   \VisualFoxPro
    \5.0
     \Options]

and create a new item 
TEDIT
with string content
"/N C:\Progra~1\vim\vim61\gvim.exe"
(or whatever your path to Vim happens to be.)

This will not replace the internal VFP
editor for such things as modifying the
"click method" for a button
(unfortunately),
but when you modify a program, VFP will
fire up gvim.

Start MS VFP, start Help and 
look for TEDIT. ;-)






VimTip	{{{1 329: A map for swapping words


Put the following map into your <.vimrc>:

  nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>

Then when you put the cursor on or in a word, press "gw", and
the word will be swapped with the next word.  The words may
even be separated by punctuation (such as "abc = def").

While we're talking swapping, here's a map for swapping characters:

  nmap <silent> gc    xph

This hint was formed in a collaboration between
Chip Campbell - Arun Easi - Benji Fisher






VimTip	{{{1 330: how to stop auto indenting


Since VIM 6.0 the indent has been improved so much.
But sometimes when we are pasting formated text (source code or HTML etc)
into a buffer, VIM indents again so that lines will be padded with too
much spaces.

Setting nocindent, noautoindent, nosmartindent still cannot stop this.
All you need to do is "set paste", then paste your stuff, and then
"set nopaste" again.

Ref: indentexpr






VimTip	{{{1 331: modline magic...


  One  of the  things about  vim that  are both  quite simple  yet very 
useful is that you can store  by-file settings... that is each file can 
contain settings specific to it. this  thing is called a modline (:help 
modline). though this  is limited to only the  'set' command arguments, 
you can do allot of local to  file things like the indent type, folding 
method and so on.                                                       

the syntax is as follows:

// vim:set ts=4 sw=4 nowrap:

or

/* vim:noai:ts=2:sw=4: */

  The modlines can be contained in comments so as to not interfere with 
the file  syntax (shown here  for C/C++). these  lines are read  by vim 
when it loads the  file, and they can either be in the  first or last 5 
lines (by default).                                                     

refer to ':help modline'

//and a happy 20th birthday to the good old smiley!! :-)







VimTip	{{{1 332: make footnotes in vim


I found at http://groups.google.com/groups?q=vim+changing+shell+to+zsh&hl=en&lr=&ie=UTF-8&selm=S_Rh9.716%24a5.124150%40news.uchicago.edu&rnum=4
a macro to insert footnotes in vim, but it doesn't work as of vim6.0.
so i wrote my own; this macro requires two differents shortcuts, one for entering the first footnote, the other one for all subsequent footnotes.

when you hit "K0" (first footnote) or "KK" (all other footnotes) in normal mode, your cursor is positionned at the end of the document, in the footnote & in insert mode. The "a" bookmark is set to the place where you entered the footnote in the text. so a "`a" will bring you back to the location of the footnote in the text.

" for now requires entering K0 for the first footnote and then KK                                  nmap K0 i[0]<esc>maG$i<end><enter>[0]
nmap KK maG$?\[[0-9]*\]<enter>yt]G$i<end><enter><esc>p<C-a>i<end>]<esc>`aP<C-a><right>i]<esc>maG$i<end><end>






VimTip	{{{1 333: Syntax-based folding for c/c++/java


Here's a function to toggle the use of syntax-based folding for a c/c++/java file. It also handles folding markers.

function! OutlineToggle()
    if (! exists ("b:outline_mode"))
        let b:outline_mode = 0
    endif

    if (b:outline_mode == 0)
        syn region myFold start="{" end="}" transparent fold
        syn sync fromstart
        set foldmethod=syntax

        silent! exec "%s/{{{/<<</"
        silent! exec "%s/}}}/>>>/"

        let b:outline_mode = 1
    else
        set foldmethod=marker

        silent! exec "%s/<<</{{{/"
        silent! exec "%s/>>>/}}}/"

        let b:outline_mode = 0
    endif
endfunction






VimTip	{{{1 334: Loading scripts in .vimrc safely


If you copy your .vimrc to many places, you might get a problem:
writing a portable .vimrc is sometimes painful.
Maybe in some places you have latest VIM6.1, and in some places
you have VIM 5.x. And maybe you have some favorite scripts in
your own computer while other places does not.

Here're some tips and examples on writing portable .vimrc that will not make error
messages when environment changes:

(1) Check version:
if version >= 600
    set foldcolumn=2
endif

(2) Use environment variables:
source $VIMRUNTIME/vimrc_example.vim

(3) Loading scripts(especially useful for scripts just merged into standard macros):
if filereadable($VIMRUNTIME . "/macros/matchit.vim")
  source $VIMRUNTIME/macros/matchit.vim
endif








VimTip	{{{1 335: Copy C++ function declaration into implementation file


There's a handy plug in for MS Visual Studio called CodeWiz that has a nifty ability to copy a function declaration and deposit it into the implementation file on command.  I actually missed while using vim, so I wrote an approximation of that capability.  This isn't foolproof, but it works alright.  

" Copy Function Declaration from a header file into the implementation file.
nmap <F5> "lYml[[kw"cye'l
nmap <F6> ma:let @n=@/<cr>"lp==:s/\<virtual\>/\/\*&\*\//e<cr>:s/\<static\>/\/\*&\*\//e<cr>:s/\s*=\s*0\s*//e<cr>:s/(.\{-}\zs=\s*[^,)]\{-1,}\>\ze\(\*\/\)\@!.*)/\/\*&\*\//e<cr>:s/(.\{-}\zs=\s*[^,)]\{-1,}\>\ze\(\*\/\)\@!.*)/\/\*&\*\//e<cr>:s/(.\{-}\zs=\s*[^,)]\{-1,}\>\ze\(\*\/\)\@!.*)/\/\*&\*\//e<cr>:let @/=@n<cr>'ajf(b"cPa::<esc>f;s<cr>{<cr>}<cr><esc>kk

To use this, source it into vim, for example by placing it in your vimrc, press F5 in normal mode with the cursor on the line in the header file that declares the function you wish to copy.  Then go to your implementation file and hit F6 in normal mode with the cursor where you want the function implementation inserted.






VimTip	{{{1 336: type the line number and press enter to get there


an easy way to  to get to a line (whose number we know)  faster  is to combine some existing ways that are;
:132<ENTER>
or
123G
or 
123gg

and the solution is to map in normal mode the enter to G

so with 
:nmap <ENTER> G
we can type the line number and then press enter to get there...

it's very small gain ... but it is!!!







VimTip	{{{1 337: editing remote files via scp in vim


VIM 6.x has the netrw plugin installed as a standard plugin. It allows you to edit files via ftp, rcp, scp, or http. If your username differs on the remote host, however, and you're trying to use scp, things can get a little wierd, particularly if you're not editing a document under your user tree.

To get around this, try opening the file as follows: 
    vim scp://remoteuser@server.tld//path/to/document
Notice two things: adding the "remoteuser@" syntax, and the use of two slashes (//) between the servername and the path. The first sets the remote user so that scp will not grab the $USERNAME environment variable, the second will appropriately set the absolute path.






VimTip	{{{1 338: vim + cscope + cygwin


Tip #292 doesn't seem to be true, at least not anymore. I am using cscope 15.4 and vim 6.1. With a few hacks, I was able to get cscope to work with vim under cygwin for Windows 2000. I did not need to change the sprintf line. The hacks included 

1. Copying if_cscope.? to the src directory and the if_cscope.pro to the src/proto directory. These files do not come standard with the Windows source distribution of vim.  (I think it should - anybody in charge of distribution listening?) 

2. Edit if_cscope.c to make the following changes: 

Add the following includes: 
    #include <sys/unistd.h> 
    #include <sys/signal.h> 

3. Edit Make_cyg.mak 

Add if_cscope.o to OBJ variable. 

Add a rule for this at the end 

$(OUTDIR)/if_cscope.o: if_cscope.c $(INCL) 
$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o 

Uncomment the lines following 

#>>>>> uncomment this block to build a GUI version 


4. Edit feature.h 

Force cscope compilation: 

# define FEAT_CSCOPE 

5. make -f Make_cyg.mak GUI=yes 

6. Note that the env variable TMPDIR should be defined in VIM for cscope to work correctly. 

That should do it. Somebody in charge of distribution please make this standard. It would save a lot of trouble. 







VimTip	{{{1 339: "tabbed windows"


This is what I use to emulate the multi-tab environment of certain editors like EditPlus, and easly switch between multiple files being edited (opened with the :split command):

" put this in your .vimrc file to rotate windows with Alt-K / Alt-J
set winminheight=0
nmap <M-k> <C-W>r<C-W>k:resize<CR>
nmap <M-j> <C-W>j<C-W>R:resize<CR>
imap <M-k> <ESC><M-k>i
imap <M-j> <ESC><M-j>i
" end

The only problem is that after a :split you have to Alt-K-J to keep the new window "maximized".






VimTip	{{{1 340: Visual Select And Search


The following visual select and search map is a combination of information
from Benji's vimrc file (vmap S y/<C-R>=escape(@",'/\')<CR>) and a tip that
mentions the "\n" to "\\\\n" substitution.

It works for special characters and multiple lines.

vmap \s y/\V<C-R>=substitute(escape(@",'/\'),"\n","\\\\n","g")<CR>/<CR>

Quick explanation:

vmap       visual map
\s         your choice
y          yank selected text
/          search delimiter
\V         no magic, just text
<C-R>=     expression
substitute substitute "\n" for "\\\\n"
escape     escape '/' (delimiter) and '\' in yanked text (@")
<CR>       end expression
/<CR>      search

Warning: Folding will not match if the foldexpr expression is using
getline() to match against a search pattern that spans multiple lines.

Enjoy.






VimTip	{{{1 341: switch color schemes


This function is similar to the vimtip #211. I did not recognize that s.o.
already wrote a function for that, but this one has one advantage:
It just takes all possible colorschemes in the given directorys and rotates
them. Just put the following code in your .vimrc file:

let SwitchSchemesFiles = globpath("$VIMRUNTIME,$HOME/.vim","colors/*.vim")
let SwitchSchemesIndex = 0

function! SwitchSchemes()
        let sep="\n"
        if g:SwitchSchemesIndex == -1
                let g:SwitchSchemesIndex=0
        endif

        exe "source " . NextElement(g:SwitchSchemesFiles, sep, g:SwitchSchemesIndex)
        let g:SwitchSchemesIndex = NextIndex(g:SwitchSchemesFiles, sep, g:SwitchSchemesIndex + 1)
endfunction

In addition you need the http://www.vim.org/script.php?script_id=109
Put it in the plugin directory.

If you use e.g. a map to F12, you can easily switch between all
installed themes:
map <f12>  :call SwitchSchemes()<CR>








VimTip	{{{1 342: Remap <ESC>


Tired of hunting down <ESC> at upper-left of your keyboard while using a keyboard with useless Windows keys?

Well, remap them -- use xmodmap. I'm using Debian and my xmodmap config file is in /etc/X11/xinit/xmodmap, ymmv. 
You may have to use xmodmap directly (from ~/.xinitrc  in *BSD or whatever).

Anyway, here's my xmodmap:
[ .. other irrelevant mappings skipped ... ]
keycode 115 = braceleft
keycode 116 = Escape
keycode 117 = braceright

Btw, the keys are:
    * 115 - Windows key, between the left-hand Ctrl and Alt keys
    * 116 - Windows key, to the right of the AltGr key
    * 117 - Menu key, to the left of the right-hand Ctrl key

Valid for all environments with X, on *BSD as well as on Linux.
You get the same mappings under ordinary console by modifying the console keymap file (pretty self-explanatory), in my case it's 
/usr/share/keymaps/i386/qwerty/et.kmap.gz.

I'm using mapping braces to winkeys because of my Estonian keyboard.







VimTip	{{{1 343: Faster loading of large files


In the past I experienced long loading times for large files ( size > 10MB )
These files are normally generated by SQL tracing, XML message based
protocols tracing etc.
One of the causes of long loading times was syntax parsing, creating swap file etc.
Normally one want to view these files and remove not relevant details by 
deleting lines, but do not want to have undo capabilities and auto recalculation of 
syntax highlighting.

The code below, I put in my _vimrc to switch off a number of defaults for
large files.

One can modify the g:LargeFile variable and reload a file to test:
:let g:LargeFile=10
:e

It would be interesting to know if others have more or better suggestions.

" Protect large files from sourcing and other overhead.
" Files become read only
if !exists("my_auto_commands_loaded")
        let my_auto_commands_loaded = 1
        " Large files are > 10M
        " Set options:
        " 	    eventignore+=FileType (no syntax highlighting etc
        "            assumes FileType always on)
        "       noswapfile (save copy of file)
        "       bufhidden=unload (save memory when other file is viewed)
        "       buftype=nowritefile (is read-only)
        "       undolevels=-1 (no undo possible)
        let g:LargeFile = 1024 * 1024 * 10
        augroup LargeFile
                autocmd BufReadPre * let f=expand("<afile>") | if getfsize(f) > g:LargeFile | set eventignore+=FileType | setlocal noswapfile bufhidden=unload buftype=nowrite undolevels=-1 | else | set eventignore-=FileType | endif
        augroup END
endif







VimTip	{{{1 344: Cut / Copy / Delete / Paste Lines without knowing the number of lines


If you ever need to cut / copy / delete / paste lines without knowing the actual number of lines, here is what you should do.

1. In the command Mode, Go to the beginning of the first mark (lets say line 50).
2. Type: mk
3. Go to the end of your selection (lets say 100), using j's or Ctrl -F or anything. You don't need to count the lines.
4. Type: "ay'k (i.e. Double Quotes, <reg name from a-z>, <y-yank or d-delete>, single quote, k
5. The above command copies those lines into register a.
6. If you do "ad'k , it will delete them from the current location and copies them into register a.
7. You can paste those lines wherever you want just as you print from registers, i.e. "ap

I use this a lot, since I don't need to count the number of lines.

-Kdr






VimTip	{{{1 345: Visual Studio + vim Quickfix mode + cygwin + XFree86


I run gvim inside a cygwin XFree86 session running WindowMaker.  Because I'm inside cygwin-XFree86, I can't use the useful VisVim plugin to step through Visual Studio compiler errors.  To work around this limitation, I wrote a Bash/Perl script that munges nmake output into something that has cygwin compliant path and is parseable by the default quickfix errorformat setting .

Here's what to do:

1.  install the following from cygwin:

- perl
- cygutils
- bash

2.  Set up Visual Studio to support command line compiles.   Basically this involves adding paths to the PATH, INCLUDE, and LIB environment variables.  See vcvars32.bat in the Visual Studio VC98/bin directory for guidelines.

3.  Export a makefile for your dsp project file via the Visual Studio "Project|Export Makefile..."

4.  Create the cygwin shell script defined below.  Put the script in '/bin/dovcmake' 

---begin cut-----

#!/bin/bash
# This script takes output from
# Visual Studio's nmake and reformats
# it so that it can be parsed by 
# cygwin's vim default errorformat
# setting
nmake /F $1 2>&1 | perl -n -e \
	'	chomp; 
		if(/^([a-z]:[^(]+)\((\d+)\)(.+)$/i) { 
			$f = $1; $l = $2; $m = $3; 
			$f =~ s/\\/\//g; 
			$cyp = `cygpath -au $f`; \ 
			chomp $cyp; 
			print qq{"$cyp",$l:$m\n};} 
		elsif(/error/i) { 
			print qq{$_\n}; 
		}'

---end cut -----

5.  Add this map to your vimrc:

set makeprg=/bin/dovcmake
map <f7> :make <c-r>%<cr>

6.  Fire up cygwin vim and open the makefile from step 3.  If you hit F7, you'll automatically start a Visual Studio build and you'll be able to step through compiler errors via the :cp and :cn commands.







VimTip	{{{1 346: Wrap text in HTML/XML tags after prompting for the tag name



Someone else posted this sometime ago on this mailing list, I have enhanced it slightly and made a tip out of it.
I thought it was pretty clever and very generic.

If you have a block of text and you want to wrap it in <TAG_NAME>...</TAG_NAME> then this function will prompt you for the tag name and wrap the text.

If there is no text VISUALLY selected, it will wrap the current word in the tag, otherwise it will wrap the visually selected text.

It will also strip off any leading spaces.
For the end tag, it will use the first word of the tag only.

Consider an ANT build file, which has tags like this:
<target name="init">
...
</target>

When prompted for the tag you would enter:
target name="init"

And it will wrap the text in:
<target name="init">
...
</target>


" Tag Select/Wrapper
" These mappings and TagSelection function will allow you to place " an XML tag around either the current word, or the current selected " text 
nmap <Leader>t viw<Leader>t 
vnoremap <Leader>t <Esc>:call TagSelection()<CR>

nmap <Leader>t viw<Leader>t
vnoremap <Leader>t <Esc>:call TagSelection()<CR>

function! TagSelection()
  let l:tag = input("Tag name? ")
  " exec "normal `>a</" . l:tag . ">\e"
  " Strip off all but the first work in the tag for the end tag
  exec "normal `>a</" . 
              \ substitute( l:tag, '[ \t"]*\(\<\w*\>\).*', '\1>\e', "" )
  exec "normal `<i" 
              \ substitute( l:tag, '[ \t"]*\(\<.*\)', '<\1>\e', "" )
endfunction







VimTip	{{{1 347: Format paragraph without changing the cursor position


map <silent> <C-j> :let line=line(".")<CR>:let col=col(".")<CR>gqap:exec ":".line<CR>:exec "normal " . col . "\|"<CR>
imap <silent> <C-j> <Esc>:let line=line(".")<CR>:let col=col(".")<CR>gqap:exec ":".line<CR>:exec "normal " . col . "\|"<CR>a







VimTip	{{{1 348: Quickly insert a single word


I've had something like this for a single character for some time, and this may be something that everyone is already doing, but it's really convenient for me.  These two mappings make it quick and easy to insert a word.

nmap <buffer> <silent> ,w :exec ":imap \<space\> \<space\>\<esc\>,BB"<cr>i
nmap <buffer> <silent> ,BB :exec ":iunmap \<space\>"<cr>

Given the sentence:

The quick fox.

To add the word "brown" you would put your curser on the f in fox and type ",w" (or whatever you decide is a good mapping).  Type the word brown.  As soon as you hit space you are out of insert mode.

If there's an easier way to do this, please feel free to comment.

Thanks.







VimTip	{{{1 349: Format your xml document using xmllint


If you open an xml document that is either totally or partially unindented, you can use the GNU libxml2 libary's xmllint to reformat and align your document.  This is especially good if you want to save your xml documents using as little space as possible (which would be totally unindented).  Just add this under the autocmd section of your .vimrc file

au FileType xml exe ":silent 1,$!xmllint --format --recover - 2>/dev/null"

This instructs vim to take the entire contents of a *.xml file and pass it through xmllint, using the --format and --recover flags and silencing any errors that may occur.  This is generally a very effective process and will only mess up on very poorly typed (a large amout of incorrect syntax) xml documents.  Please note that xmllint only adds and removes structural space.  It does not remove space from regular text nodes (as doing so would be incorrect).






VimTip	{{{1 350: when 'formatoptions' has o easily enter a non commented line: go/gO mappings


This is relevant when your 'formatoptions' has o.
From :h fo-table, "Automatically insert the current comment leader after hitting 'o' or 'O' in Normal mode."
I like this behavior enough to keep the o option, however at times I want to NOT insert the comment chars, and although manually deleting the added chars is not hard I present these simple mappings that delete the added chars automatically.

(from my .vimrc)
nnoremap go o<esc>S
nnoremap gO O<esc>S

This makes go open a new line under the cursor and removes inserted chars, while gO opens a new line above the cursor and removes inserted chars.

Your mileage will vary of course (:
Happy VIMing!







VimTip	{{{1 351: Using quickfix in a different way


I'm a software developer and I find vim's quickfix (:help quickfix) very helpful.
You can also use this while debugging your code, in a slightly different way...

Usually, you will have some print messages in your code, and after the program 
runs, you'll look at the output to see the execution trace (e.g which if-constructs
were taken, how many times did a while loop iterate.. ). If you precede these
statements with a <filename>:<linenumber>, then, the program output can be parsed
with a :cfile, and the execution trace becomes very simple.
For instance, in C++

   // fdebug is the pointer to the debug file called, debug.txt say.
   #define DEBUG_MESG( ) fprintf(fdebug, "%0s:%0d\n", __FILE__, __LINE__)

   ...
   
   function( )
   {
      ...
      if (something)
         DEBUG_MESG( );
      else
         DEBUG_MESG( );
      ...
   }

Open your code in vim and do a ":cfile debug.txt"






VimTip	{{{1 352: disabling cabbrev


Have you ever been annoyed by an over-zealous cabbrev? A simple way to temporarily disable it is to set invpaste. Very convenient in combination with the pastetoggle key.






VimTip	{{{1 353: Swap caps-lock and control keys using MS Windows Registry


This will allow you to use the caps-lock key as a control key. Makes using vim in win32 much nicer in my opinion.

Place the following text into a text file with the extension *.reg and update your registry by double-clicking the file:

REGEDIT4

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00








VimTip	{{{1 354: Find in files - recursively (NOT :grep!). Only for unix clones.


You probably know about the grep command in vim (:help grep)
There is one limitation of this - you can't search for a pattern recursively in files (why doesn't grep have some kind of -R option for searching recursively? Have looked around enough at the man pages for that..). The script below does this. Cut-paste this in to your .vimrc/_vimrc. Type ":Fif" (without arguments) to see usage.

   " Start of script
   " Location where the temporary file (.fif.tmp) would be stored
   let g:Fif_tmp_dir = "/tmp"
   function! Fif_fun(...)
      if a:0 == 0
         " Print usage info and quit
         echo "Usage: Fif <pattern-to-be-searched> <file-pattern>. E.g:"
         echo "Fif struct *.c"
         echo "searches for the word struct in all the c files from the current directory"
         return
      endif
      if a:0 != 2
          echohl Error
          echo "Error! Wrong number of arguments. Type :Fif with no arguments to see usage"
          echohl None
          return
      endif
      let tmp_file = g:Fif_tmp_dir . "/.fif.tmp"
      execute "!touch " . tmp_file . " 2> /dev/null"
      if ! filewritable(tmp_file)
         echohl Error
         echo "No permissions to create " . tmp_file
         echo "Try setting the g:Fif_tmp_dir variable to the right value"
         echohl None
         return
      endif
      " Put quotes around the file pattern
      let com_string = '!find . -name "' . a:2 . '" '
      " Do NOT put quotes around the pattern to be searched - leave it to the user
      let com_string = com_string . '-exec grep -n ' . a:1 . ' /dev/null {} \; > ' . tmp_file
      execute com_string 
      if ! filereadable(tmp_file)
         echohl Error
         echo "Can't open " . tmp_file . " for reading"
         echohl None
         return
      endif
      execute "cfile " . tmp_file
      execute '!rm -f ' . tmp_file . ' 2> /dev/null'
   endfunction
   com -nargs=* Fif call Fif_fun(<f-args>)
   " End of script.

No vim magic here, just some shell util usage.
Tested on HPUX.
Should work on Windows with Cygwin. You'll have to
1. Remove those /dev/null's
2. Make sure that the Cygwin's find and grep utils are used, and not the windows ones
3. Change the default value of g:Fif_tmp_dir
4. Cygwin's grep differs from the version I have on HP. For forcing grep to print the filename, you'll have to give it a "-H" option, in addition to "-n"

Some more tinkering can be done with this.. for instance, if you want to search in all the text files, irrespective of the extention, you can consider doing something like this:

   " Find all files.
   let com_string = '!find . -type f -print '
   " Get the file type
   let com_string = com_string . '| xargs file '
   " Filter out the text files
   let com_string = com_string . "| awk '/text/ {print $1}' "
   " Some formatting to remove the trailing ':'
   let com_string = com_string . "| sed 's/://' "
   " grep for the pattern in all the files
   let com_string = com_string . '| xargs grep -n ' . a:1

Cheers!
Karthick.






VimTip	{{{1 355: Comment Lines according to a given filetype


There is probably an easier way to do this, but, if I cannot find an easy solution for a given problem, I just device one that works for the meantime -- which usually becomes permanent :-) .

This function comments out lines according to file type. So if a file is .sh, it uses # to comment lines. And if a file is type .c it will start the comments with /* and end them with */.

Put this lines in your .vimrc file:
" -------- vimrc ---------
" comment out highlighted lines according to file type
" put a line like the following in your ~/.vim/filetype.vim file
" and remember to turn on filetype detection: filetype on
" au! BufRead,BufNewFile *.sh,*.tcl,*.php,*.pl let Comment="#"
" if the comment character for a given filetype happens to be @
" then use let Comment="\@" to avoid problems...
fun CommentLines() 
    "let Comment="#" " shell, tcl, php, perl
    exe ":s@^@".g:Comment."@g"
    exe ":s@$@".g:EndComment."@g"
endfun
    " map visual mode keycombo 'co' to this function
vmap co :call CommentLines()<CR>
" ------- end vimrc -------

Now create a ~/.vim/filetype.vim file if you don't have one and add things like these to it (remember to put a line
filetype on, in your vimrc file ... again if you don't already have one. Vim needs to be compiled with filetype detection
support for this to work. You have been warned.):

-------- filetype.vim ---------

if exists("did_load_filetypes")
    finish
endif

augroup filetypedetect

    au! BufRead,BufNewFile *.inc,*.ihtml,*.html,*.tpl,*.class set filetype=php | let Comment="<!-- " | let EndComment=" -->"

    au! BufRead,BufNewFile *.sh,*.pl,*.tcl let Comment="#" | let EndComment=""

    au! BufRead,BufNewFile *.js set filetype=html | let Comment="//" | let EndComment=""

    au! BufRead,BufNewFile *.cc,*.php,*.cxx let Comment="//" | let EndComment=""

    au! BufRead,BufNewFile *.c,*.h let Comment="/*" | let EndComment="*/"

augroup END

------ end filetype.vim -------

All set, now whenever you are editing a file of those you have defined in your filetype.vim script, you can just go into Visual mode, highlight what you want to comment out, and type "co". Simple.









VimTip	{{{1 356: Quick yank and paste


Since I didn't want to interfere with the standard Vim mappings I removed all the <C-c>, <C-v>, etc. mappings found in the default vimrc. But quickly copy-pasting text is a must, so I added the following keymaps. This is very simple, but it works like a charm.

vmap <C-Space> "ay
nmap <C-Space> "aP
imap <C-Space> <C-o>"ap
nmap <C-c> "ayiw

Niels

My vimrc if you're interested: http://home.student.utwente.nl/n.h.m.aandebrugh/_vimrc






VimTip	{{{1 357: Adding a console to gdbvim



This tip shows how to enhance the gdbvim vimscript #84 by 
making the outputs from gdb appear in a "console buffer" 
inside vim.

"1.a) In gdbvim.vim, one needs to add the following two buffer 
"     manipulation functions:

"--------------------------------------------------------
" Buffer manipulation functions {{{1
"
" function! s:GdbFocusBuf(nameref)  {{{2
" move the focus to the buffer nameref -- create 
" it if it doesn't exist
" return the number of the currently focused buffer 
"
function! s:GdbFocusBuf(nameref)
  let l:oldnr = bufnr("%")
  let l:win_nu = bufwinnr(a:nameref)
  if l:win_nu > 0
    execute l:win_nu "wincmd w"
  else
    if bufexists(a:nameref)
      execute "sbuffer" a:nameref
    else
      execute "new" a:nameref
    endif
  endif
  return l:oldnr
endfunction

" function! s:GdbAppendBuf(nameref, stuff) {{{2
" append stuff to buffer nameref
" 
function! s:GdbAppendBuf(nameref, stuff)
   let l:oldnr = s:GdbFocusBuf(a:nameref)
   call append("$", a:stuff)
   execute "normal G\<End>"
   return l:oldnr
endfunction

"1.b) And modify the two source file management functions
"     to be as follows:

"--------------------------------------------------------
" Source file management functions {{{1
" function! Gdb_Bpt(id, file, linenum) {{{2
"
function! Gdb_Bpt(id, file, linenum)
        let s:nowfile = a:file
        let l:curnr = s:GdbFocusBuf(a:file)
        execute "sign unplace ". a:id
        execute "sign place " .  a:id ." name=breakpoint line=".a:linenum." file=".a:file
        execute a:linenum
endfunction

" function! Gdb_CurrFileLine(file, line) {{{2
"
function! Gdb_CurrFileLine(file, line)
        if a:file != 0
           let s:nowfile=a:file
        endif

        let l:curnr = s:GdbFocusBuf(s:nowfile)

        execute "silent! " . a:line . "foldopen"
        execute "sign unplace ". 1
        execute "sign place " .  1 ." name=current line=".a:line." file=".s:nowfile
        execute a:line
endf


"1.c) And add the following console function: 

"--------------------------------------------------------
" function! Gdb_Console(stuff, set_prompt) {{{2
"
function! Gdb_Console(stuff, set_prompt)

  let l:fooey = s:GdbAppendBuf("console", a:stuff)

  if a:set_prompt == 1
      " What needs to happen here is to enter command mode
      " with the partial command ":Gdb " typed out.
      " The following line shows what doesn't work 
      " call input(":Gdb ")   
  endif 
endfunction

"1.d) And while we are modifying gdbvim.vim, we could also
"     add a text section to the definitions of the signs:

"--------------------------------------------------------
sign define breakpoint linehl=DebugBreak    text=bb
sign define current    linehl=DebugStop     text=cc


#2) The subroutine worker in the perl script gdbvim needs to
#   be modified as indicated below.  The key points to note 
#   are the two calls the vim-script function Gdb_Console().

# this function processes the gdb output, prints it and sends vim commands
sub worker # {{{
{   
    vim_call('Gdb_interf_init(\"'.$PIPE.'\", \"'.$ENV{"PWD"}.'\")');
    print GDB_WTR "set prompt (gdb)\\n\n";
    while (<GDB_RDR>)
    {
        if (/^.*?gdb\)/) 
        {
            print RL_WTR "READ\n";
            chomp ; 
            print $_ . " "; 
            vim_call("Gdb_Console(\\\"$_\\\", 1)");
        }
        else
        {
            my $stuff = $_;
            if(
                  s/Breakpoint ([0-9]+) at 0x.*: file ([^,]+), line ([0-9]+)./Gdb_Bpt($1,\\\"$2\\\",$3)/ ||
                  s/Breakpoint ([0-9]+), 0x.*at ([^,]+):([0-9]+)/Gdb_CurrFileLine(\\\"$2\\\",$3)/ ||
                  s/^\s*0x.*\s+at\s+(\S+):([0-9]+)/Gdb_CurrFileLine(\\\"$1\\\",$2)/ ||
                  s/\032\032([^:]*):([0-9]+).*/Gdb_CurrFileLine(\\\"$1\\\", $2)/  || 
                  s/^\s*0x\S+\s*([0-9]+)\s+.*/Gdb_CurrFileLine(0, $1)/ 
              )
              {
                  chomp;
                  vim_call($_);
              } 
              print $stuff;
              chomp($stuff);
              # the next substitution is because I couldn't figure out how to 
              # pass (from perl) double quotes inside string arguments to 
              # vim-script functions
              $stuff =~ s/"/'/g; 
              vim_call("Gdb_Console(\\\"$stuff\\\", 0)");
        }
    }
    vim_call("Gdb_interf_close()");
    close GDB_RDR; close GDB_WTR;
}; # }}} 

That's all the modifications -- and now gdbvim will show 
the output of gdb inside a vim.  (Errors from gdb won't 
show up in the console but still go to the terminal.)

Happy gdbVimming!

Acknowledgment:
   I learnt about functions in vim-scripts by the process of tracking 
   down an annoying behavior in cvscommand.vim vimscript #90.  
   Also, the author of cvscommand.vim, Bob Hiestand, graciously 
   improved my earlier versions of the functions GdbFoucBuf and 
   GdbAppendBuf. 







VimTip	{{{1 358: Get a random colorscheme on vim startup


This script picks a colorscheme randomly among all available schemes files
when vim starts up.  This is similar to vimtip #341, but differs in that it
is independent of other script liblaries, besides the randomness.

Copy & paste the lines below to somewhere appropriate in your .vimrc.

" Create the comma-separated list of colorscheme files
let s:colors = substitute(globpath(&runtimepath, 'colors/*.vim'), "\n", ',', 'g')
" Make backward slashes forward if necessary
if (has('dos16') || has('dos32') || has('win16') || has('win32') || has('os2')) && !&shellslash
  let s:colors = substitute(s:colors, '\', '/', 'g')
endif

if strlen(s:colors)
  " If there are two or more colorschemes
  if s:colors =~ ','
    let s:rnd = matchstr(localtime(), '..$') + 0
    let s:loop = 0
    " Rotate the list s:rnd times
    while s:loop < s:rnd
      let s:colors = substitute(s:colors, '^\([^,]\+\),\(.*\)$', '\2,\1', '')
      let s:loop = s:loop + 1
    endwhile
  endif
  " Obtain the filename of the first colorscheme in the list.  e.g.:
  "   c:/home/vimfiles/colors/foo.vim
  " Then, trim unecessary parts to get this:
  "   foo
  let s:color = substitute(matchstr(s:colors, '^[^,]\+'), '^.*/\(.*\)\.vim$', '\1', '')
  execute "colorscheme" s:color
endif
unlet! s:colors s:color s:rnd s:loop


Please be noted that adding this script might slightly slow down the startup
time of vim.  Enjoy!






VimTip	{{{1 359: Download RedHat RPMS of the latest and greatest version of VIM.


You can now download RedHat RPMS of the latest and greatest version of VIM.
Here is the annoucement: http://marc.theaimsgroup.com/?l=vim&m=103629270123503&w=2
Here is the download link: http://nirvani.org/software/vim/






VimTip	{{{1 360: ':e <dir>' enter files and directories


You can directly enter files with ':e filename', but did you know you can 'enter' directories that way ?

e.g. ':e ..' opens a buffer window with the entries of the parent directory.
If you then double click on an entry the directory is opened in the same way (if it's a directory) 
or the file is opened for editing (if it's a file).

(Don't ask me, if it's normal vim behaviour or the effect of any script.)






VimTip	{{{1 361: Use xdvi (or kdvi) in conjunction with gvim (or vim) and converse


source: the xdvi man page

For recent xdvi versions (>= 22.38), (or recent Unix/Linux versions), xdvi can
interact with any editor provided with a client-server mode. We explain 
here how to use xdvi in conjunction with vim (compiled with the client-server 
option) or gvim (mostly compiled with this option). I have tested that 
with Linux Mandrake 9.0. On that system, gvim is compiled with the 
client-server option and vim is not.

0-Check that your xdvi version provides the "source-special" functions, 
by typing 'xdvi -version' or 'man xdvi'

1-Configuration of the source file (file.tex)
Put the following line at the beginning of the latex file:
\usepackage[active]{srcltx}
or the following line at the beginning of the tex file
\include{srctex}

2-Configuration of xdvi
xdvi has to be called with the following options
xdvi -editor 'gvim --remote-wait +%l %f' file.dvi &
(or with 'xterm -e vim --remote-wait +%l %f' if vim has 
been compiled with the client-server option).

To make it easier to use you can define an environement 
variable XEDITOR to set the value of 'editor' or add 
the following line in your .Xdefaults
xdvi.editor: gvim --remote-wait +%l %f
Launch 'xrdb -load ~/.Xdefaults' to make sure that 
xdvi.editor is set to the good value.
If you have defined such a variable, xdvi will always be launched 
with the -editor option. To avoid this unsafe behavior, 
launch 'xdvi -safer'.

3-Conversely, if you call xdvi within gvim with the -sourceposition 
option, cursor is placed in the dvi file on the corresponding position.
Syntax is:
xdvi -sourceposition l:cfile.tex file.dvi
l is the line number, c is the column number
(Be carefull: there is no space between "c" (column number) and 
file.tex).
To make it easier to use, you can do the following
First create a file named for example "xdvi_source.vim"
with following lines
" This script calls xdvi source and puts cursor in xdvi viewer at 
" the position corresponding to the position in the source file
" 
:exec "silent !xdvi -sourceposition ".line(".").':'.col(".")."%".' '."%:r.dvi"

Then launch the following command within gvim editing the .tex 
source file. Pressing simultaneously <CTRL> and -> will open 
the dvi file at the right position:
:noremap <buffer> <C-Right> :so xdvi_source.vim<CR>







VimTip	{{{1 362: matchit.vim and coldfusion (and perhaps others)


Hi VIMmites

I couldn't get any tags to match in Coldfusion files *.cfm either HTML Javascript or ColdFusion tags themselves <cfif ..> ... </cfif>

Much pain was gone thru before I realised that the Syntax File for ColdFusion
 (/syntax/cf.vim) was called cf and not cfm

Therefore in matchit.cfm I need to add CF in following line and NOT CFM

au FileType html,jsp,php,cf if !exists("b:match_words") |

zzapper






VimTip	{{{1 363: Starting up Vim very fast expecially from a telnet session


when you telnet to a remote machine and fire Vim on that machine,
sometimes it takes a lot of time for Vim to start.
instead if you use
vim -X 
it will start vim almost instantaneously. This is because "-X" options 
tells vim not to connect to the local X server, which can save a lot of startup time.

Also 
vim -X --noplugin
will not load any plugins in $VIMRUNTIME/plugin directory, this will again speed up the
starting and is very useful especially when running vim from a Disk mounted over NFS.
Njoy






VimTip	{{{1 364: Automatic file type detection with fully qualified ClearCase names


I am using the great plugin from Douglas Potts (vimscript #15).

When you load a specific ClearCase version of a file, vim cannot find the correct file type in the full name (ex. filename.c@@/main/foo/1). To improve that, you can create an autocommand in the filetype.vim file in your user runtime directory.

augroup filetypedetect
  au BufNewFile,BufRead */*@@*
    \ if expand("<afile>") =~ '@@' |
    \   exe "doau filetypedetect BufRead " . expand("<afile>:s?@@.*$??") |
    \ endif
augroup END

The test in the command is for compatibility with path containing '@@' sequence.






VimTip	{{{1 365: Vim Book Online


New Riders has released Steve Oualline book Vi iMproved (VIM) under their Open Publication License (OPL).  View it at http://www.newriders.com/books/opl/ebooks/0735710015.html






VimTip	{{{1 366: really basic RCS interaction from within vim



  I've looked all around and haven't found RCS functions built into vim (which surprises me, really), so I looked more and found some almost working RCS scripts for text-mode.  Key there is almost.  It's still a kludge, but it works without too much hassle.

   I've chosen F1 and F2, because I never use those keys for what they are intended.  I use :help for command reference, not for a tutorial style thing.  So, use some discretion.  Also, the write command could just as easily have been a :write!, but I decided against that in the case of files that weren't checked out.  You should check them out, first, and they should be writable.

map <F1>                :write %<CR>:!ci -l %<CR>:edit!<CR>
map <F2>                :!co -l %<CR>:edit!<CR>

  New RCS files work just fine with the first mapping.

  There would be some use to creating the RCS directory, if it's not already there, but I don't see an "if exists and is directory" function, right now.

  There's a good menu-driven rcs client for graphical vim, but I hate menus and graphical interfaces.






VimTip	{{{1 367: What is this $VIMRUNTIME ?


$VIMRUNTIME points to a directory where most of the files needed by Vim are kept.
As the name suggests these files are needed during "run-time". Though they are not necessary for
Vim to run, but they help in adding extra functionality to the basic Vim.

Here is a brief overview of files and directories in $VIMRUNTIME.

bugreport.vim :- Use this file if you think you have discovered a bug in VIM. see "help bugreport"
colors :- Contains various clorschemes. see ":help :colorscheme"
compiler :- Contains compilation scripts for various languages. see ":help :compiler"
delmenu.vim :- Deletes all Menu's 
doc :- Contains Documentation :-) 
evim.vim :- script for easy vim. see :help evim"
filetype.vim :- Detects filetype of files based on their extensions. see "help filetype"
ftoff.vim :- SOurce this to disable ditection of filetypes.
ftplugin :- Contains plugins that are loaded based on the filetype.
ftplugin.vim :- Enables flietype plugins
ftplugof.vim :- Disables filetype plugins
gvimrc_example.vim :- The name says it all, right :-)
indent :- contains indentaion scripts for various languages
indent.vim :- Enables indentation based on filetype.
indoff.vim :- Disables indentation based on filetype.
keymap :-  Contains keymap files for various encodings. see ":help keymap"
lang :- Contains Message files in different language. see ":help language"
macros :- Contains variuos cool stuff. read "macros/README.txt"
menu.vim :- Default Menus  
mswin.vim :- sets options for Vim to behave like Windows.
optwin.vim :- commands to create option window.
plugin :- Contains plugins. All .vim files in this directory are automatically sourced.
scripts.vim :- helps detect filetype in Vim scripts.
syntax :- Contains Syntax defination files for various programming languages.see ":help syntax"
tools :- Some useful tools. like blink to blink the cursor in xterm.
tutor :- Contains tutor.vim. see ":help tutor"
vim32x32.xpm :- Vim Logo.
vimrc_example.vim :- again name says it all. 
~







VimTip	{{{1 368: Use gvim in VS.Net


This tip presumes you have both VS.Net (Developer Studio.Net) and gvim installed, and know where gvim is located on your system.

- Create a solution in VS.Net, any project type will do.
- In the solution explorer (View->Solution or Ctrl + R) you should see a list of files (click on the "Solution Explorer" tab if you do not see the file list).
- Right click on any of the files and choose "Open With...", this brings up the Open With dialog.
- Click on "Add..." this brings up the Add Program dialog.
- Click on "Browse..." and point the Browse dialog to your gvim location.
- You have now added gvim to the list of editors, you may also select gvim to be the default editor for that file type.

You may need to do this for all file types you wish to edit with gvim. And yes you still have VS.Net open the file in its own editor.
Of course if you want to reverse changes simply remove gvim from the list of editors and why would you want to do that? :)

Enjoy!






VimTip	{{{1 369: Comment/UnComment visually selected text


Comment/UnComment visually selected code
========================================

Visually selected code can be easily Commented out and uncommented by using
the following functions. The functions insert/delete C/C++/Java style 
comments. The comment characters can be modified by editing the functions.

Add the following to your .vimrc file. It will add two menu items under 
the "Edit" menu in gVim. The function calls can be mapped to keystrokes 
if desired. 

------------------------------------------------------------------------------
"Menu items for Commenting and Un-Commenting code
amenu 20.435 &Edit.-SEP4-			:
amenu Edit.Comment <ESC>`<:let fl=line(".")<CR>`>:let ll=line(".")<CR>:call Comment(fl, ll)<CR>
amenu Edit.UnComment <ESC>`<:let fl=line(".")<CR>`>:let ll=line(".")<CR>:call UnComment(fl, ll)<CR>

"Function for commenting a block of Visually selected text
function Comment(fl, ll)
    let i=a:fl
	let comment="//"
	while i<=a:ll
	    let cl=getline(i)
		let cl2=comment.cl
		call setline(i, cl2)
		let i=i+1
	endwhile
endfunction

"Function for Un-Commenting a block of Visually selected text
function UnComment(fl, ll)
    let i=a:fl
	let comment="//"
	while i<=a:ll
	    let cl=getline(i)
		let cl2=substitute(cl, "//", "", "")
		call setline(i, cl2)
		let i=i+1
	endwhile
endfunction
------------------------------------------------------------------------------






VimTip	{{{1 370: always cd to the current file's directory


When I have several or more files from various directories opened and am going to open another, I find it counter-intuitive to specify the file path from Vim's current directory.  I think it's more natural to specify it from current file's directory (though this is not the traditional vi way).  If you feel similarly, this simple tip may help you.

My solution is to have Vim always cd to the current file's directory.  Put this in your .vimrc:

function AlwaysCD()
        if bufname("") !~ "^ftp://"
                lcd %:p:h
        endif
endfunction
autocmd BufEnter * call AlwaysCD()

Note that Vim doesn't cd to a remote machine's directory.  If you never open a file through network, just use this instead:

autocmd BufEnter * lcd %:p:h







VimTip	{{{1 371: Encrypting a file within vim session and not leaving behind traces.


I was desperately looking for a simple way to encrypt files.
(I find this very useful. Despite all the user permissions you set, it's easy for someone/admin
to do sudo and read your personal files..Many work environments provide users the permission
to sudo or become super user)

Vim let's you encrypt file within the edit session. 

:X

Will prompt for encryption key. Enter the encryption key and REMEMBER to save
it using :w. That will encrypt the file.

Try
:help  :X
for more info.

If you don't want to leave behind traces of your edits:
By default, once you finish your vim session, ~/.viminfo will be written with
the  files you edited (marks), commands you entered and possibly what you wrote
(the registers you copied or pasted...). If you don't want such trace to be left behind,
then place the following file in in your .vimrc 

set viminfo='0,\"0,\/0,:0,f0







VimTip	{{{1 372: Remove unwanted empty or blank lines for english and chinese


This tip is inspired by tip #72 which titled 'Remove unwanted empty lines'.
:g/^$/d
==================
Well, if the line contains <Space> and <Tab>
:g/^\s*$/d
==================
If the line contains <Space> and <Tab> and chinese character <Space>, which takes two bytes, and the ASCII is 0xA1 0xA1.

:g/^\(\s\|&#12288;\)*$/d

Herein after the | I paste the `<Space> as a chinese character'.

:g/^[ \t|?]*$/d

Note the `|?' represents a single character which ascii is 0xA1, and inputed by
CTRL-VxA1







VimTip	{{{1 373: Run find/replace/search on multiple files and subdirectories



I wanted to recursively edit all html files in a folder/subfolders and run a search and replace command (substitute) in each one, then save the files when finished.

Vim 6.1.255

This is what my batch (WinXP) file does:
Note, since this is running in a windows batch/command file, I had to
escape the % sign.

First start a new instance of gvim, so it doesn't use one that I am already using.  
Give it a specific name so the commands are contained to it.
start gvim --servername BEAD

Using the FOR statement recursively edit all htm files and send them to the gvim session I just started:
FOR /R %%i IN (*.htm) DO gvim --servername BEAD --remote-silent "%%i"

Now, send the bufo command to that server that will run a substitute command.  
Note, I had to double up the % signs since I am in a batch/cmd file.
I also used the ge options so that no error was reported if the search string was not found.
gvim --servername BEAD --remote-send "<ESC>:bufdo %%s/Tweety Bird/Road
Runner/ge<CR>"

Now save all files and exit
gvim --servername BEAD --remote-send "<ESC>:xall<CR>"


Complete batch/cmd file (minus the ***'s)
***********************
start gvim --servername BEAD
FOR /R %%i IN (*.htm) DO gvim --servername BEAD --remote-silent "%%i"
gvim --servername BEAD --remote-send "<ESC>:bufdo %%s/Tweety Bird/Road
Runner/ge<CR>"
gvim --servername BEAD --remote-send "<ESC>:bufdo
%%s/\(^File:.*JPG\).*/\1/ge<CR>"
rem Write all files and exit
gvim --servername BEAD --remote-send "<ESC>:xall<CR>"
***********************







VimTip	{{{1 374: VIM's Filtering Commands Summary


Vim's Filtering Commands or how to get text into or out of a file

# Redirection to Paste register * (or any other a-z)
:redir @*                    : start redirect commands to paste buffer
:history
:g/fred/
etc etc
:redir END                   : end redirect

# Redirection to a file
:redir >> out.txt            : redirect to a file
blahblah
:redir END                   : end redirect

# Storing glob results in register a (note must use APPEND)
:g/fred/y A                  : append all lines fred to register a
# to a file (must use >>)
:'a,'b g/^Error/ . w >> errors.txt

# Get output from external commands 
:r!ls.exe                    : reads in output of ls
!!date                       : same thing

# Filtering current file using an external command
:%!sort -u                   : use an external program to sort current file
:'a,'b!sort -u               : use an external program to sort current file

These tips are "filtered" from vimtip #353






VimTip	{{{1 375: autocmd for skeleton html file (BufFileNew)


How about starting your new html document with a nice shiny skeleton!

Add this in your autocmd section in your .vimrc file

  " Start with an html skeleton docuement when opening a new *.html file
  au BufNewFile *.html | execute "normal :set ai!\<kEnter>i<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transiti onal//EN\">\<kEnter><html>\<kEnter>  <head>\<kEnter>    <style>\<kEnter>    </style>\<kEnter>    <script>\<kEnte r>    </script>\<kEnter>  </head>\<kEnter>  <body>\<kEnter>  </body>\<kEnter></html>\<ESC>:set ai\<kEnter>gg"






VimTip	{{{1 376: A totally useless tip...or is it ?


Would it not be cool to have your Name listed as part of a Vim command.
Well If you build your VIM from source , you can do that.
CD to the source directory and do
./configure --with-compiledby="<Your Name>" <other-options>

After building and installing Vim,
Whenever you issue 
 :version <enter>
 You will see your Name in the "compiled by" line.
NJoy.






VimTip	{{{1 377: Microsoft Natural Multimedia Keyboard Scancodes


I have collected most of the special keys' scancodes on the Microsoft Natural Multimedia Keyboard.  This might be helpful for those of you that do lots of key-bindings.

http://nirvani.org/docs/Microsoft_natural_multimedia_keyboard_scancodes.html

--
Jeremy Brand <jeremy@nirvani.net>
http://nirvani.org/software/vim/







VimTip	{{{1 378: Auto insert Java class template when editing a new Java file


If you are lazy like me, tend to use lengthy and verbose Java class names, then this tip is for you.  When creating a new Java class file, the first thing that I do after creating it is to add the following block of text:

public class ClassName
{
}

Rather than have to type the ClassName twice (once when you first opened the new file, and then again for this block), you can use this autocmd to insert that text for you automatically:

  autocmd BufNewFile *.java
    \ exe "normal Opublic class " .  expand('%:t:r') . "\n{\n}\<Esc>1G"









VimTip	{{{1 379: 1,$ s/^M//g  gets rid of control-Ms (windows carriage returns)


This has got to be in the tips somewhere else, but darned if I could find it.  I had been bothered by the pesky ^M characters that appeared at the end of lines in files that were generated in MS Windows -- particulary appserver log files for me.  My new best friend showed me this regex substitution that gets rid of them:

:1,$ s/^M//g

Note - If I don't have this in the command buffer, I usually wind up copying and pasting the ^M into the regex if I'm in windows, since I'm not sure how to type it from the keyboard (shift 6 followed by capital M doesn't work).  In unix, I can ususally type ctrl-V followed by Enter to get the ^M.








VimTip	{{{1 380: Using gvim as frontend for dbx


There is a easy, fast way to use gvim as somewhat like a frontend for the solaris dbx - debugger. Add the following to your .dbxrc:

alias sc=" gvim --remote +$vlineno $vfile" 
when stop { gvim --remote +$vlineno $vfile ;}

Allways the debugger stops it shows you the current positon in the gvim. My gvim does'nt take the focus, I dont know why, but so I just can walk through the code.

The sc alias shows the current position and is helpful after loading the executable to show the start (we have'nt stopped at this point).

Unfortunately it doesn't work at the first stop after attaching to a process.










VimTip	{{{1 381: Running the win32-version of Vim from cygwin


This tip does not only concern Vim, but any native win32 application (NWA) we may want to run from cygwin.

Note: I call a "native win32 application", any program that has not been specifically compiled to run on cygwin.
Typical examples are internet explorer, yap, acrobat reader, ... and of course the win32 version of Vim available on this site or on http://cream.sourceforge.net.

The problem with running NWAs from cygwin comes from the fact that paths in cygwin can be expressed in ways that NWAs can't understand. Indeed from cygwin, we can also:
- express paths as *nix-like paths ; e.g.  /etc/profile
- use paths that, as a matter of fact, are symbolic links.

So, to come around this issue, here is a shell script that can be used to define aliases:
    http://hermitte.free.fr/cygwin/cyg-wrapper.sh
[More help available on: http://hermitte.free.fr/cygwin#Win32]

All you have to do is to drop it into one directory from your $PATH, and define into your .profile something like:
    alias gvim='cyg-wrapper.sh "C:/Progra~1/Edition/vim/vim61/gvim.exe" -c'

Notes:
- under MsWindows 9x, I had to writte the path to gvim.exe in the windows short form
- the '-c' is here to tell cyg-wrapper.sh that: when calling VIM, the parameter following '-c' is not a path.
  This enables to write: 
         gvim -c '/^$/' foo.xxx


Regarding the use of *nix-like paths from win32-VIM, check Johannes Zellner's plugin (cygwin.vim) that will convert *nix paths into MsWindows paths on file-opening -- there are different autocommand to add, but it will give you the main idea.
Last point, the win32 version of Vim can not expand paths expressed in the *nix way ;
e.g. ':sp /etc/pr<tab>' won't expand.







VimTip	{{{1 382: Search and replace in all open buffers


Useful for doing simple refactoring i.e. changing a method or variable name. Prompts for a word and then replaces all instances of <cword> in open buffers with the word. 

"---------------------------------------------------------------------------
" Search for <cword> and replace with input() in all open buffers
"---------------------------------------------------------------------------

fun! Replace()
    let s:word = input("Replace " . expand('<cword>') . " with:")
    :exe 'bufdo! %s/' . expand('<cword>') . '/' . s:word . '/ge'
    :unlet! s:word
endfun

map \r :call Replace()<CR>

Thanks to Jurgen Kraemer for showing me how to use the :exe command :)

Sean







VimTip	{{{1 383: a Map to jump to a subroutine/function from where it is called


Hi
When writing/debugging code you often want to jump from where a subroutine/function is called to where it actually  is . Hitting the "*" key is frustrating if the sub/func is called many times. The following mapping solves the problem. (Notice how it can be altered for other lanaguages)

nmap gx yiw/^\(sub\<bar>function\)\s\+<C-R>"<CR>

Instructions: place cursor over called function (normal mode) and type gx


How it works:
yiw : Yank inner work to un-named register
/^\(sub\<bar>function\)\s\+  : search for sub or function followed by 1 or more spaces
<C-R>" : Retrieve un-named register
<CR> : Start Search


(also included in vimtip #305 )






VimTip	{{{1 384: Easily switch between source and header file


To switch between header and source files very quickly, all you need to do is add a few key mappings in your filetype plugin files. Let me explain with an example:

Let's say that you're editing C files, so all you would have to do is edit your ftplugin/c_extra.vim file and include

nmap ,s :find %:t:r.c<cr>
nmap ,S :sf %:t:r.c<cr>

to switch to the corresponding source file, and

nmap ,h :find %:t:r.h<cr>
nmap ,H :sf %:t:r.h<cr>

to switch to the corresponding header file.

The built-in 'find' command will search (recursively or not) for the specified file anywhere in your vim 'path' setting. The 'sf' is short for split-find, meaning that if vim finds your file it will open it in a split window. Simply add the 'vert' keyword before 'sf' if you want a vertical split.

See these help pages for a full description of these built-in features:
help expand   # for a description of the %, :t, :r expansion
help find   # for a description of the 'find' and 'sf' features
help ftplugin   # for a description of how filetype plugins work
help path   # for a description of how the path setting works

This method is also highly configurable. All you have to do is change the 'path' setting when switching to different projects, and modify the corresponding filetype plugin to support other languages.

This tip is very similar to vimscript #31 by Mike Sharpe, however this method only takes a few lines, and his script spans several pages!






VimTip	{{{1 385: some java & vim tips


i started to aggregate some java & vim tips (in part because i easily forget stuff).  they're the kind of tips that are a little elusive but deliver a big bang for their effort; like actually getting quickfix to work with java, using ctags with java, etc....

http://www.ophinity.com/papers/jim/index.html

...on that note, i wonder if vim.org should start organizing tips and scripts into areas of interest or perhaps cross-indexing?  some things that come to mind are document generation (tex/ latex), oracle/ db integration, java development, c/ c++ coding, win32 issues, etc...






VimTip	{{{1 386: Cut/copy and paste using visual selection


Visual selection, although common in applications today, is a key feature that differentiates vim from traditional vi.

To cut (or copy) and paste using visual selection:
1. Position the cursor at the beginning of the text you want to cut/copy.
2. Press v to begin character-based visual selection (or upper case V to select whole lines, or Ctrl-V for a vertical block).
3. Move the cursor to the end of the text to be cut/copied. (While selecting text, you can perform searches and other advanced movement, a feature that sets vim apart from most other editors.)
4. Press d (as in "delete") to cut, or y (as in "yank", which I imagine meaning "yank so hard and fast that it leaves a copy behind") to copy.
5. Move the cursor to the desired paste location.
6. Press p to paste after the cursor, or P to paste before.

In gvim, visual marking (steps 1-3) can be replaced by selecting text using a mouse or similar pointing device, although I strongly prefer to navigate using the keyboard.

Bonus tip: To replace the selected text with new text (to be entered by you), press 'c' instead of 'd' or 'p' on step 4.  This deletes the selection and leaves you in insert mode.  Then, instead of (or prior to) steps 5-6, type your replacement text.






VimTip	{{{1 387: A way to quickly prefix a char(or chars) to a parameter list, via :s


This is a way to quickly prefix a char(or chars) to a parameter list, via :s

In the thought that others may like the same preferred style as I, here is an
easy way to prefix each param with an underscore.

The command:
:s/\<\(\I\i*\s\{-}[,)]\)/_\1/g

A sample menu entry:
amenu  Fe&ral's.Prefix\ underscores\ to\ params        <Esc><Esc>:s/\<\(\I\i*\s\{-}[,)]\)/_\1/g <bar> :noh<CR>


An Example:
Before:
BOOL CSomeView::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)

After:
BOOL CSomeView::Create(DWORD _dwStyle, const RECT& _rect, CWnd* _pParentWnd, UINT _nID)


Happy VIMing :)






VimTip	{{{1 388: Insert C++, LaTeX, and other comments easily


Visual selection combined with powerful replace (:s) command can be used for fast inserting C++ (//), LaTeX (%), and other comments at the beginning of a block of lines. 

If you have, for example, paragraph in a LaTeX file and you want to comment it (so that it does not appear in the output anymore), then you have to insert the percent sign '%' at the beginning of every line. An easy way to do this is to select visually the block of text, press ':' for entering a vim command (which automatically expands to :'<,'>) and to use substitute 

s/^/%/

The whole command then looks like

:'<,'>s/^/<your comment here>/

So just press enter and the comment will be inserted at the beginning of all the selected lines. 

If you want to delete it later, just use column blocks (Control-V starts blockwise visual selection) to select first column(s) and d to delete them.








VimTip	{{{1 389: search only in unfold text(intend to work with diff)


hi, 

sometimes I would like to search/replace the code in the latest version. That is when I show diff between two version of code, I would like to only search the unfold. The following function may do the replace job:

function Foldrepl(spattern, tpattern)
    normal gg            "go to top of the file
    if &diff             "need to change fold option for diff
        exec "set diffopt=context:0"    
    endif    
    "echo a:spattern
    "echo a:tpattern
    let mycount =0
    while search(a:spattern, "W") > 0  "find the search pattern
       if foldlevel(line(".")) < 1     "not in flod 
           exec "s/".a:spattern."/".a:tpattern."/g"  
           let mycount = mycount + 1       
       endif    
    endwhile        

    if &diff            "need to restore fold option, mine is 4
        set diffopt=context:4
    endif    
    echo mycount ." lines are changed"
endfunction

It can be changed to do the search job or both

Demai 






VimTip	{{{1 390: combining vimdiff with cvs diff


i like using vim's diff mode for comparing different revisions of source code files. usually older versions do not live in the directory structure with the current versions, but in a cvs repository. the command below, CVSdiff, can compare the current file to any given revision number in the cvs repository. please note that in case a revision number does not exist, empty files will be displayed, as the below script does not do any error checking (yep, i'm lazy, and this works for me). a vertical split is performed on the current file and its given previous revision.

command -nargs=1 CVSdiff silent call CVSdiff("%", "<args>")
function! CVSdiff(filename, cvsversion)
    " append a:filename to keep extension and therefore highlighting mode
    let patchname = tempname() . a:filename
    let tempname  = tempname() . a:filename
    let newname   = tempname() . a:filename
    execute "!cvs diff -a -r " . a:cvsversion . " " . a:filename . " > " . patch
    execute "!cp " . a:filename . " " . tempname
    execute "!patch -R -o " . newname . " " . tempname . " < " . patchname
    execute "vertical diffsplit " . newname
    call delete(patchname)
    call delete(tempname)
    call delete(newname)
endfunction







VimTip	{{{1 391: Simple programmers TODO list using grep and quickfix


I use this to maintain a TODO list for projects I am working on. All my projects are pretty small scale with each project stored in it's own directory so this tip was writtten with that in mind.  Basically it is two keymappings one which inserts 
//TODO_ITEM 
leaving Vim in insert mode so you can add a note to help you remember what you wanted to do ;) 
The other mapping uses :grep to search for all occurrences of TODO_ITEM in files in the current directory excluding ~ files and then opens the error window displaying the list of TODO_ITEMs. 

imap \q <ESC>i//TODO_ITEM<SPACE>
map \q i//TODO_ITEM<SPACE>
imap \w <ESC>:grep --exclude=*~ TODO_ITEM * <CR> :copen <CR>
map \w :grep --exclude=*~ TODO_ITEM * <CR> :copen <CR>

Change the comment style to suit your language and the lame keymappings to something better.

Sean






VimTip	{{{1 392: fileencodings: how to make it work correctly?


For 6.0+, we have 'encoding', 'fileencoding', and 'fileencodings'.
If I work with Big5(Taiwan), sjis(Japan), ucs-bom, utf-8, and plain ASCII (latin1),
how should I set the *encoding options?

I've tried several cases and finally got something like below:
set fileencodings=plain,ucs-bom,utf-8,big5,sjis

This works fine with loading files.
(The order is important. If you put big5/sjis befure ucs-bom/utf-8,
 the unicode family will never be used)
But if I start editing a plain ASCII file (which will set fileencoding
to latin1) and then entered some non-ASCII characters which is
in unicode, big5, or sjis, then trying to write the file out will get 
an error message like "XXX write error, conversion failed"

Is there a better (or correct) way to set fileencodings so that it
will detect multiple charsets, and to write out in correct manner?







VimTip	{{{1 393: PCRE search and replace (Perl Compatible Regular Expressions)


1. Verify in :ver that +perl or +perl/dyn is compiled in.
2. Install Perl if necessary. On Windows, ActivePerl is required.
3. Type  :perldo s/searchme/replaceme/g 






VimTip	{{{1 394: pop up menu for checking the meaning of the word from internet



 To check the meaning of the word under the cursor, right click
 mouse, and choose Dic. Either IE or mozilla will be opened
 and dictionary service offered by www.m-w.com will be ready.

 Following is the map:

 To open mozilla

 nme <silent> PopUp.&Dic :sil! !start C:/Progra~1/mozilla.org/Mozilla/mozilla -nosplash "http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=<cword>"<CR>

 To open internet explorer:

 nme <silent> PopUp.&Dic :sil! !start iexplore -nohome "http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=<cword>"<CR>

 This is tested for gvim.exe on windows 2000 professional.
 







VimTip	{{{1 395: visual marks


Hi,

Setting visual bookmarks in a file / buffer can be done in a simple way by using VIM's 'sign' feature.
This solution just sets the background of the current line to light blue.

Also see ':help sign'.

Add these lines to your gvimrc:

" define a highlight colour group for bookmarks
hi default BookmarkCol ctermfg=blue ctermbg=lightblue cterm=bold guifg=DarkBlue guibg=#d0d0ff gui=bold

" define a bookmark / sign: just highlight the line
sign define MyBookmark linehl=BookmarkCol

" add something to the context menue (right mouse)
amenu 1.200 PopUp.-SEP3-			:
amenu 1.200 PopUp.&mark.set\ bookmark		:exe 'sign place 1000 name=MyBookmark line='.line(".").' buffer='.winbufnr(0)<CR>
amenu 1.200 PopUp.&mark.del\ bookmarks		:sign unplace 1000 <CR>
amenu 1.200 PopUp.&mark.list\ bookmarks		:sign list<CR>


Happy VIMming

Thomas







VimTip	{{{1 396: Highlighting whitespaces at end of line


Whitespace characters (tabs, spaces, etc) at end of line are rarely meant to be there; they are usually there by accident.  If you don't want them, maybe it pays to highlight them with an alarming color.  (After all, GNU Emacs has it (show-trailing-whitespace), so why not in vim :-) )

Put this in your ~/.vimrc to highlight the whitespace characters at end of line:

highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/







VimTip	{{{1 397: mapping for better browsing of :help docs


I personally find it very akward and un-intuitive to browse the documentation
using Ctrl-] for following the link and Ctrl-Shift-t to go back.

I have had an idea to to remap those commands to Enter and Backspace, since 
I do not use those keys in help in normal mode.

The command :nnoremap <buffer> can remap the key only in the given buffer
without affecting the other buffers.

just create file 
$VIMRUNTIME/ftplugin/help.vim

with following contens
""""""""""""""""""""""""""""""""""""""""""""""""
"""" begining of the file

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" map ctrl-] to enter in normal mode only for this buffer
nnoremap <buffer><cr> <c-]>

" map ctrl-T to backspace in normal mode only for this buffer
nnoremap <buffer><bs> <c-T>

"""" End of the file
""""""""""""""""""""""""""""""""""""""""""""""""








VimTip	{{{1 398: Mapping for quicker access to macros


:nnoremap <space> @q

Start recording keystrokes by hitting 'qq'. 
End recording with 'q'  (<esc> q if you're in insert mode).
Play keystrokes by hitting space.
---
Refs: 
    :help register
    :help record
    

    






VimTip	{{{1 399: fold away empty lines


You can fold sequences of at least two empty lines (may contain blanks) with these settings:

" fold empty lines with white spaces:
syn match MyEmptyLines "\(^[ ^I]*\n\)\+"  fold

You probably can substitute '[ ^I]' with '\s'.
If you have set 'foldcolumn' to more than 0 you can just open/close these empty lines block
by clicking the '+' or '-' with the mouse in the folder column.






VimTip	{{{1 400: Fast scroll mappings (incl. insert mode)


" allow Alt-[movement keys] to scroll window
if !has("gui_running")
    nmap ^[l <A-l>
    nmap ^[h <A-h>
    nmap ^[k <A-k>
    nmap ^[j <A-j>
    vmap ^[l <A-l>
    vmap ^[h <A-h>
    vmap ^[k <A-k>
    vmap ^[j <A-j>
    imap ^[l <A-l>
    imap ^[h <A-h>
    imap ^[k <A-k>
    imap ^[j <A-j>
endif

" To have <A-h> available for the mappings below, search menu.vim for the
" first instance of &Help and change it to Hel&p so that <Alt-H> isn't used
" for the GUI Help menu
nmap <A-l> 4zl
nmap <A-h> 4zh
nmap <A-k> <C-y>
nmap <A-j> <C-e>
vmap <A-l> 4zl
vmap <A-h> 4zh
vmap <A-k> <C-y>
vmap <A-j> <C-e>
imap <A-l> <C-o>4zl
imap <A-h> <C-o>4zh
imap <A-k> <C-x><C-y>
imap <A-j> <C-x><C-e>







VimTip	{{{1 401: A mapping for easy switching between buffers


Instead of using a buffer-explorer I looked for a simpler method for fast switching between buffers. So on a rainy day I invented a simple mapping:

map  <C-Up> :bn<Return>
map  <C-Down> :bp<Return>

This works very well for an intermediate amount of buffers. Of course you can take other keys (instead of the up and down arrows) for the mapping.

Chris.











VimTip	{{{1 402: Just using space-bar: jump between splitted windows and open them wide


Jump between splitted windows and open them wide.
Use only the space-bar for this.
Press space-bar once and you jump to the next window.
Press it twice and the window opens wide for better reading - this works 
for horizontal and vertically open windows.

Put this in your vimrc:

"Jump between windows
map <space> <c-W>w
"Open window wide
map <space><space> :call OpenSplittedWindowWide()<cr>

function OpenSplittedWindowWide()
	normal ^W|
	normal ^W20+
endfunction

Note:
^W must be generated by vim (must be one character).
-------------------------------
The first tip is not new I know it - to jump between windows using the space-bar.
But the combination jumping and opening wide with just using the space-bar this is new.
If not, please apologize, I cannot know all the tips and possibilites published.








VimTip	{{{1 403: Request for tip - interleaving '.' and '@:'


I'm looking for a way to repeat the last command, whether it is an ex command or not. '.' repeats the last non-ex command, while '@:' repeats the last ex command. Can anyone think of a way to interleave the two? It may not seem very useful, but since you can map a keystroke to an ex command (or a sequence of them), isn't it reasonable to expect a uniform way to repeat the last keystroke, without having to remember how it's implemented?

As a random note, it occurs to me that the undo command probably maintains sufficient information to do this - if only we could get at it.






VimTip	{{{1 404: Tags for Mixed Assembly and C


Probably this is a no-brainer, but thought would share it just the same. While accessing C functions/variables from assembly (esp for those DSP/low level guys out there) the usual exhuberant ctags doesn't work. 
The solution
a) Make a copy of 'tags' file 
b) Search and replace all variables & functions of C files with _variables & _functions in the copy file, say 'Tags' 
    (ex in Vim ":g/\.c\>/s/^\(\l.\)/_\1/")
c) In Vim :set tags=tags,Tags 
d) Use Ctrl-] to sail through.

Tried to find an elegant (read complicated) solution, but then gave up :). Of course if you need to be doing ctags all the time write a perl scripts or something to do this.

Cheers






VimTip	{{{1 405: ShowBlockName one-liner equivalent for one coding style


I use [[ and its look-alikes a lot for browsing my C++ code.  You can use ShowLine() and the following mapping to obtain something close to ShowBlockName (and it's pretty fast):

map <silent> z[ [[k:call ShowLine()<CR>``

Thanks for your scripts, Gary Holloway.  I look forward to using z[ heavily!

Cheers,

William






VimTip	{{{1 406: Alternate delimiters for the replace command


This text is from http://www.troubleshooters.com/lpm/200212/200212.htm

-- pasted text --

In many VI implementations you don't need to use the slash character as the expression delimiter. You can use most non-alphanumeric characters (but not \, " or |). This is very handy when working with UNIX filenames, as in the following example:

:s+/usr/local/+/opt/+Whatever character follows the :s is defined to be the delimiter character. If your implementation doesn't support this, you can represent slashes in search and replace expressions by escaping them with backslashes, as follows:

:s/\/usr\/local\//\/opt\//As you can see, the escaping method is much less readable, so if you can use alternative delimiter characters, it's a good idea.







VimTip	{{{1 407: PHPdoc: Use JCommenter.vim for php-scripts


Use JCommenter.vim for php-scripts: 

jcommenter.vim : A script for automatically generating JavaDoc comments 
http://vim.sourceforge.net/script.php?script_id=20

PHPdoc is an imitation of JAVAdoc. 
The syntax between the two languages is very close,
see the examples below:

Example 1:
You have the PHP-function:
function serialize_it($something) {
  $person = serialize($something);
  return $person;
}

Put the cursor on the first line and call :call JCommentWriter()<CR>

You get
/** 
 * 
 * 
 * @param $something 
 * @return 
 */
function serialize_it($something) {
  $personen = serialize($something);
  return $personen;
}

Example 2:
You have the PHP-class:
class submenu {
	...
}

Put the cursor on the first line and call :call JCommentWriter()<CR>

You get
/** 
 * 
 * 
 * @author 
 * @version 
 */
class submenu { 
	...
}

Example 3:
For a class-variable you get:
/** 
* 
*/
var $urls; 

Note:
It does not work if you have = '' like in 
function serialize_it($something = '') {}

But I think jscript.vim can be adapted for the use with PHP.

Klaus






VimTip	{{{1 408: Enhance Calendar (script 52) with special dates


   
To enhance Calendar (vimscript #52) with display of special dates:

Step 1) Create a file called "holidays" in the directory assigned to g:calendar_diary
            (Default value for g:calendar_diary is ~/diary).  
            This file will contain the special dates.  Essence of contents of the
             holidays file is the special dates encoded as (10000+(month*100)+day).

____example_contents_of_file_g:calendar_diary/holidays_________
List of holidays:  ^(10000 + ((month * 100)+day))

Encoded   Sign   Color   Description
 Date    

10101     n      blue    Jan 01   (Wed)      - New Year's Day
10217     p      blue    Feb 17   (Mon)      - President's Day
10214     v      red     Feb 14   (Fri)      - Valentine's Day
10414     s      green   Apr 14   (Mon)      - Spring Break
10526     m      blue    May 26   (Mon)      - Memorial Day
10703     i      gold    
10704     i      gold    Jul 3&4  (Thu & Fri)- Independence Day + 1 day
10901     l      blue    Sep 01   (Mon)      - Labor Day
11127     t      blue    Nov 27&28(Thu & Fri)- Thanksgiving Day + 1 day
11128     t      blue    
11225     c      silver  Dec 25&26(Thu & Fri)- Christmas Day + 1 day
11226     c      silver  Dec 25&26(Thu & Fri)- Christmas Day + 1 day

Step 2)  Add the following to your vimrc file:

let calendar_sign = 'MyGetSpecialDay'
function! MyGetSpecialDay(day, month, year)
  let l:m100d = 10000 + (a:month * 100 ) + a:day 
  let l:holidays = expand(g:calendar_diary) . "/holidays"
  exe "split " . l:holidays
  let l:found = search(l:m100d)
  if l:found
    let l:found = 'h'  
  endif
  quit
  return l:found
endfunction

That's all.

Note:  The preceding constitutes basic support for display of special dates.
          With this basic support, all special dates are shown with the same 
          sign (viz. +) and the same highlight color.  An enhancement would 
          be to pick up the sign and the highlight color from the holidays file.
          (Also, I suspect management of buffer for the holidays file can be 
           speeded up, perhaps by opening it only once, keeping it in the
           background and searching with warp-around flag ('w').)  
   
   







VimTip	{{{1 409: Using selected text as part of a command?


I wish to use selected text as part of a command  - say, to substitute instances of a very long variable with a shorter name:

:%s/<selected text>/ShorterName/g

How would I do this? (Hope its OK to ask a question, as opposed to presenting an answer).






VimTip	{{{1 410: Allow Inform header files to be distinguished from C headers


Inform is an Interactive Fiction authoring language.  It's header files often use a '.h' extension, which causes VIM to think they are
C files, or do not have any extension at all, leaving VIM unable to determine what kind of file they are.  This is irritating to Inform
developers using VIM with syntax highlighting.

The solution is to use a custom 'filetype.vim' and 'scripts.vim'.  Create a '$HOME/.vim/filetype.vim':

    if exists("did_load_filetypes")
      finish
    endif
    augroup filetypedetect
      au BufNewFile,BufRead *.h             call FTCheck_inform()
    augroup END

    " function to detect inform code (any extension)
    fun! FTCheck_inform()
        if getline(1) =~ "^!"
           setfiletype inform
        elseif getline(2) =~ "^!"
           setfiletype inform
        else
            let s:colnum = col('.')
            let s:linenum = line('.')
            call cursor(500, 1)
            if search('\[\(\s*\I\i*\)*\s*;', 'bW') > 0
                setfiletype inform
            endif
            call cursor(s:linenum, s:colnum)
        endif
    endfun

On loading a file with a '.h' extension, a function is called to examine the file for certain Inform-specific constructs.  If it finds any, it sets the filetype as inform, otherwise it leaves the filetype unset, allowing the global 'filetype.vim' to determine the filetype.

For files with no extension, create a '$HOME/.vim/scripts.vim':

   " local scripts.vim gets called when
   " all autocommands have failed to identify file type,
   " but before global scripts.vim
   "
   call FTCheck_inform()

See also the site http://www.stephenthomas.uklinux.net/informvim






VimTip	{{{1 411: How to initialize plugins


Plugins have two basic ways of being initialized:

    a) via some variable that the plugin script uses;
       the initialization here is obvious -- set the
       desired variables in your <.vimrc> (or use
       an appropriate autocmd to do so).

    b) via a map or function call.  The problem here
       is that <.vimrc> is sourced prior to plugin
       sourcing, so the map or function call isn't
       available yet.

       Solution: put in .vim/after/plugin a file
       of the same name as the plugin you're initializing.
       In that file put

            call TheInitializationFunction()

            -or-

            norm TheInitializationMap

For example, the <HiMtchBrkt.vim> script which supports the
highlighting of matching brackets as you move onto a
bracket is not on by default.  Normally it requires one to
type "\[i" to start it.  However, if you'd like to have the
script to start enabled, then put

            norm \[i

into the file <.vim/after/plugin/HiMtchBrkt.vim> (see tip
vimtip#177).

(Windows users: mentally change .vim to _vimfiles and / to \
in the tip above)








VimTip	{{{1 412: Easy menu-style switch between files with a simple map


When there are several files opened in a vim session, it becomes difficult to keep track of the files and their respective buffer numbers.

Switching to a different file is made easier using a simple map:

:map <F5> :buffers<CR>:e #

When F5 is pressed, a numbered list of file names is printed, and the user needs to type a single number based on the "menu".
Another good thing is that the "menu" disappears after choosing the number and hitting enter. So it appears only when you need it.






VimTip	{{{1 413: Drag and Drop file names into VIM's command line


You can open files in VIM by Drag&Drop of selected file names from Windows Explorer. (not very surprising).
This also works by dropping into the VIM command line, so you can e.g. type
 ':split '
 then drag&drop a selected file to VIM window
 and hit <CR>

The complete path and filename is transferred to commandline and the file is opened in a new VIM buffer/window.






VimTip	{{{1 414: Change guifont to see more of your file.


Sometimes, its nice to be able to quickly jump to a smaller font to
see more of the file you're editing at once, and jump back again to
make the text more readable. I use these mapping:

:map <f9> :set guifont=Lucida_Console:h9:cANSI<Cr>
:map <f11> :set guifont=Lucida_Console:h11:cANSI<Cr>
:map <S-f9> :set guifont=Courier_New:h9:cANSI<Cr>
:map <S-f11> :set guifont=Courier_New:h11:cANSI<Cr>

9 and 11 are my mnemonics for the font size. <f10> wouldn't work for me
because it activates the menu. Of course, this only works in gvim.

Ben






VimTip	{{{1 415: easy way to edit two files using split window


In my rc ($HOME/.exrc) file, I have the following lines:

map K ESC:split
map k ^K ^W^W

where the 'ESC', '^K', and '^W^W' are escape sequences.

This allows the user to split the screen using 'K', then switch between the two screens using 'k'.  This in conjuction with the :e to edit a different file can be powerful.  Useful for pulling lines (or blocks) from one file into another without having to cut/paste or use the :r command.  Personally I use this alot so I find it useful.  I got the syntax from the O'Reilly book 'Learning the vi editor' in the section about 'ex commands'.






VimTip	{{{1 416: Fix error "E97: Cannot create diffs" on VIM for Windows


I read a couple postings of people having this issue, even if they have a diff program in their path when running on Windows platforms.
Check out your _vimrc file, function "MyDiff". If the path to the diff file contains ANY spaces, enclose the path in double quotes. Alternatively you can remove the path and just leave the diff file and check.

This is the line that if fixed in my _vimrc:

Changed

  silent execute '!C:\Program Files\Vim\vim61\diff -a ' . opt . v:fname_in . ' ' . v:fname_new . ' > ' . v:fname_out

To be:

  silent execute '!"C:\Program Files\Vim\vim61\diff" -a ' . opt . v:fname_in . ' ' . v:fname_new . ' > ' . v:fname_out

I am running the diff program that comes with CygWin and it works just fine.






VimTip	{{{1 417: combining move and scroll [IMPROVED]


A long time ago, I entered vimtip #105.  I used that mapping for a long time, but it always had a couple problems.  One, it reset the scroll parameter.  Two, it didn't work in visual mode, because :set scroll exits visual mode.  I was reviewing my vim configuration and learning some new tricks, and in the process I improved this mapping.

Now, Ctrl-J and Ctrl-K will move the cursor one line down or up, and scroll one line down or up--so the cursor remains on the same screen line (except near the beginning and end of the file)--in both normal and visual modes.  And the scroll parameter is unaffected.

    " N<C-D> and N<C-U> idiotically change the scroll setting
    function! s:Saving_scroll(cmd)
        let save_scroll = &scroll
        execute "normal" a:cmd
        let &scroll = save_scroll
    endfunction

    " move and scroll
    nmap <C-J>      :call <SID>Saving_scroll("1<C-V><C-D>")<CR>
    vmap <C-J> <Esc>:call <SID>Saving_scroll("gv1<C-V><C-D>")<CR>
    nmap <C-K>      :call <SID>Saving_scroll("1<C-V><C-U>")<CR>
    vmap <C-K> <Esc>:call <SID>Saving_scroll("gv1<C-V><C-U>")<CR>

This is an example of several terrible vim hacks, to boot.






VimTip	{{{1 418: Stop the beeping in gvim.


How do you stop gvim from beeping on error?






VimTip	{{{1 419: Auto-fold perl subs (and possibly other languages)


Add this to your .vimrc file and it'll automatically fold perl functions (and possibly other languages that define a subroutine with "sub ...")
Once you open a perl file, you'll see all functions are folded. You can then move to a function and (space) or "zo" to open it, "zc" to close it, "zR" to open all folds (normal file) and "zM" to re-fold all folds.  It makes skimming over a file a breeze. See ":help folding" for more info on folding in general.

function GetPerlFold()
   if getline(v:lnum) =~ '^\s*sub'
      return ">1"
   elseif getline(v:lnum + 2) =~ '^\s*sub' && getline(v:lnum + 1) =~ '^\s*$'
      return "<1"
   else
      return "="
   endif
endfunction
setlocal foldexpr=GetPerlFold()
setlocal foldmethod=expr







VimTip	{{{1 420: get rid of annoying menu/tool bar


if you also get annoyed by the menu bar and/or tool bar in the gui version of vim, you can get rid
of them with the following:

set guioptions-=m            " to get rid of the menu bar
set go-=T                       " to get rid of the tool bar

and then you're back to the look and feel of how vim should always be =]

-your friendly neighbourhood garbage man.






VimTip	{{{1 421: the simplest map to highlight the current line


This is the simplest map to highlight the current line

nn <silent> K mk:exe 'match Search /\\%'.line(".").'l/'<CR>

Note: abstract from
http://vim.sourceforge.net/tips/tip.php?tip_id=411
http://vim.sourceforge.net/tips/tip.php?tip_id=177

To turn off highlight, type :match<CR>







VimTip	{{{1 422: A Quick Reference


After using vi and similar for a few years, I have accumulated a list of commands I use most often, and pass it on to people starting with vi.  The available quick reference tends to be verbose, but is useful for people with more vi experience (type ":help quickref" or go to  http://vim.sourceforge.net/htmldoc/quickref.html).  For beginners, here is my file:

VI is a text editor.  Its idea is that you manipulate text (as opposed to enter it all the time).  Almost all commands can be "repeated" a number of times, which you specify before typing the command itself (to delete a line, type dd; to repeat the deletion of a line 55 times, type 55dd).

At almost any time, "u" means "undo", and "Esc" stops all command or text entering.  For help, type :help<enter>.  There is a difference between what I call direct and indirect commands: "u" is a direct command, ":h" is an indirect one (it uses an underlying program).

:q to quit, :q! to quit without saving

Entering and manipulating text:

  Command           Interpretation

  .                 repeat the last command
  i<text>Esc        enter <text> on current line, at current position
  I<text>Esc        enter <text> on current line, at beginning of line
  a<text>Esc        enter <text> on current line, at next character position
  A<text>Esc        enter <text> on current line, at the end of the line
  o<text>Esc        enter <text> on a new line below
  O<text>Esc        enter <text> on a new line above
  r<character>      replace  characters by <character> repeated  times, 
                    starting from cursor towards end of line
  s<text>Esc        substitute characters by <text>, starting from cursor
                    towards end of line
  R<text>Esc        substitute characters by <text>, starting from cursor
                    towards end of line
  ~                 change the case
  d                 delete (combine with a movement: dl deletes to the 
                    right, d0 deletes to beginning of line, 5dw deletes 5 
                    words forward)
  dd                delete line
  D                 delete to the end of the line (like d$)
  c                 change (same combinations as with d)
  cc                change line
  C                 change to the end of the line (like c$)
  S                 change line, like cc
  x                 delete the character at the current position
  X                 delete the character at the left (backspace)
  J                 join the next line to the current line
  y                 yank (copy, same combinations as with d)
  p, ]p             paste the result of the last deletion or yanking command 
                    after the cursor
  P, [p             paste the result of the last deletion or yanking command 
                    before the cursor
  /, ?              find forward, backward (then, n means next in the same 
                    direction, N means next in the opposite direction)
  Ctrl-a, Ctrl-x    increase, decrease by 1 the number under the cursor (5Ctrl-a
                    increases by 5)
  :<number1>,<number2>g/<pattern>/<command>
                    on all lines within <number1>,<number2> range and matching 
                    <pattern>, execute <command>.
                    :3,$g/^  table/d
                        deletes all lines from 3 to end of buffer that start
                        with "  table"
                    :%g/[a-z0-9]$/s/boo/table/
                        on all lines in buffer that end with a lowercase letter 
                        or a digit, replace "boo" with "table"
                    :%g/[^RT]umble.*cran[0-6]/m'a
                        move all lines in buffer of the kind "Aumble...cran4"
                        or "Gumble...cran6" (NOT Tumble or Rumble) underneath 
                        line marked as a.
  :<number1>,<number2>v/<pattern>/<command>
                    on all lines within <number1>,<number2> range and not 
                    matching <pattern>, execute <command>.
  :<number1>,<number2>!<command>
                    execute shell <command> on lines <number1> to <number2>

Moving around:

  Command           Interpretation

  0, $              jump to the beginning, end of the line
  h, j, k, l        left, down, up, right (you can also use the arrow keys)
  H, M, L           jump to the highest, middle, lowest line on screen
  {, }              move up, down to the next empty line
  %                 jump to the corresponding parenthesis, square bracket or 
                    curly brace
  [[, ]]            jump to the beginning, end of the file
  :1, :$            jump to the beginning, end of the file
  <number>G         jump to line <number> (without the number, jumps to the 
                    end of the file)
  Ctrl-f, Ctrl-b    next page down, up
  Ctrl-d, Ctrl-u    next half-page down, up
  Ctrl-e, Ctrl-y    shift all the text by one line down, up
  w, b              go forward, backward to the next word
  e, ge             go to the end of the word, backwared to the end of the previous word
  f<char>           goes to the next <char> in the current line
  t<char>           goes to the character just before the next <char>
  m<character>, '<character>
                    set mark <character>, go to mark <character>
  ''                go to the line that was last modified

Manipulating files:

  Command           Interpretation

  :r <file>         read file in
  :w <file>         write current buffer to <file> (default: write current 
                    buffer to current file, if defined)
  :w! <file>        same as write file, overriding permissions
  :wq, ZZ           write to file and quit
  :wq!              write to file and quit, no matter what
  :sp <file>        split window and edit file
  :e <file>         edit <file>
  :n                edit next file in list
  :ls               list buffers
  :buf <number>     edit buffer number <number>

Executing a command easily several times:

  Mapped keys:

    To map a key to a command to execute, type:

      :map <key> <command>

    Then, type <key> to execute <command>.

  Macros:

    To enter a macro, type:

      q<character><commands>q

    To execute the macro <number> (default: 1) times, type:

      <number>@<character>

    Important note: macros can contain calls to mapped keys.

  Registers:

    To use a register named <character>, type "<character> before your command.

      Example: copying the word under the cursor and saving into register z:

        "zyw

      Example: pasting the result of register c before this word or line:

        "cP

    Important note 1: register characters are independent of marks ('a is not affected by "a)
    Important note 2: a macro named <character> is actually stored in the register of same name.  To edit the macro f, just create a new line (o<Esc>), paste the contents of register f ("fp), edit the commands (...), go to the beginning of the line and delete/store the line into register f (0"fD), and remove the temporary line (dd).

Additions to this file are welcome, but make sure it's concise...

William








VimTip	{{{1 423: Finding more available keys to map


One of my ongoing problem with VIM is finding more keys on my keyboard onto which I can map functions without losing some other functionality.  I finally went on a search of terminal emulations that maximize the programability of the keyboard when accessing Linux servers from a Windows 2000 client.

 I am in no way associated with the author or the company, but I wanted to give other VIM users a pointer to check out the ZOC terminal emulator from Emtec at http://www.emtec.com/zoc.  Not only does this support full use of the Alt key, but it also supports compete remapping based on the NumLock and ScrollLock keys.  Keys can be mapped to send any string including binary codings.  ZOC also supports a Linux console terminal mode.

Again I'm not advertising for a particular product; I'm just passing on my solution to a particularly onerous problem when attempting to use the full potential of VIM.






VimTip	{{{1 424: Copy, cut, and paste macros that also work in old vi


The following three mappings implement a useful, quick line-oriented copy, cut, and paste scheme that not only works in VIM but also standard old vi.  These macros use yank or delete commands to either copy or delete lines to named register m where those lines are defined by the motion command to mark m.  The put command is then used to insert the contents of register m at the desired location.

There's nothing special about mark m or register m, thery're just somewhere in the middle.  Meta-g is mnemonic for "get".  Meta-v looks like an insertion mark.  Meta-q looks like Meta-g but with a twist. Of course any other keys, registers, or marks could be used.

map <M-g> mn"my'm`n
map <M-q> "md'm
map <M-v> "mp

To copy some lines ( only in command mode ):
1. Put the cursor on the first or last line and press "mm" 
2. Move to the other end of the line range, last or first, and press meta-g
3. Move to the line above where you wish to insert the lines and press meta-v

To cut some lines and move them to a new location use the same procedure but replace meta-g in step 2 with meta-q.

I find that in programming I constantly use these simple functions to position code in the proper place.  I started using this scheme years ago and find it useful now because not all systems have vim, and because it is so quick and easy that it has become part of my finger habits.  Some day I will have to learn the visual mode of VIM better.






VimTip	{{{1 425: Forcing Syntax Coloring for files with odd extensions


If you are editting a file containing PHP script (for example) but the file doesn't have the extension .php

you can force the desired syntax coloring with

:set syntax=php

similarly
:set syntax=perl
:set syntax=html

Alternatively if the extension causes an undesired coloring, switch off coloring with
:set syntax=off

look in the directory *vim/vim61/colors/ for supported languages








VimTip	{{{1 426: Protecting a file you're referencing


A common programmimg situation, you are comparing two versions of the same file.

One is the "reference file" which you DONT WANT to update.

However they look so similar that you can get confused.

Solution:
:set ro   (readonly) in the master file
additionally change it's color scheme (peachpuff is quite a benign one!)

:colorscheme peachpuff

look in vim/vim61/colors for available colorschemes







VimTip	{{{1 427: Fast window resizing with +/- keys


Depending on your willingness to occasionally consume the + and - keys, here's a fast way to resize the active window if you have more than one window open:

if bufwinnr(1)
  map + <C-W>+
  map - <C-W>-
endif

I normally use the scrollpad + and - keys.

The map eliminates the need for time-consuming chording and if you liked chording, you'd be using Emacs instead of Vim anyway...








VimTip	{{{1 428: Wordwise Ctrl-Y in insert mode


Ctrl-Y in insert mode is one of Vim's handy extensions that inserts character which is above cursor (see :help i_CTRL-Y).  However, sometimes this is not very useful when a user wants to insert many characters.  In this case it's better to get a *word* above cursor.

Put this in ~/.vimrc:

" Wordwise Ctrl-Y in insert mode
noremap! <C-Y> <Esc>klyWjpa

You might want to substitute 'W' with 'w', 'E', or 'e'.  Try them and choose one that works best for you.

Unfortunately, this simple map doesn't work at the beginning or end of line.  Improvements are welcome.







VimTip	{{{1 429: Using '< and '> marks



Today I discovered that '< and '> persists even after the selection is gone.
Thus, to repeat an Ex command over a previously selected (via V command) block
just use : history -- no need to reselect block again.






VimTip	{{{1 430: Fast switching between buffers


This is one for Tab key fans. I use these mapping to quickly cycle between buffers using Tab and 
Shift-Tab. I use them in normal more as I use tab for word completion when in editing more. Put these in your
.vimrc or gvimrc. The buffer will be written before switching to the next one. The test makes sure that the file can be written to and is modified.

nmap <tab> :if &modifiable && !&readonly && &modified <cr> :w<cr> :endif<cr> :bn<cr>
nmap <s-tab> :if &modifiable && !&readonly && &modified <cr> :w<cr> :endif<cr> :bp<cr>








VimTip	{{{1 431: 
map to toggle between backslash and forwardslash



Microsoft is backward, ie, using C:\Progra~1\Outloo~1\
To get it back forward, we can do
:s#\\#/#g<CR>
Now, life turns back to normal: C:/Progra~1/Outloo~1/
However, to copy and paste this normal path to Windows' applications,
we have to substitute slash to backslash:
:s#/#\\#g<CR>

Here came a small map to toggle between "/" and "\" within one line.

Usage:

Put the cursor on "/", and type v\, all "/" becomes "\".
Put the cursor on "\", and type v\, all "\" becomes "/".

Map:

vn <silent><Bslash> y:let c=getline(line("."))[col(".")-1]
   \<CR>:if(c=='/')<Bar>s#/#\\<CR><Bar>elseif(c=='\\')
   \<Bar>s#\\\\#/<CR><Bar>endif<CR>`<







VimTip	{{{1 432: Putting the current file on the Windows clipboard


Sometimes I want to use the file I'm editing in Vim (on Windows) in another application; I created the following command:

com! Copyfile let @*=substitute(expand("%:p"), '/', '\\', 'g')

This simply copies the entire path and filename of the current file -- substituting backslashes for slashes (in case there are any) -- onto the Windows clipboard.  I can then just go and paste the value wherever I want (such as a File -> Open dialog).

For example, for my _vimrc file, I get c:\vim\_vimrc in the clipboard.






VimTip	{{{1 433: a rough mapping to spellcheck the buffer


well, certainly

well, certainly there are plugins to do this much better, but, if you 
like to have most of the stuff placed on your vimrc file, the
following must help:
 
 map ,SS :exec system("ispell -l -t -d br < ".expand("%")." \| sort -u \| sed 's/\\(.*\\)/syntax match Underlined \"\\\\<\\1\\\\>\" contains=TOP /'")
 
basically, i use 'ispell' to collect all misspelled words, and assign
each one to the 'Underlined' syntax group (seems better than 'Error')
=]

improvements aren't so hard to do; actually, I use another mappings 
for another 'spell' functions, but the essential can fit in just one 
line;

leorosa







VimTip	{{{1 434: Autogroup commands for C/C++ editing - inserting skeletons etc (long post!)


Hi all,

When you start editing a *.h file, you'd need some format like this:
CODE STARTS:
/*****************************************************************
* Filename: abc.h
* Description: 
* Created: Mar 5 03 09:00:00
* Last modified: Mar 6 03 09:00:00
* <some more stuff like author, copyright, blah-blah>
*
* Revision History
*   Date                  Author            Remarks
*   Mar 5 2003         KG                 File Created
*******************************************************************/
#ifndef _ABC_H_
#define _ABC_H_

#endif
// vim:ts=3:sw=3:ft=c
CODE ENDS
I wanted my gvim to do the following things at various stages of editing a abc.h file:
1. Upon opening a new file, insert the skeleton like the one above, and leave me in insert mode after "Description"
2. When writing a file, update the "Last Modified" timestamp
3. On opening a existing file, modify the "Revision History" to add a new line, and leave me in insert mode below "Remarks"

The following autogroup (:help au) commands let you do these (put these in your .vimrc):
CODE STARTS:
if !exists("autocommands_loaded")
  let autocommands_loaded = 1
  au BufNewFile *.h call InsertCHHeader()
  au BufWrite *.h call ModifyTime()
  " You might want to comment-out the line below - see note 6 at the end of the post.
  au BufReadPost *.h call ModifyHeader()
endif

function! InsertCHHeader()
   call InsertSkeleton("skeleton.h")  " CHANGE this!
   call InsertFname()
   1
   " Search for Description
   call search("Description:")
   normal $
   startinsert
endfunction

function! InsertSkeleton(fname)
   let path_to_skeletons = $HOME . "/etc/skeletons/"  " CHANGE this!
   " Save cpoptions
   let cpoptions = &cpoptions
   " Remove the 'a' option - prevents the name of the
   " alternate file being overwritten with a :read command
   exe "set cpoptions=" . substitute(cpoptions, "a", "", "g")
   exe "read " . path_to_skeletons . a:fname
   " Restore cpoptions
   exe "set cpoptions=" . cpoptions
   " Delete the first line into the black-hole register
   1, 1 delete _
   " Search for Filename:
   call search("Filename:")
   exe "normal A " . expand("%:t")
   " Search for Created:
   let current_time = strftime("%b %d %Y %T") "CHANGE this!
   call search("Created:")
   exe "normal A " . current_time
   " Search for Last modified:
   call search("Last modified:")
   exe "normal A " . current_time

   " Search for Date
   let date_line_no = search("Date")
   let rev_history = getline(line("."))
   let rev_history = substitute(rev_history, "Date       ", strftime("%b %d %Y"), "")  " CHANGE this!
   let rev_history = substitute(rev_history, "Author", "KG    ", "")  "CHANGE this!
   let rev_history = substitute(rev_history, "Remarks", "File created.", "")
   call append(date_line_no, rev_history)
endfunction

function! InsertFname()
   " Convert newname.h to _NEWNAME_H_
   let fname = expand("%:t")
   let fname = toupper(fname)
   let fname = substitute(fname, "\\.", "_", "g")
   " Search for #ifndef
   call search("#ifndef")
   exe "normal A " . "_" . fname . "_"
   " Search for #define
   call search("#define")
   exe "normal A " . "_" . fname . "_"
endfunction

function! ModifyHeader()
   " Modify header only if we have write permissions
   if &readonly == 0
      " Search for Date
      let date_line_no = search("Date")
      if date_line_no != 0
         let rev_history = getline(line("."))
         " Substitute Date, and Author fields
         let rev_history = substitute(rev_history, "Date       ", strftime("%b %d %Y"), "")  " CHANGE this!
         let rev_history = substitute(rev_history, "Author", "KG    ", "")  " CHANGE this!
         let rev_history = substitute(rev_history, "Remarks", "", "")
         " echo "Modified = " . rev_history
         call append(date_line_no, rev_history)
         normal j$
         startinsert
      endif
   endif
endfunction

function! ModifyTime()
   " Do the updation only if the current buffer is modified
   if &modified == 1
      let current_time = strftime("%b %d %Y %X")  " CHANGE this!
      " Save current position at mark i
      normal mi
      " Search for Last modified:
      let modified_line_no = search("Last modified:")
      if modified_line_no != 0 && modified_line_no < 10
         " There is a match in first 10 lines
         " Go to the : in modified:
         exe "normal f:2l" . strlen(current_time) . "s" . current_time
         echo "Modified date stamp to " . current_time
         sleep 500m
         " Restore position
         normal `i
      endif
   endif
endfunction
CODE ENDS

Notes:
1. The strftime( ) function is not-portable. You might need to change the format specifier for your system
2. The autogroup commands assumes that there is a file called skeleton.h at the location ~/etc/skeletons.
    You might have to modify the path and file name. In my case, the skeleton.h file looks like:
   /******************************************************************************
    *  Filename:
    *  Description: 
    *
    *  Version: 1.0
    *  Created:
    *  Last modified:
    *  Revision: None
    *
    *  Author:    Karthick Gururaj
    *  Company: [Removed]
    *  e-mail: [Removed]
    *
    *  Revision history
    *  Date           Author       Remarks
    *
    ******************************************************************************/
   #ifndef
   #define
   
   #endif
   // vim:sw=3:ts=3
Search the script for the pattern "CHANGE" to see where you might have to make changes..
3. I have not tried to make the script super-portable (that looks obvious eh?). The reasoning is, any changes are a one time effort.
4. The scripts don't modify search history or register values. I have used one letter for marking thou'
5. If you open a new header file, and quit it without writing, no file is created.
6. I found having an autogroup command for modifing the revision history everytime the file is opened to be irritating. So I have disabled this in my system. Note on note: I also had some problems when trying to open the file thro' the quickfix window.
7. You can define more such skeletons for other extentions.
8. Feedback is welcome!

Cheers!






VimTip	{{{1 435: remarks to script c.vim : statement oriented editing of  C / C++ programs


Seems to be a nice, powerful addition for C-programmers.

The screenshots show a really dangerous C++ trap:
     NEVER add C++ comments after a '#define' statement !
The Preprocessor will substitute the defined text literally,
so all of your code behind the defined text will be commented out.

I used abbreviations for C-constructs like 'cfor' for empty for loops, 'cif' for if then elses, etc., 
so typing in insert mode has not to be interupted. The cursor will be positioned for entering the following code.

Another thing is standard C-comments for file/function headers. I used a command line tool (perl script)
to get a personalized version from a standard template and read in the output with ':r !<mytool> <options>'.
This is a solution for workgroups where no one HAS to use VIM.
I had autocommands for automatically read in the comment headers when opening new header or source files.


Thomas







VimTip	{{{1 436: Accidently typed control-u and lost your input?


If you've accidently typed control-U to delete a line then accidently typed ESC straight after that because you've been using web forms and ESC in IE forms is like undo and basically you really didn't want to do that then you should do this:

:let @a = @.
"aP

The . register is basically everything you've just typed in input mode including the control-U.  When you paste this buffer it acts like you're typing it again and deletes the line.  You need to reassign it to another register with the let command before you can paste it properly and get at your nice input.






VimTip	{{{1 437: extending keywords


sometime when you are working with an extended language (such as uC++) there exist
keywords that are not included as keywords in the vim release, so you can easily update
keywords in two ways.

1. edit your c.vim file [if you are coding c/c++] try 'vim61/runtime/syntax/' for location of these files,
    and add the keywords in the correct groups,

2. the second way is you can put them all in a separate file, and source it, eg:
   say i had some new c types, called uTask or uMutex i could get them highlighted as types
   using the following command:
	:syn keyword type uTask uMutex uNoMutex [etc..]

enjoy.
.. hzp.






VimTip	{{{1 438: Search/replace "within selection" in gvim using '< '>


In other editors I've always used the search/replace "within selection" features a lot but never knew how to do that in gvim. I finally found the '< and '> marks 

'< goes to the start of the last graphical selection (in gvim) 
'> goes to the end of the last graphical selection

so you can use these to simulate the search "within selection" option that other programs have. eg:

:'<,'>s/fred/joe/g

will replace fred with joe in the last graphical selection






VimTip	{{{1 439: Replace text in highlighted search


you can search for text and highlight it, using  /pattern
usually you want to replace the exact found occourences with another string, because the common trick to e.g. repeadetly pressing:
1. cw = change till end of word, or ct(  = change till first occourence of character ( 
2. n = next found pattern
3. . = do command 1. again
3. goto 2.
is too cumbersome, besides, you already specified what you want to replace with /pattern.

solution:

use c//e as 1. (it replaces till end of highlight).
you will NEED to bind:
nnoremap n //<CR>
nnoremap N ??<CR>
in your vimrc, or step 2. will end up with the cursorposition on the last character of your match, because it will remember the pseudo-search-command in step 1.








VimTip	{{{1 440: Automatic formatting of paragraphs


When I use Vim to create plain-text files (like mail 
messages) I like the feature that automatically makes lines 
XY characters long. I simply type ':set tw=60' on the 
command line, and as I type lines are broken (autorwapped) 
before they reach 60 characters length.  The problem is, 
when I latter decide to edit the paragraph. When I delete or 
add some words, the paragraph looks broken.

The solution is to type '<Esc>gqap' to format a paragraph  or 
make a mapping for this command. However, it annoys me to do 
it repeatedly.


There is a better solution.

1. Go to http://cream.sourceforge.net/vim.html
and download the latest patched Vim

2. Install the program.

3. See :help auto-format. 

I will not repeat the docs here. For the impatient, set 
fotmatoptions to aw2tq ':set fo=aw2tq' and start typing.
The text flows automagically between lines as you type
text inside the paragraph.
GREAT!!!






VimTip	{{{1 441: Toggle auto-wrap using txtwidth in INSERT mode




In INSERT mode, I would like to 

1. keep tying without auto-wrap (good for editing vimrc and c)
2. wrap long line at will (good for email and text)

Following is the map I figured out, using <C-B> in this example:

set sr fo=roqm1 tw=64
im <C-B> <C-O>:setl sr! fo<C-R>=strpart("-+",&sr,1)<CR>=tc<CR>_<BS><Right>

By default, it goes without auto-wrap. If I want, I can type
<C-B> to triggle auto-wrap. Another <C-B> toggles back.

Basically it toggles two settings:

a) :set fo+=tc<CR>
b) :set fo-=tc<CR>

strpart() is used for toggling; "sr" is choosing for no good
reason; "_" can be any char; <BS><Right> is needed to *triggle"
this action.

It works for me on W2K. Please tell me if you have better ideas
to get this job done. 

Note:  We may use 'linebreak', but that still leaves a really
long line. I would like to keep my &tw.

Thanks









VimTip	{{{1 442: Show all lines that contain keyword under cursor


Started finding this one pretty useful.

If you want to view a list of all the lines in the current buffer that contain a word, place your cursor over the word and press [I

Handy to see where you last used variables, functions, etc.






VimTip	{{{1 443: A better interfacing of (La)TeX with the quickfix mode


VIM's quickfix mode is a very nice feature. Nevertheless, I was not
completely satisfied when I used it together with (La)TeX. Here are the
main reasons:

* The default error format pattern is able to extract the line number
  and the error message, but not the column number.

* This pattern is of course unable to deal with BibTeX's or MakeIndex's
  error messages.

* TeX's messages are quite verbose. Having them displayed at each run,
  even when no error occurs is sometimes annoying.

Thus I implemented TeXwrapper, a small program which silently runs TeX
and optionally some associated tool like BibTeX, MakeIndex, eukleides or
Dvips. When an error occurs, TeXwrapper scans the transcript files and
prints to stderr "compiler style" error messages, i.e.:

		<filename>:<line>:<column>:<message>

This allows very simple settings on VIM's side, that is:

	set makeprg=texwrapper
	set errorformat=%f:%l:%c:%m

Someone writing an article with LaTeX containing cross references and a
bibliography may then use: "make -lb2 %". Option -l stands for "run
LaTeX" (instead of TeX), -b for "run BibTeX", -2 for "run twice" (to get
correct cross references).

Another feature is the --window option (short: -w). When something goes
wrong, a GTK+ window pops up, displaying a summary of the encountered
errors. Hence, one may use: "silent make -w %" which enables to avoid
the "Hit ENTER or type command to continue" message at each run.

TeXwrapper has been developed on a GNU/Linux system, but it should build
on any system where flex has been ported. The pop up window is opened by
a separate program, named texwrapper_window, which of course requires
the GTK+ library. 

TeXwrapper has been released under the GPL and is available at:

	http://perso.wanadoo.fr/obrecht/texwrapper

Happy Vimming & TeXing!
Christian Obrecht






VimTip	{{{1 444: quickfix show entire contents of multiline error in cwindow on cn, cp and cc


put this in your .vimrc if you use the cwindow

" \cc
map <Leader>cc :cwindow<cr>:cc<cr><c-w>b<cr>
" \cn
map <Leader>cn :cwindow<cr>:cn<cr><c-w>b<cr>
" \cp
map <Leader>cp :cwindow<cr>:cp<cr><c-w>b<cr>

and when you use \cc (or whatever your leader character is + cc), \cn or \cp, it will do what :cc, :cn and :cp usually did, with the added bonus of showing the entire contents of multiline errors.  this is especially useful for javac via ant, and it's obnoxious to keep typing <c-w>b<cr> every time i do a :cn, so i mapped this.

detailed explaination:
":cwindow<cr>" ensures that the quickfix window is show.
":cc" (:cn, and :cp) actually do the operation
"<c-w>b" go to the bottom window (which cwindow will be if it's shown) which will magically center on the error
"<cr>" carriage-return on the error line, taking you back to the code with the error

i know it probably seems superfluous if you haven't been personally affected by this particular annoyance.
thanks to freenode #vim for inspiration.






VimTip	{{{1 445: Formatting stuff


Hello all, Im new to VIM, but I wanted to post some of my ideas for everyone here. Mark T, a friend of mine, just reciently got me in to VIM and I havent looked back yet! I really like this program, and I feel it's a valuable tool. 

Mark and I program in Lisp and Visual lisp for AutoCAD. (Its a program for drafting) and I have been adding stuff to my 'rc' file for lisp programing for abbout a month now. Mark has convinced me to post some tips here. So here they are: 

**********************************************************************
imap <Backspace> <left><del>
" this will allow me to always use the backspace key in insert mode

imap <C-j> <Esc>Ji
" this will allow me to join a line while still in insert mode

map .f v%zf
" fold an entire block of code

nnmap ,y <S-v>y
" This will select a whole line of text or it will select 
" everything in a fold.

map .; v%:s/^/;;;/<CR>:noh<CR>
" comments out and entire block of code from paren to paren

:au BufRead *.lsp :loadview 1<cr>
:au BufRead *.LSP :loadview 1<cr>
" load the first fold view file for the current file

map st :set tw=70<cr>v<S-}>gq<End>
" this will allow you to format an entire block of text
**********************************************************************

John






VimTip	{{{1 446: Quick and dirty Postgres query


Here is a simple and usefull mapping for anyone who can't stand developing queries on the psql prompt or messing around with the single \e psql edit buffer. 

map <F9> :!psql -d yourdb < % <BAR> less






VimTip	{{{1 447: Use the upper-lower case ~, also on Windows (ita)


For who know to change the case of key typed, otherwise see before the Tip #49 :^)

I had find usefull use ~ ( on linux :^) to change the case of word, but  also a my friend want this option on windows.
So i told him to use the ~ for this.
But italian keyboard have not the ~ on board.
So i have mapped this to a key, let read the code:

map <the key that you want> ~

Thats all.

I have used this on windows and italian keyboard, but i believe that is possible also on other keyboard yhat not have the tilde like us-keyboard.

NOTE:
Make attention to key that you use for mapping ~, some key ar used by vim, so for this don't work.

Have a nice day :^)









VimTip	{{{1 448: Yank (copy) decimal numbers from hex numbers.


Here is a mapping that will copy a hexadecimal number in a register after converting it to the decimal equivalent.  The tip is pretty useful if you are a programmer.

:map \y g*<esc>:let @*=@/ + 0<enter> 

Usage: 
1.  Place the cursor on any hexadecimal number (eg 0xff, 0xfefe, 0x3434) and press \y.  
2.  Place the cursor at the location where you want to paste the number in decimal and press "*p
3.  The number is also copied to the clipboard (windows) so you can paste it in other applications.

Example:
If the hexadecimal number is 0xff, then 255 will be copied to the clipboard.

Configuring the tip.
If you do not like the above key combinations or the register being used, you can configure the tip to use other mappings as explained below:
1.  Change \y in the above mapping to any key combination of your choice.
2.  Change @* to @<any_other_lower_case_letter> to copy the contents to another register.  If you do this, pasting will require the command "<that_same_lower_case_letter>p

Side effects:
1.  The tip uses the search register for the conversion.  Therefore any last search will be lost.  
2.  The tip also uses a register to yank the result.  The earlier contents of that register (in our case the * register) will be lost.  

-mohit








VimTip	{{{1 449: FORTRAN highlighting problems


Sometimes the FORTRAN syntax file doesn't set the correct source form. 

So if you want to choose it by yourself, add the following line in your vimrc file:

au BufNew *.for let b:fortran_fixed_source=1    " set the correct value

The other way to do this is to change the file extension (F77/F90/F95), but it might be a long and/or hazardous work for big projects...







VimTip	{{{1 450: Working with multiple sessions


The problem I'm trying to solve:
I usually need to work on different projects (let us call them: PROJ1 and PROJ2). These are in different directories, have 
different files.. etc. It would be nice if I can instruct my editor to take me back to the exact session (see :help sessions)
for each of these projects - open the required files and buffers, window layout etc...

Solution
1. Append the following code to your .vimrc
    - Change the variable g:PathToSessions to your desired place, if needed (make sure that this directory exists and is writable)
2. Open all/some files in a particular project (as if you are working on that) in gvim. Say I open all my PROJ1 related files.
    You can split windows etc.. and make it look as if you are really working! :-) Do a 

    :SetSession PROJ1

3. Quit gvim
4. Restart gvim without any filenames at the command line.
5. You ought to get a popup-entry asking you which session to restore. Choose PROJ1.vim to see the effect.
6. Repeat with other projects.

Note:
1. You don't have to :SetSession everytime you open gvim as in step 5. Only once.
2. If you start vim with no files at the command line, you have an option of going back to the last saved session (this
    is available in the gui if you choose LastSession.vim)

CODE STARTS
au VimLeave * call VimLeave()
au VimEnter * call VimEnter()

let g:PathToSessions = $HOME . "/.vim/sessions/"

function! VimEnter()
   if argc() == 0
      " gvim started with no files
      if has("browse") == 1
         let g:SessionFileName = browse(0, "Select Session", g:PathToSessions, g:PathToSessions . "LastSession.vim")
         if g:SessionFileName != ""
            exe "source " . g:SessionFileName
         endif
      else
         " For non-gui vim
         let LoadLastSession = confirm("Restore last session?", "&Yes\n&No")
         if LoadLastSession == 1
            exe "source " . g:PathToSessions . "LastSession.vim"
         endif
      endif
   endif
endfunction

function! VimLeave()
   exe "mksession! " . g:PathToSessions . "LastSession.vim"
   if exists("g:SessionFileName") == 1
      if g:SessionFileName != ""
         exe "mksession! " . g:SessionFileName
      endif
   endif
endfunction

" A command for setting the session name
com -nargs=1 SetSession :let g:SessionFileName = g:PathToSessions . <args> . ".vim"
" .. and a command to unset it
com -nargs=0 UnsetSession :let g:SessionFileName = ""
CODE ENDS






VimTip	{{{1 451: KDE Konsole renameSession to edited file name


In Kde the renameSession will set the Konsole name. Add this to your
.vimrc file to name the session after the edited file.

autocmd BufReadPost * :silent !dcop $KONSOLE_DCOP_SESSION renameSession %







VimTip	{{{1 452: Unix: Editing multiple files, listed in a file, one per line, from the command-line


I needed to edit about 300 files in a directory tree that all contained a specific line.  I used -w {scriptout} on the first file to write my macro, and then used this command line to execute the rest:

     vim -s scriptin `cat file-containing-files`

This cats the file containing the multiple files, one per line, to the command line, allowing you to edit tens, hundreds or even thousands of files using the same script.  Of course, I had to use a recursive macro to get it done.  Here's what I used:

     qq/\.\.\.\.\.\.Complete^Mdd:wn^M^M@qq@q

Basically recording the macro, searching for my string, deleting that line, writing the file and going to the next, then executing itself (@q), ending the macro and then executing itself.  This way one script could be used to edit all 300 of my files.






VimTip	{{{1 453: Use Taglist with LaTeX files


First, you have to add a new language to ctags
in ~/.ctags add : 
<.ctags>
--langdef=tex
--langmap=tex:.tex
--regex-tex=/\\subsubsection[ \t]*\*?\{[ \t]*([^}]*)\}/- \1/s,subsubsection/
--regex-tex=/\\subsection[ \t]*\*?\{[ \t]*([^}]*)\}/+\1/s,subsection/
--regex-tex=/\\section[ \t]*\*?\{[ \t]*([^}]*)\}/\1/s,section/
--regex-tex=/\\chapter[ \t]*\*?\{[ \t]*([^}]*)\}/\1/c,chapter/
--regex-tex=/\\label[ \t]*\*?\{[ \t]*([^}]*)\}/\1/l,label/
--regex-tex=/\\ref[ \t]*\*?\{[ \t]*([^}]*)\}/\1/r,ref/
</.ctags>

I think this good for me but if someone found something better, i will be happy :)

Edit taglist.vim (my patch for version 2.4) : 
--- taglist.vim 2003-04-14 16:47:25.000000000 +0200
+++ .vim/plugin/taglist.vim     2003-04-14 15:00:04.000000000 +0200
@@ -509,6 +509,9 @@
 " vim language
 let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
 
+" tex language
+let s:tlist_def_tex_settings = 'tex;s:section;c:chapter;l:label;r:ref'
+
 " yacc language
 let s:tlist_def_yacc_settings = 'yacc;l:label'

in vim, type : 
:Tlist

or see taglist doc

references : 
Taglist : http://www.vim.org/scripts/script.php?script_id=273
ctags : http://ctags.sourceforge.net
Vim-LaTeX : http://vim-latex.sf.net/






VimTip	{{{1 454: Syntax Highlighting Keeps Breaking (and how to fix it!)


If you vim syntax highlight keeps breaking as you move around your document this is the tip for you!   :) 

First of all, how to fix it:
    put the following in your .vimrc (_vimrc on windows):
        "autocmd BufEnter * :syntax sync fromstart"

now, you might say, "Robert, I already put 'syntax sync fromstart' in my .vimrc, and it doesn't work!" -- and in saying that, you would be correct, because of a few factors coming together to cause you pain. 

Factors:
    1. Vim syntax files should define the best syntax sync method for that langauge
    2. Many vim syntax files do not do #1
    3. Almost all syntax files do a :syntax clear which removes _your_ sync setting

Notes:
    The syntax files that tend to have the most trouble keeping sane highlighting are multilangauge files (html/javascript -- html/php/javascript ...), yet the all work perfectly with :syntax sync fromstart.  This is not a vim bug, but a problem with the syntax files, yet, it has been argued that maybe vim should NOT clear out the sync setting when doing a syntax clear -- and just wait for it to be overwritten... like everything else -- that is debatable  :)  

Hope this helps you... join #vim on irc.freenode.net for all your vim help needs :) 






VimTip	{{{1 455: Map a function key to toggle line wrapping


Most of the time I want to have line wrapping on. But, there are some times that I want to toggle it off, to check structures or something... here's a function key for toggling line wrapping:

:set wrap
:let g:toggleWrap = 0
map <silent> <F6> :if g:toggleWrap == 1<CR>:set wrap<CR>:let g:toggleWrap = 0<CR>:else<CR>:set nowrap<CR>:let g:toggleWrap = 1<CR>:endif<CR>

Tom.







VimTip	{{{1 456: escape  select mode in a map command (used to map indent in select mode)


When using mswin behaviour, the select mode is activated each time you select some text with shit+arrows or with the mouse. Then entering '>' to ident the text will just replace selected text with >. To offer a behaviour similar to visual text editor, I use the following mappings :

vmap    <Tab>         ^0   >
vmap    <S-Tab>     ^0   <


then in select mode, tab will go to to visual mode, shift one block  and then return to select mode ! Shit-Tab will just do the same thing, going backward.






VimTip	{{{1 457: Follow tag in new window


If you use tags, you might want to follow a tag, but leave the current window open.  The following mapping allows you to do this easily with Ctrl-\.
:map <C-\> :sp<CR><C-]><C-w>_







VimTip	{{{1 458: How to use quickfix mode to see all errors in one window (:cwindow).


Uptil vim 5.8, I was using the cfile, clist...etc for quickfix mode.
In vim6.x, I found out that :cw will boost my productivity as  a programmer.

To make,
type :make as we do in older versions of vim (<6.0).
Instead of clist,cfile...etc, type
:cw<enter>
you get one split window, in which errors are listsed. Current error line will be highlighted and cursor will move to the corresponding source file line.
Doing an <enter> on any error line in the error window will take the cursor to the corresponding source line.
This eliminates the need for the process described in vimtip #345.(Now you can get rid of Visual studio altogether !)

Details:
Help is available in vim 6.x onwards by entering :help cw







VimTip	{{{1 459: Use Ctrl-O instead of Esc in insert mode mappings


Theory: Ctrl-O in insert mode switches to normal mode for one command and then switches back to insert mode.

Practice: Mappings like

:imap <f5> <esc>:set number!<cr>a

move the cursor one character right when it's in the first column. Use

:imap <f5> <c-o>:set number!<cr>

instead, it has no side-effects. If you have <f5> mapped in normal mode too (to do the same thing),

:imap <f5> <c-o><f5>

is even better.

When you need to do more than one thing in the mapping, you can
- use more Ctrl-O, one before each command, or
- use | to run more commands at once, or
- define a command (or function) doing everything and map <f5> to it.
- ... (TMTOWTDI)






VimTip	{{{1 460: how to implement vertical lines showing tab groups..


When browsing the jEdit screenshots page, I saw a feature I wanted and didn't have in vim.  It was a vertical line showing tab groups.   

if (this) {
|   if (that) {
|   |   do stuff;
|   }
}

http://www.jedit.org/index.php?page=screenshot&image=10 <-- show a much better example that my little example did... 

I was wondering how todo this in vim.. turns out it is simple
    :set list
    :set listchars=tab:\|\ 

    :h listchars for help


Hope this helps you... join #vim on irc.freenode.net for all your vim help needs :)






VimTip	{{{1 461: Open a Perl module based on it's module name


This may be of interest to Perl programmers using vim. Sometimes I want to open up the source code of a system Perl module that's installed. Here's one way to do that:

:e `perldoc -l Module::Name`

I find that useful. 








VimTip	{{{1 462: G's of Vim


Hi Guys !!

You can play with THE "g" in VIM editor.

Try this

Place the cursor on any variable in your program.

gd          will take you to the local declaration
gD          will take you to the global declaration.
g*           search for the word under the cursor. It's just like * but don't put < or > around words
              so here you can search word which contains word under your cursor
              Confused ???? try it NOW :-)
g#           same as g* but in backward direction

Now time for gssssss
 
ggdG       takes out all your hard work ;-) I mean deletes the content of the file ..

Happy viming ...








VimTip	{{{1 463: XSLT Mappings I use to speed up developing XSLT files.


I recently added these mapping to speed up typing XSLT elements. As this is my first tip, I hope these might be useful to someone else. I added these mappings to my copy of Devin Weaver's xmledit script.

imap <Leader>pi <?xml version="1.0" ?>^M
imap <Leader>ap <xsl:apply-templates/>
imap <Leader>ap`s <xsl:apply-templates select=""/>^[F"i
imap <Leader>ap`sm <xsl:apply-templates select="" mode=""/>^[3F"i
imap <Leader>at <xsl:attribute name="">^[F"i
imap <Leader>el <xsl:element name="">^[F"i
imap <Leader>if <xsl:if test="">>^[kf"a
imap <Leader>im <xsl:import href=""/>^[F"i
imap <Leader>in <xsl:include href=""/>^[F"i
imap <Leader>ou <xsl:output method=""/>^[F"i
imap <Leader>pa <xsl:param name=""/>^[F"i
imap <Leader>pa`ns <xsl:param name="" select=""/>^[3F"i
imap <Leader>st <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">>
imap <Leader>te <xsl:template match="">>^[kf"a
imap <Leader>te`n <xsl:template name="">>^[kf"a
imap <Leader>te`mm <xsl:template match="" mode="">>^[kf"a
imap <Leader>va <xsl:value-of select=""/>^[F"i
imap <Leader>wi <xsl:with-param name=""/>^[F"i
imap <Leader>wi`ns <xsl:with-param name="" select=""/>^[3F"

For more information:
vimscript #301
help: imap






VimTip	{{{1 464: search & replace the word under the cursor


I have this usefull mapping in my vimrc:

nmap ; :%s/\<<c-r>=expand("<cword>")<cr>\>/

Now, if you see a word 'foo' which should be replaced, you only have to put the cursor on it and type ';'.
Then the command-prompt has already the annoying :%s/\<foo\>/ and you just have to enter your new word.

For information:

:help <c-r>
:help expand







VimTip	{{{1 465: generic xml imap to make an element of any word you type


Hi all.

We're doing a lot of xml work, in docbook and custom xml files.  

I'd just like to share one macro I've developed, that I really can't live without.

imap ,,, <esc>bdwa<<esc>pa><cr></<esc>pa><esc>kA

If in isert mode I type programlisting,,,
the text immediately get's modified to 
<programlisting>
</programlisting>
with the cursor in between, still in Insert mode.

The same happens with any other word i type followed by three commas. 
<tryit>
</tryit>

It saves me a lot of work, and I'd like to share it. Hope you can use it

Bart van Deenen. (bart@vandeenensupport.com)






VimTip	{{{1 466: Insert one character only


I have not yet seen this idea yet.  But early in my use and love of Vim, I got frustrated in command mode when I wanted to insert just one character of text.  So I put this in _vimrc:

"insert one character
noremap <somekey>  i<Space><Esc>r

I think it has been one of the most time saving mappings -- and I have remapped most of my keyboard.






VimTip	{{{1 467: vim windows displaying output inside vim window


In vim for *nix or cygwin, the command

:!cmd

displays the output inside vim windows,
but for vim windows, the output is displayed in the console window.
To make the output displayed inside vim or gvim window, 
can use 

:echo system("command")

references:
:help system()
:help echo






VimTip	{{{1 468: display date-and-time on status line


It didn't seem like an existing tip mentioned this, so:

The following lines in .vimrc or a plugin file will display 
the time of day and calender date (some of us need that reminder)
on the editor status line:

set ruler
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M\ %p')}\ %5l,%-6(%c%V%)\ %P%)

It doesn't update time if you issue no keystrokes, but as soon as you
do anything at all in the editor, you will get the current time.






VimTip	{{{1 469: The use of  %< instead of %


This tips is for vim or gvim user. We know the following map

map! /' ^[:w^M:! latex %^Mi

is doing the following. By typing "/'" in insert mode, this
will save the current tex file, and compile it. 
The reader understand that one can change "/'" by anything he want,
as long as it does not bug its own configuration, I like this map 'cause 
on an english keyboard both / and  ' are close to eachother.

We may wonder
what to do if we wish to open the associated dvi file?!
Indeed one has to replace % by %<.dvi and then we get

map! <F4> ^[:! xdvi %<.dvi ^Mi
or 
map! <F4> ^[:! kdvi %<.dvi ^M
if you are using K environement.

The same thing apply indeed for any other extension i.e., 
the map
map! <F5> ^[:! gv %<.ps ^Mi
will open the associated ps file with gv.







VimTip	{{{1 470: Map to quickly swap/exchange arbitrary text


When editing text, it's not uncommon to need to swap two bits of text.  In
Vim, it's easy to swap adjacent characters, words and lines (see vimtip #47),
but to swap non-adjacent text (such as comma-separated words, variable
assignments, and function parameters), you usually have to resort to a tedious
delete/move/put/delete/move/put sequence.

Mappings such as the one in vimtip #329 can help in some cases, but for a more
general solution, try this mapping:

	vnoremap <C-X> <Esc>`.``gvP``P

To use it:  First, delete some text (using any normal Vim command, such as
daw, {Visual}x, or dt,).  Then, visually select some other text, and press
CTRL-X.  The two pieces of text should now be swapped.

For example, to swap "apple" and "orange" in the line below:

        int apple, lemon, orange;

1. Delete "apple", using (for example) diw or <double-click>d
2. Visually select "orange"
3. Press CTRL-X

The mapping is not limited to single words, though, and will work with
anything you can delete/select (even lines and blockwise selections).







VimTip	{{{1 471: Bridging the worlds: putting your rodent to work for vim in xterms


If, like me, you don't want to use the GUI vim because you work in an xterm most of the time anyway, you may be annoyed at the shortcomings this presents. For example, during my webbrowsing, I'll often fire up vim in one of the already lying around xterms to conveniently write a long text (such as this one), and then paste from vim into a textfield on a HTML form in the browser.

The first problem is caused by line numbering, which I keep enabled at all times.

:set number
:help number

Normally, if you try to copy text out of the xterm that vim is running in, you'll get the text as well as the numbers. The GUI version gets this right: it only selects the text, keeping the line numbers out of the picture. But I don't want the GUI version. So instead, I added this to my vimrc:

:set mouse=a

Much better. You can also selectively enable mouse support for specific modes only by using something other than 'a' (for 'all').

:help mouse

Now although I'm more of a keyboarder, when I juggle text between X apps (or maybe between xterms), it's just more convenient and efficient to keep my hands on my mouse, since they're there anyway. Now, if you own a moderately recent model, you'll know this lovely little wheel they have (which usually also doubles as mouse button 2). Rolling it scrolls the window in GUI vim, which simplifies life when selecting several, distant passages to paste one after the other. But I don't want to use the GUI vim - you can imagine my delight when I ran across this in the vim documentation:

:help wheel

It involves adding a couple mappings to your vimrc and corresponding VT100 translations to your .Xresources file as a prerequisite. Don't forget

$ xrdb -load .Xresources

after you edit the file. The running xterm will not heed the changes; you need to open a new one to see the effect.

The wheel may not work with the mappings as described in the helpfile. They worked without a hitch for me at first (using Xfree 4.1 then), but broke after I upgraded my distro. Whether it was the switch to 4.3 on this binary has been built with different options, I don't know. At any rate, I had to experiment a bit with the list from

:help keycodes

After a bit of trial and error, I finally fixed them by substituting <xCSI> for <M-Esc>:

:map  <xCSI>[62~ <MouseDown>
" etc
" ...

Done. Load a large text file and marvel at mousewheel scrolling.






VimTip	{{{1 472: Handy option flag toggler


Here's a little function I put together to make some of my mappings easier to read, understand and change.

function ToggleFlag(option,flag)
    exec ('let lopt = &' . a:option)
    if lopt =~ (".*" . a:flag . ".*")
	exec ('set ' . a:option . '-=' . a:flag)
    else
	exec ('set ' . a:option . '+=' . a:flag)
    endif
endfunction

Examples of use:

map <silent> <F8> :call ToggleFlag("guioptions","m")<CR>
map <silent> <F9> :call ToggleFlag("guioptions","T")<CR>

Can anyone see anyway to improve it?
e.g. remove the leading exec... "if &{a:option}..." doesn't work.
e.g. a regex match doesn't seem the cleanest of checks, though I prefer it to setting a variable for each possible flag.






VimTip	{{{1 473: "compiler" for perl


At on stage I was writing a lot of perl scripts/modules with Vim and found it useful to be able
to run the perl syntax-checker (perl -c) from within Vim via the "make" function. To be able
to do this you'll need to add the following Module (VimCompile.pm) to your @INC 
---------------<cut here>---------------
#!/usr/bin/perl -w
#$Id: VimCompile.pm,v 1.2 2002/02/16 01:07:03 forkin Exp $
# reformat "perl -c" syntax-check error-/warning-messages for Vim
package VimCompile;

use strict;

sub _die {
    my ($msg)=@_;
    $msg=~s/^((.* at )((.*) line )([0-9]+)(\.|, near .*))$/$4:$5: $1/mg;
    die qq/$msg/;
}
sub _warn {
    my ($msg)=@_;
    $msg=~s/^((.* at )((.*) line )([0-9]+)(\.|, near .*))$/$4:$5: $1/mg;
    warn qq/$msg/;
}
$SIG{'__DIE__'}=\&_die;
$SIG{'__WARN__'}=\&_warn;
# return OK
1;
__END__
------------<cut here>---------------
This Module will reformat the warnings/errors so that Vim can parse them (to allow you to
jump to the location/source-code of the error). You will also need to deposit the following
(perl.vim) in your ~/.vim/runtime/compiler directory.
------------<cut here>---------------
" Vim compiler file
" Compiler:     perl (output of "die" massaged)
" Maintainer:   Chris Forkin, chris@forkin.com

if exists("current_compiler")
  finish
endif
let current_compiler = "perl"

" A workable errorformat for "perl -c"
setlocal errorformat=%f:%l:\ %m

" default make
setlocal makeprg=perl\ -MVimCompile\ -c\ %
------------<cut here>---------------







VimTip	{{{1 474: have . restore the cursor position a la emacs in viper mode


Before making the switch to vim, I spent time in limbo using EMACS in viper mode (which is EMACS with vi emulation).  Despite the vast improvements in most areas, there were a few things I missed from EMACS.  One thing I really missed was the behavior of the . command, which always restored the cursor position.

For example, let's say I had the following:

foo.some_method.each do { |x| puts x }
foo.some_other_method(Time.now)
foo.close()

and I wanted to change foo to bar.  I would always use a cw and then the . command:
cwbar<cr>j.j.

rather than making a substitute command which would make me worry about the range over which it should take place etc.

When making the switch to vim, I was disconcerted because after the first . my cursor was at the end of the second 'bar'.

In fact I pretty much always wanted this behavior from '.', so this mapping helped me out:

"make . not move the cursor
noremap . mz.`z 


I've since noticed this is just a special case of the tip *restore-position* in the help manual, but it took me a while to find out how to do this.  One other former emacs/viper user also was searching for this.  Hopefully this tip makes it easier for the next person to find who finally finds their way out of EMACS.







VimTip	{{{1 475: wrap visual selection with fold markers


Use this vmap to enclose a block with fold markers:

vmap    <leader>fold mz:<esc>'<O// {{{<esc>'>o// }}}<esc>`z?{{{<cr>A<space>






VimTip	{{{1 476: multime errorformat & makeprgs


I was fiddling around with the errorformat and makeprg opts, and as I code in different languages, i was wondering if there was a way of specifiing a special makeprg and errorformat parameter for each language.... and THERE IS!!

just edit the $VIM/ftplugin/[syntaxfile].vim

i.e.: perl.vim
added at the end :
set makeprg=$HOME/bin/vimparse.pl\ -c\ %\ $*
set errorformat=%f:%l:%m

c.vim
set makeprg=g++\ %

well, and you get the pattern.

It works delightfully with the :Make tip vimtip #203

Ah! I mapped F-5 to :Make, and made it go back to the main window:
map <F5> :Make<cr><C-w><Up>






VimTip	{{{1 477: How to put the indentation level on the status line


related to vimtip #303

in .vimrc

set statusline=<Whaterever your status is>\t%{ShowTab()}\ %P


fu ShowTab()
   let TabLevel = (indent('.') / &ts )
   if TabLevel == 0
      let TabLevel='*'
   endif
   return TabLevel
endf






VimTip	{{{1 478: Copy the search results into clipboard


" previous clear the clipboard with this command :normal "*y0
" Usage: :g/<pattern>/call CopyPattern()
function CopyPattern()
	let idx = 0
	let xEnd = 0

	while idx >= 0
		let @* = @* . matchstr(getline("."), '' . histget("/", -1), idx) . "\n"
		let xEnd = matchend(getline("."), '' . histget("/", -1), idx)
		let idx = match(getline("."), '' . histget("/", -1), xEnd)
	endwhile

	unlet idx
	unlet xEnd
endfunction






VimTip	{{{1 479: Replace with NO Typing


Often I replace one word with another.  This is much faster than the substitute command and requires no typing.

For example, to change badName(...) to goodName(...) (with the mappings below):

1.  Put the cursor anywhere on goodName and type:  gy

2.  Move the cursor to badName and type:  gp

That's it!

If there are more than one badNames, type *N before typing go, then n gp to change the next one.

I mapped go to put a space after the word, but someone clever might be able to combine them.


Here is how I mapped the commands:

"replace word with register b WITH SPACE AFTER word
noremap go lb"bPldwi <Esc>hbye

"replace word with reg b WITHOUT SPACE after word
"(lb so no move to previous word, but gives error at end of line)
noremap gp lb"bPldwhbyw

"copy this word to register b for replacing with go and gp
noremap gy lb"bye







VimTip	{{{1 480: editing files on an ftp server listening  on a non-standard port


Vim will edit files on an FTP server with the command:

e ftp://ftp.server/path/to/file/filename

But if you are using a virtual FTP server as in Bricolage to edit templates, the FTP server is listening on a non-standard port (typically 2121, but it can be something different).

In that case, the command would be

e ftp://ftp.server\#2121/path/to/file/filename. 

Note the "\#".  The standard syntax for specifying a port number is to append #2121 to the server name, where "2121" is the port to connect to. But Vim treats an unescaped "#2121" as an alternate file reference and fails with the message "No alternate file name to substitue for '#'".  Escaping the "#" causes Vim to treat is an another character in the string, and the connection works.

help edit and then search for "count" to find the syntax for editing alternate files


This works on Red Hat and on WindowsNT.









VimTip	{{{1 481: abbreviations only on shortcut


Actually, this is just a more flexible completion.

I made the following (example) to have a unique abbreviation:

  iabbrev date^A  <c-r>=strftime("%F")<cr>

Note that ^A is Control-A (insert with <c-v><c-a>).
This is to avoid the completion if you really want to write 'date'.

And now this mapping:

  inoremap <c-b> <c-v><c-a><c-[>a

Now type date<c-b> in insert-mode and you will get the date.







VimTip	{{{1 482: Use VIM as an organizer of Memos, bookmarks, todo, etc.


No one has perfect memory. I know this when I saw clever person often key in notes in his computer. 
He uses a number of small files with ".txt" extension and "grep" through them. To me this is not good
because you still need to give a different name to different things and as time goes by, you will useup
common words and starts "name1", "name2", ... to enumerate.

Have you ever thought of having one single Memo at hand that can put things down as normal
editor, still very easy to search and navigate through? HTML would be perfect for hypertext
navigation, but it is not as perfect for writting notes. Who knows what <H3> means level 3 headings
when i just want to use to highlight my text, ... A lot inconvenience.

I use VIM! For many years it helps me remember almost everything and still enjoy it. Let me share
the experience with you. Of course I expect you be a VIMMER as me first.

VIM as an organizing tool? The help system of VIM is so well organized that we can think 
of reusing the same for our everyday purpose. For example, here is my own Memo (abridged):
<<cut here>>
*memo.txt*      My Memo   - extending my poor memories                |guide|
-------------------------------------------------------------------------------------------------------------
*subjects*                                                                                     *toc*
|cmd|  command tips    |def|   definitions         
|dev|   developments     |ed|    editors              |friends|  friends
|lang|  languages          |misc|    others
|private|  personal info   |sys|   system  
-------------------------------------------------------------------------------------------------------------
Commands                                                               *cmd*
*General
        http://www.cslab.vt.edu/manuals
         ......
|doskey|    DOS key utility
        <F8>: expand history
|man|        Unix manual
                man foo
                nroff -man foo.1 | less
                nroff -man foo.1 | a2ps -m
|unix|
    http://gd.tuwien.ac.at/linuxcommand.org/
|winhelp|
.....
-------------------------------------------------------------------------------------------------------------
Development                                                        *develop*            *dev*
...
-------------------------------------------------------------------------------------------------------------
vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
<<cut here>>
Some explainations: 
1) The last line instructs VIM with a number of editing settings. The most
important one here is "ft=help", which says file-type is "help"! So the VIM
will highlight thing for us.
2) You can use *foo* to indicate an anchor to the "help" system of VIM. 
If you press Ctrl + ] on a word "foo", the cursor will jump to the first *foo*.
You can also see |foo| as a way to highlight it as implicit keywords.
3) This is not magic. The mechanism behind is the tag system. VIM needs 
to have the following tag file to go to where you want it to go:
===================================
%userprofile%   memo.txt   /*%userprofile%*
.htaccess   meo.txt   /*.htaccess*
access  memo.txt   /*access*
access.conf memo.txt   /*access.conf*
addressbook memo.txt   /*addressbook*
anchor_keyword  memo.txt   /*anchor_keyword*
apache  memo.txt   /*apache*
as  index.txt   /*as*
at  index.txt   /*at*
awk index.txt   /*awk*
===================================
Each line defines a tag, the first element is the keyword,
the second is the file where the tag belongs (yes, you can use
multiple files as long as you know what they are), and the last
element is the command which as VIM to perform at the keyword (you
can as well do something wield here, but that's your own business).
4) But that's tedious! How to write these tags? God save you and thanks
VIM, you can find this utility to do it:
    cc doctags.c -o doctags
    doctags memo.txt | sort -f | awk -f cases.awk >tags
    uniq -d -2 tags
------------------------------------------------------------------------------
<<cut here>> doctags.c

/* vim:set ts=4 sw=4:
 * this program makes a tags file for vim_ref.txt
 *
 * Usage: doctags vim_ref.txt vim_win.txt ... >tags
 *
 * A tag in this context is an identifier between stars, e.g. *c_files*
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define LINELEN 200

	int
main(argc, argv)
	int		argc;
	char	**argv;
{
	char	line[LINELEN];
	char	*p1, *p2;
	char	*p;
	FILE	*fd;

	if (argc <= 1)
	{
		fprintf(stderr, "Usage: doctags docfile ... >tags\n");
		exit(1);
	}
	printf("help-tags\ttags\t1\n");
	while (--argc > 0)
	{
		++argv;
		fd = fopen(argv[0], "r");
		if (fd == NULL)
		{
			fprintf(stderr, "Unable to open %s for reading\n", argv[0]);
			continue;
		}
		while (fgets(line, LINELEN, fd) != NULL)
		{
			p1 = strchr(line, '*');				/* find first '*' */
			while (p1 != NULL)
			{
				p2 = strchr(p1 + 1, '*');		/* find second '*' */
				if (p2 != NULL && p2 > p1 + 1)	/* skip "*" and "**" */
				{
					for (p = p1 + 1; p < p2; ++p)
						if (*p == ' ' || *p == '\t' || *p == '|')
							break;
					/*
					 * Only accept a *tag* when it consists of valid
					 * characters and is followed by a white character or
					 * end-of-line.
					 */
					if (p == p2 && (p1 == line || p1[-1] != '-') &&
							(strchr(" \t\n\r", p[1]) != NULL || p[1] == '\0'))
					{
						*p2 = '\0';
						++p1;
						printf("%s\t%s\t/*", p1, argv[0]);
						while (*p1)
						{
							/* insert backslash before '\\' and '/' */
							if (*p1 == '\\' || *p1 == '/')
								putchar('\\');
							putchar(*p1);
							++p1;
						}
						printf("*\n");
						p2 = strchr(p2 + 1, '*');		/* find next '*' */
					}
				}
				p1 = p2;
			}
		}
		fclose(fd);
	}
	return 0;
}
<<cut here>> cases.awk
{
print tolower($1) "\t" $2 "\t" tolower($3);
}
<<cut here>>

That's it. Good luck VIMMER.






VimTip	{{{1 483: Using GREP for a list occurrences and quickfix help command.


This is inspired by VIMTIP#391: Simple programmers TODO list using grep and quickfix
taglist.vim is VIMSCRIPT#273

This is a little tip on shortcuts to make :grep just a little bit more handy.

:GREP is simply a front end to :grep which uses the current word under the cursor and the current file.
Use this for the times when you want a list occurrences type search. (See also :h :ilist another method)

" [Feral:158/03@07:02] Easily GREP current word in current file.
command GREP    :execute 'grep '.expand('<cword>').' '.expand('%') | :copen | :cc

Certainly nothing fancy here.

Now given that continually typing :cnext, :cprev and :cc can get a bit cumbersome to type one might consider mappings to speed up the process. When such mappings call a user function we can get somewhat fancy as illustrated below.

"[Feral:314/02@19:33] Assign some keys for handy quickfix window commands.
if has("win32")
    nnoremap <kPlus>        :call <SID>Fancy_Quickfix_Cmd(':cnext')<cr>
    nnoremap <kMinus>        :call <SID>Fancy_Quickfix_Cmd(':cprev')<cr>
    nnoremap <kMultiply>    :call <SID>Fancy_Quickfix_Cmd(':cc')<cr>
    nnoremap <c-kPlus>    :clast<CR>
    nnoremap <c-kMinus>    :cfirst<CR>
    nnoremap <m-kPlus>    :cnewer<CR>
    nnoremap <m-kMinus>    :colder<CR>
endif



" [Feral:158/03@08:02] Very simple wrapper: do quickfix cmd, center line and
"    if taglist.vim's window is open sync
function s:Fancy_Quickfix_Cmd(Cmd)
    :try
        execute a:Cmd
    :catch /^Vim(\a\+):E553:/
        :echohl ErrorMsg | echo v:exception | echohl None
    :endtry

    :norm! zz

    " If the taglist window is open then :TlistSync
    "    Tag list window name: '__Tag_List__'
    if bufwinnr('__Tag_List__') != -1
        :TlistSync
    endif
endfunction

NOTE that s:Fancy_Quickfix_Cmd() uses VIM 6.2s new try/catch commands; For previous versions just omit the try/catch  endtry lines. The function works well enough just is not as graceful when you reach the first or last of the error list. I.e. PRE 6.2 version:
function s:Fancy_Quickfix_Cmd(Cmd)
    execute a:Cmd
    :norm! zz
    " If the taglist window is open then :TlistSync
    "    Tag list window name: '__Tag_List__'
    if bufwinnr('__Tag_List__') != -1
        :TlistSync
    endif
endfunction

Just as an asside, if you did not want to use a user command for something like this you can do something like this:

nnoremap <kPlus>        :cnext<CR> :norm! zz<cr> :TlistSync<CR>
nnoremap <kMinus>        :cprev<CR> :norm! zz<cr> :TlistSync<CR>
nnoremap <kMultiply>    :cc<CR> :norm! zz<cr>

Of course if you do not have/want the syncing with taglist.vim simplly remove :TlistSync.


Now, the advantage of having s:Fancy_Quickfix_Cmd() is that we can conditionally do something based on the command, or some other attribute. In this case we function the same for all commands (and just blindly execute them). We do check to see if the taglist window is open and if so ask it to Sync, if it is not, we don't.  One other (minor, cosmetic) advantage to this is we see the user command in the echo area and not the last command executed (as with just the pure mapping method directly above).

You may need to modify the :GREP command so that your grep has the proper flags, etc. On win32 I have my grepprg set to "set grepprg=C:\Dev\bin\grep.exe\ -niH", fwiw.

Happy VIMing!






VimTip	{{{1 484: Console-like fonts for Windows GVim


For some excellent "DOS"-like fonts in multiple sizes (.fon format) check out http://www.uwe-sieber.de/dosfon_e.html.  Very cool for GVim and console 
windows!






VimTip	{{{1 485: Open a new window and read in the man page for the word under the cursor


This short function opens a new window and reads in the Unix man page for the word under the cursor.  To use it add the following to your ~/.vimrc file:

fun! ReadMan()
    " Assign current word under cursor to a script variable:
    let s:man_word = expand('<cword>')

    " Open a new window:
    :exe ":wincmd n"

    " Read in the manpage for man_word (col -b is for formatting):
    :exe ":r!man " . s:man_word . " | col -b"

    " Goto first line...
    :exe ":goto"

    " and delete it:
    :exe ":delete"
endfun

" Map the K key to the ReadMan function:
map K :call ReadMan()<CR>

cf:
:help windows
:help wincmd
etc

The col command may differ on your version of Unix, see col(1) for details.






VimTip	{{{1 486: Search for word under cursor, but don't move.


This is very, very simple:

:noremap <F1> #*

I find this helpful when editing multiple files and I want to search for the word under the cursor in *another* file.
I then type F1, C-^, n.








VimTip	{{{1 487: jump to a file to a certain line number


Dear VIMMERS:

It is useful to have cn, cl for locating errors. however, when the compilation was done off-line,
gcc  ... >& compile.log
how to use the compile.log to locate the errors? for example, 
     vim.h:1506
if i use "gf" when the cursor is over "vim.h", it just jumps to the begining of the file. 
here may be one solution by combining several steps:
      nmap gt mAT f:l"aywbbgf:^Ra^M
"mA"   --- marks the current position to global register A so that i can return the log file by 'A
"T "     --- goes to the begining of the tag, so in any characters of "vim.h:1506", it first places the cursor to "v".
"f:"      --- goes to the ":" separator
"l"       --- goes to the starting of line number
"ayw   --- try to use register a to remember the line number
"bb"    --- move cursor back to the filename
"gf"     --- now jump to the file
":^Ra^M" 
          --- jump to the line number remembered in register a
 
nmap gt ... place the above steps into key combinations "g" "t" so next time use "gt" instead of "gf" on the error tag!






VimTip	{{{1 488: vimrc setting for wider vim diff window (gVim)


The Vim diff feature (fantastic as it is) opens with the default window width (gVim), and the two files each get a half width buffer windows with a vertical split between them.  When you resize, only one buffer window changes.  We might write function to automatically center the split and possibly trigger it automatically with an autocmd (advanced).  However, we can still have Vim open with a wider window when performing a diff.  The following code can be added to the vimrc file.  Be sure to adjust the numbers for the available screen real-estate and the other settings to taste.

"===============================================================
" Window settings
set lines=60           " Set window height
set columns=98         " Set window width 'co'
set guioptions+=b      " Add bottom scroll bar 'go'

" If comparing files side-by-side, then ...
if &diff
    " double the width up to a reasonable maximum
    let &columns = ((&columns*2 > 172)? 172: &columns*2)
endif
"===============================================================

Remember, the default for the columns setting is either 80 or the terminal width.  I wouldn't expect consistant results for non-gVim usage.  By the way, I still need to add a test to detect vim vs. gVim in my own vimrc (perhaps greping $VIM for gvim) so that I can adjust colors and other settings accordingly.  Note that the expression in the let statement can be replaced with a constant.  But, that expression may prove usefull if the columns setting is to vary (e.g. a filetype plugin).  For a general function (intermediate), someone would want to come up with some global names like MaxScreenColumns or MaxBufferColumns.






VimTip	{{{1 489: Section jump in Latex


This is a small mapping that can be used for jumping sections in a latex file (just like ]m and [m for Java methods)

map <silent> ]s :/\\\(sub\)\{,2}section\s*{<CR> :noh<CR>
map <silent> [s :?\\\(sub\)\{,2}section\s*{<CR> :noh<CR>

I want to extend it to recognize something like 2]s to move two sections forward. How to do it.

Aditya






VimTip	{{{1 490: Paste vim registers in search or colon command-line instead of using the system clipboard


To paste something into a search or the colon command-line without using the system clipboard, press Ctrl-R" (including the quote, which represents the unnamed register), or replace the quote with another register. For more information about registers, see ":help resisters".






VimTip	{{{1 491: can anyone tell me how to get rid of the F1 mapping ?


owkay

i have been googeling for 2 hours now

and i cant find how to remove that really anoying <F1> map

i keep hitting it as i go for esc, and its really starting to piss me off ^^;

can anyone tell me how to get rid of the F1 mapping ?






VimTip	{{{1 492: jump to file from :CVSDiff output


I use :CVSDiff from cvscommand.vim quite often to get an overview of the changes i made to a file.
I always want to jump from the diff to the corresponding line in the original file.
So I wrote a small script that does that, and put it in $VIM/after/syntax/diff.vim
Pressing <Return> will execute that script.

function! DiffJumpToFile()
  let a=line(".")                                " current line number
  let b=search("^\\(---\\|\\*\\*\\*\\) ", "b")   " search for line like *** 478,489 ***
  let c=getline(b)                               " get this line as string
  let d=strpart(c, 4, match(c, ",")-4)           " get the first line number (478) from that string

  let f=search("^\\(---\\|\\*\\*\\*\\) .*\\t", "b") " search for line like *** fileincvs.c  ....
  let g=getline(f)                                  " get this line as string
  let h=match (g, "\\t", 4)                         " look for end of filename (terminated by tab) in string
  let i=strpart(g, 4, h-4)                          " get the filename

  execute ":b " . i                                 | " change to that file
  execute "normal " . (d+a-b-1) . "G"               | " go to right line number
endfunction

nmap <buffer> <Return> :call DiffJumpToFile()<CR>

I didn't put that script in the script section because it doesn't have any error checking at all.







VimTip	{{{1 493: Open the directory for the current file in Windows


It's often handy to open the folder that corresponds to a file I'm editing (as much as I hate to leave Vim!) I've added this mapping:
   map <C-e>  :silent !explorer %:p:h:gs?\/?\\\\\\?<CR>

So that typing ctrl-e in any buffer opens the folder that the file lives in in Windows.

See :help filename-modifiers for more.






VimTip	{{{1 494: maximize or restore window


I used to define 2 different mapping for maximize and restore window. But I wanted a map that can toggle between them. So, I came up with this function. This function assumes you are using win32 version of gvim. If you are using different version, then substitute :simlat ~[rx] by the key combination for your window manager.

Add following lines on your [._]g*vimrc


let w:windowmaximized = 0

function! MaxRestoreWindow()
	if w:windowmaximized == 1
		let w:windowmaximized = 0
		" restore the window
		:simalt ~r
	else
		let w:windowmaximized = 1
		" maximize the window
		:simalt ~x
	endif
endfunction

map <F5> :call MaxRestoreWindow()<CR>






VimTip	{{{1 495: Backspace key using puTTY to RH9 box


I connect to a RedHat9 server via the free software "puTTY" from a Windows computer.  On the shell (tcsh), the <Backspace> was working as it should, but in VIM it was not.  No matter what I did in the .vimrc file, it always acted like a <Delete> key.  Very annoying.

I've discovered that one must use the keyboard setting of "linux" in the puTTY settings in order for the <Backspace> key to work properly in VIM.  The "linux" keyboard is not the default.  If one does not do this, VIM always is sent the <Delete> key command when pressing on the <Backspace>.






VimTip	{{{1 496: This is the hyperlinked html format of the Vim Reference Manual.


DESCRIPTION
----------

   	This is the hyperlinked html format of the Vim Reference Manual.  
Vim is much more than just a text editor; it's a cross-platform working
environment, but quite counter-intuitive to use. A Greek translation
of the Vim Tutor and Menu is on the drawing board at LynxX.org. 

   	If you have a Web browser, the official hypertext version is 
currently at <http://www.vim.org/>. This unofficial version looks much 
nicer than the official hypertext versions that exist at vim.org or can 
readily be converted to html from the RefMan documents, but is an exact 
copy of the source docs.

	You can downloaded it from here: 

	-- FTP <ftp://lynxx.org/misc/download>
	-- HTTP <http://lynxx.org/misc/download>


DISCLAIMER
----------

   	This document is freely redistributable, but I take no liability 
for the correctness and safety of any procedures or advice given here.  
This document is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY, explicit or implied for the MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.


BUGS
----
If you find any mistakes or dead links, please contact:

<vangelise@lynxx.org>

Vangelis Eustratius






VimTip	{{{1 497: Replacing a string with default buffer contents


It's common to replace a given string in a file with something that appears elsewhere in the file. Often I don't think to put the replacement string in a named register, so it's hard to delete the text I'm replacing without replacing what's in the default (@") copy register -- :let is too cumbersome for this. (BTW, is there a way to issue a command like 'd' or 'c' *without* replacing what's in @"?)

Anyway, I've been using this map
 vmap R :<BACKSPACE><BACKSPACE><BACKSPACE><BACKSPACE><BACKSPACE>:let @9=@"<CR>gvx"9P 

which replaces what's highlighted in visual mode the contents of ""

It's ugly though (all the backspaces are necessary to delete the default  :'<,'> that shows up when you start a command in visual mode.)

I find this useful enough that I use it, but what I really want is something similar where I could type say
  R3w
(where R is remapped to my special command) that replaces the next three words the contents of @"






VimTip	{{{1 498: Completation using the syntax file


To use the vim completion you can use a dictionary. 
:set  complete=k

As a dictionary you can use a syntax file (which are in the /syntax/ directory), so you can complete
the reserved words. 

Inserting in your .vimrc a line like that

autocmd Syntax * exec('set dict=/usr/share/vim/syntax/' .expand('<amatch>') .'.vim')

you can avoid to select the dictionary for each filetype. 
(Don't forget to use your correct syntax directory for this). 

To get more info:

:help autocmd
:help complete






VimTip	{{{1 499: View character class


This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>







VimTip	{{{1 500: View character class


This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>







VimTip	{{{1 501: View character class


This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>







VimTip	{{{1 502: View character class


This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>







VimTip	{{{1 503: PuTTY numeric keypad mappings


Purpose: Add support for {rhs} of keyboard numeric keypad while in vim insert mode and using PuTTY as a SSH terminal connection.

What to do: Add these mappings to your _vimrc or _gvimrc.  PuTTY's default terminal type is xterm.  Check your settings or just echo $TERM at the command prompt on most unix systems to verify xterm type.  

Code to add to _vimrc:
:imap ^[Oq 1
:imap ^[Or 2
:imap ^[Os 3
:imap ^[Ot 4
:imap ^[Ou 5
:imap ^[Ov 6
:imap ^[Ow 7
:imap ^[Ox 8
:imap ^[Oy 9
:imap ^[Op 0
:imap ^[On .
:imap ^[OQ /
:imap ^[OR *
:imap ^[Ol +
:imap ^[OS -

Any questions about vim and PuTTY please send to mmetzger@mv-research.com. 

Michael Metzger






VimTip	{{{1 504: syntax check


i need a condition depending on what syntax a file is

like 
if syntax = perl
    do foo
endif

tried above code, didnt work
how do i check what syntax file is loaded ?






VimTip	{{{1 505: email from vim!


I always found myself typing <ESC> into my email editor and wishing that it had the nice features of Vim. There are a bunch of hacky ways to email from Vim, but there's actually an elegant solution: Pine!

The University of Washington has turned what was once a lame console program into a sopohisticated IMAP email client with server-based address books and configuration files. Among its many options is one that allows you to use your favorite text editor to edit emails. There's even a very good port for Windows called PC-Pine. Here's the link:
 http://www.washington.edu/pine/






VimTip	{{{1 506: Open windows Help files (chm) using <CWORD> or selected area



If you want to open a CHM (HTML Help) file and force the index to go to a specific entry you can do the following (on WinXP or any windows platform that has keyhh.exe).

" Create mappings to launch the ASA9 Help file with context
nnoremap <C-F1> :silent!!cmd.exe /cstart keyhh.exe -\#klink "<C-R><C-W>" "$ASANY9\docs\dbmaen9.chm"<CR><CR>

vnoremap <C-F1> :<C-U>let old_reg=@"<cr>gvy:silent!!cmd.exe /cstart keyhh.exe -\#klink "<C-R><C-R>"" "$ASANY9\docs\dbmaen9.chm"<CR><CR>:let @"=old_reg<cr>:echo ""<CR>

Each of these are on one line.

nnoremap opens the help file using the <CWORD> that the cursor is on.

vnoremap allows you to visually select a block of text and open the search window with that text.  It also restores what ever was previously visually selected after the launch.

If you use the map repeatedly, the same HTML Help window will be used.











VimTip	{{{1 507: Quick window resizing


These key mappings (placed in your _vimrc) let you use the F8 and F9 keys to make a window wider or taller.  The shift key reverses the effect, and the Ctrl and Alt modifiers go to a choice of standard settings. Mappings to change the font size.(which work slightly differently) are also included. Obviously you can change F8 and F9 to keys of your choice.

" Window size appearance
augroup guiappearance
	au!
        set guifont=Andale_Mono:h12
	:map <F7> :set guifont=Andale_Mono:h12<CR>
	:map <S-F7> :set guifont=Andale_Mono:h10<CR>
	:map <C-F7> :set guifont=Andale_Mono:h14<CR>
	:map <F9> :set lines+=5<CR>
	:map <S-F9> :set lines-=5<CR>
	:map <C-F9> :set lines=60<CR>
	:map <M-F9> :set lines=30<CR>
	:map <F8> :set columns+=10<CR>
	:map <S-F8> :set columns-=10<CR>
	:map <C-F8> :set columns=132<CR>
	:map <M-F8> :set columns=80<CR>
augroup END







VimTip	{{{1 508: Problem with .vimrc


Hello,
  I am new to vim/gvim. I have used some of the tips given in this page but when i type gvim <filename> The following warning is comming:

Error detected while processing /users/pakeer/.vimrc:
line    6:
E518: Unknown option: on
Warning: Cannot convert string "<Key>Escape,_Key_Cancel" to type VirtualBinding
Warning: Cannot convert string "<Key>Home,_Key_Begin" to type VirtualBinding
Warning: Cannot convert string "<Key>F1,_Key_Help" to type VirtualBinding
Warning: Cannot convert string "Shift<Key>F10,_Key_Menu" to type VirtualBinding
Warning: Cannot convert string "<Key>F10,Shift_Key_Menu" to type VirtualBinding
Warning: Cannot convert string "<Key>KP_Enter,_Key_Execute" to type VirtualBinding
Warning: Cannot convert string "Alt<Key>Return,Alt_Key_KP_Enter" to type VirtualBinding

Can somebody help me out what i need to do in my .vimrc.

Regards,
Pakeer.






VimTip	{{{1 509: Commands that don't clobber the search register


I frequently execute commands (mappings, usually) that perform operations that change the value of the search register for the sake of the mapping.  They might do a :s or some such that affects the search register.  I don't always want this side effect, so I use the following command/function:

" Executes a command  (across a given range) and restores  the search register
" when done.
function! SafeSearchCommand(line1, line2, theCommand)
  let search = @/

  execute a:line1 . "," . a:line2 . a:theCommand

  let @/ = search
endfunction
com! -range -nargs=+ SS call SafeSearchCommand(<line1>, <line2>, <q-args>)

" A nicer version of :s that doesn't clobber the search register
com! -range -nargs=* S call SafeSearchCommand(<line1>, <line2>, 's' . <q-args>)

Basically, :SS followed by any command will execute that command (to simulate keystrokes, use :normal as the command) and restore the search register when it's done.  :S is a replacement for :s which works EXACTLY the same way (without or without range, flags etc. etc.) but doesn't clobber the search register in the process.






VimTip	{{{1 510: one way to set $VIMRUNTIME within vimrc



In general, $VIMRUNTIME cannot be set within vimrc.
(:set helpfile is not so useful) 
Bram prefers to let vim figures it out. 

This tip is for those who want to avoid setting $VIMRUNTIME as an enviromental variable
(either rc file on UNIX or enviroment on Windows).

I found the following steps worked on my PC and unix:

  1. find out your $VIM
     (On Windows, it is the directory where gvim.exe lives)
  
  2. create a directory called doc under $VIM
     (now, we have $VIM/doc)
  
  3. copy help.txt from official $VIMRUNTIME/doc
     (now, we have $VIM/doc/help.txt)

Now, we can set $VIMRUNTIME within vimrc, for example

   let $VIMRUNTIME='C:/usr/share/vim/vim62'

I find it is useful on PC especially when I have cygwin
installed, thus a single copy of VIMRUNTIME can be shared for
both vi (cygwin version) and gvim.exe (win32 version).









VimTip	{{{1 511: key mapping for goto the absolute line number


It's quite simple,
nmap <ENTER><ENTER> G
Now, you can keep the original [count]<ENTER> function and have an easier way to goto the abolute line number.
Have a nice day!






VimTip	{{{1 512: Automatic insertion of C/C++ header gates


C/C++ header files should be guarded against multiple inclusions using preprocessor directives, e.g.:

#ifndef FOO_H
#define FOO_H

/* Declarations. */

#endif

Placing the following snippet in your .vimrc file makes vim insert these preprocessor gates automatically:

function! s:insert_gates()
	let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
	execute "normal i#ifndef " . gatename 
	execute "normal o#define " . gatename . "   "
	execute "normal Go#endif /* " . gatename . " */" 
	normal kk
endfunction

autocmd  BufNewFile *.{h,hpp} call <SID>insert_gates()







VimTip	{{{1 513: Automatic insertion of C/C++ header gates


C/C++ header files should be guarded against multiple inclusions using preprocessor directives, e.g.:

#ifndef FOO_H
#define FOO_H

/* Declarations. */

#endif

Placing the following snippet in your .vimrc file, makes vim insert these preprocessor gates automatically, when a new header file is created:

function! s:insert_gates()
	let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
	execute "normal i#ifndef " . gatename 
	execute "normal o#define " . gatename . "   "
	execute "normal Go#endif /* " . gatename . " */" 
	normal kk
endfunction

autocmd  BufNewFile *.{h,hpp} call <SID>insert_gates()







VimTip	{{{1 514: Automatic insertion of C/C++ header gates


C/C++ header files should be guarded against multiple inclusions using preprocessor directives, e.g.:

#ifndef FOO_H
#define FOO_H

/* Declarations. */

#endif

Placing the following snippet in your .vimrc file, makes vim insert these preprocessor gates automatically, when a new header file is created:

function! s:insert_gates()
        let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
        execute "normal i#ifndef " . gatename 
        execute "normal o#define " . gatename . "   "
        execute "normal Go#endif /* " . gatename . " */" 
        normal kk
endfunction

autocmd  BufNewFile *.{h,hpp} call <SID>insert_gates()







VimTip	{{{1 515: see filenames of all scripts that vim loaded or tried to load


To see filenames of all scripts that vim loaded, including
those loaded implicitly at startup:

    :scriptnames

This does not show names of 'would-be scripts' -- that is,
scripts that vim tried to open, did not find and was 
silent about it.

To see the 'would-be' scripts -- that is, scripts that vim 
tried to open, did not find and was silent about it -- add
'-V' option when starting vim:

    vim -V

Also:
    vim --version  # shows system-dependent location of rc-files
                   # but does not show location of system/personal
                   # plugins
   :help startup







VimTip	{{{1 516: find two words in either order


The shortest regular expression to find two words
in either order (on the same line):

.*alice\&.*bob

(Thanks to Piet Delport and Matthew Winn)

Other solutions:

\(alice.*bob\)\|\(bob.*alice\)     -- "old-style" regexp

^\(.*Alice\)\@=\(.*Bob\)\@=

Keywords: find, match, search, words in either order,
          regular expression







VimTip	{{{1 517: Rejustification of *roff style markup.


Normally, I bind F4 to gqap, which suffices nicely to rejustify plain text, and most of my latex and HTML stuff (with due care taken to have plenty of blank lines for delimiting.

However, if you're dealing with *roff style markup, such as man-pages or (in my case) documents using the -ms groff macros, it won't work, as the tags
are on the line just above, such as the following example.

<begin example>
.IP Boggart
Magical being that transforms into whatever the viewer most fairs.
Proffessor Lupin used a boggart to
teach Harry how to repel Dementors, as
(at that time) Harry most faired Dementors.

<end example>

Ideally, I'd just position the cursor on the body of the text (this a definition list entry, if anyone is wondering), and just press F4. But that would also rejustify the argument to the IP macro, which would be bad.

So instead of using gqap, I use gq an a selected range of lines. I search upwards something that might be a macro, or a blank line, move down a
line into the body, start to select, search forward for the next macro or
blank line, then gq to rejustify.

The regex I use to search for the extents is
\(^\.[A-Za-z]\{2\}\\|^$\)

Since the document I'm working with has an extension of .groff, I bind, on BufferEnter, the following macro.

au BufEnter *.groff nmap <F4> ?\(^\.[A-Za-z]\{2\}\\|^$\)<Enter>jV/\(^\.[A-Za-z]\{2\}\\|^$\)<Enter>kgq

And it works. I'm using vim 6.1.320, although I believe it should work on most versions.







VimTip	{{{1 518: errorformat for icc7


This is a errorformat for Intel icc7 compiler:

errorformat=%E%f(%l): %m,%-C,%-C%p,%Z






VimTip	{{{1 519: Folding like in Visual Basic .NET


If your are using Microsoft Visual Studio .NET for editing Visual Basic .NET files, the Window Form Designer Generated Code is folded by default. If you want to have the same nice feature when editing the same file in Vim, put this code in your _vimrc file so you can switch between the folded and unfolded mode:

function! NetFold()
   set foldmethod=syntax
   syn region myFold start="#Region" end="#End Region" transparent fold keepend extend
   syn sync fromstart
   set foldcolumn=2
endfunction

function! NetUnFold()
	set foldmethod=manual
	set foldcolumn=0
	norm zE
endfunction

So when your are editing a *.vb file, you simply have to call the function like this:

:call NetFold()
or
:call NetUnFold()

Also, if you want that little function to be called automatically when you edit a *.vb file, put these two lines in your _vimrc file:

autocmd BufNewFile,BufRead *.vb	setfiletype vb
autocmd BufNewFile,BufRead *.vb	call NetFold()

Hope this will help. If you have any other suggestion, don't be shy to add them!






VimTip	{{{1 520: Searching for Identifiers


The problem:

It's always annoying trying to do a search and replace for identifiers in C when the identifier that you are searching for is a substring of other identifiers or keywords in the program.  For instance, let's say you want to search for every place you access the ubiquitous loop variable 'i'.  If you do a search, you'll hit all the i's in the "if" and "while" keywords and any other identifiers that contain the letter i.  For awhile I have been looking for some way to do this in vim.  Other IDE's that I have seen have a "whole word" option where the text must be the whole word.  Vim has the "]CTRL-I" command, but that is useless for search and replace because when you replace one instance, you won't have the original identifier under your cursor any more.  Until recently, I didn't know how to do it in vim without manually typing the whole regular expression for C identifiers.

The solution:

Use the "\<" and "\>" in your search.  Evidently, these respresent the start and end of words.  So, to search for all occurrences of the variable 'i', you would use the following command:

/\<i\>

If you want all identifiers that start with 'i', you use "/\<i" and similarly, for all identifiers ending in 'i', use "/i\>".

If anyone knows a better solution, I would love to know about it.






VimTip	{{{1 521: Something in GVIM for fun


Try these for fun

Open gvim with some text in it and try
set rl
to come back to where u were try set norl

In Gvim
type ggvGg? --- This encrypts the whole of text

Happy vimiiiing !!!!






VimTip	{{{1 522: Fix an autoindent error


When splitting a line in two, I sometimes insert a return before a space.  Unfortunately, this mangles the autoindentation: the last tab turns into spaces.  The following map fixes that problem:

"Fixes a rare autoindent error
inoremap <CR> <C-R>=ReturnWrapper()<CR>
function ReturnWrapper()
  if strpart(getline('.'), col('.') - 1) =~ '^\s*\S'
    return "\<ESC>wi\<CR>"
  else
    return "\<CR>"
  endif
endf

Thanks to vimtip #102 for the tip on using <c-r> with a wrapper function.






VimTip	{{{1 523: Folding functions with the prototype included


I used to use folding to fold functions in C/C++ from the "{" to the "}", but I wanted a way to fold the prototype as well.  Using foldexpr allows this.

" ----------- CUT
function FoldBrace()
    if getline(v:lnum+1)[0] == '{'
        return '>1'
    endif
    if getline(v:lnum)[0] == '}'
        return '<1'
    endif
    return foldlevel(v:lnum-1)                                 
endfunction                                                    

set foldexpr=FoldBrace()
set foldmethod=foldexpr
" ---------- END CUT

Note that this will only work if you put the braces on lines by themselves in the very first column, ie:
void func()
{
....
}






VimTip	{{{1 524: evaluate expression in any mode, including normal mode, using <CTRL-R>=


The <CTRL-R>= things evaluates the expression. For example:
           <CTRL-R>=12+34<cr>
<CTRL-R>= works in insert mode and in command mode.I felt
it more convenient if <CTRL-R>= did the same thing
in normal mode too.

I have this in my .vimrc:

        map <CTRL-R>= :echo

Now <CTRL-R>=123*456<CR> evaluates expressions for me in
all 3 modes: normal mode, insert mode, and command mode.
In fact I found it much more convenient to do casual calculations
using <CTRl-R>= in normal mode than in any other mode.


Be warned: when typing <CTRL-R>= in normal mode, don't make
long pause before '='. <CTRL-R> alone means 'redo' in normal mode.
Vim is very smart, and figures the difference between single
<CTRL-R> (which is 'redo') and the mapped sequence <CTRL-R>= (which is
remapped). The 'timeoutlen' option controls this difference.
The default value of 'timeoutlen' option is very convenient.



This is expansion of vimtip #73 "using vim as calculator"

References: :he c_CTRL-R
             :he i_CTRL-R
             :he 'timeoutlen'
             :he 'ttimeoutlen'

Keywords: calculator, expression evaluation, normal mode







VimTip	{{{1 525: JavaBeans helper function


This one helps creating beans. Nothing serious actually, but might come in handy. It's pretty fresh, cuz I just got annoyed with Netbeans - I haven't tested it fully. Perhaps we could create some bigger Java Struts thing, huh?

nnoremap <buffer> <silent>dc :call <SID>AddBean()<CR>
function! s:AddBean()
    let line = line('.')
    let name = inputdialog('Enter the name of the variable: ')
    let type = inputdialog('Enter the type of the variable: ')
    let upperName = substitute(name, '^\(\w\)\(.*\)$', '\u\1\2', '')
    call append(line, "\t}")
    call append(line, "\t\tthis.".name." = ".name.";")
    call append(line, "\tpublic void set".upperName."(".type." ".name.") {")
    call append(line, "")
    call append(line, "\t}")
    call append(line, "\t\treturn (this.".name.");")
    call append(line, "\tpublic ".type." get"."".upperName."() { ")
    call append(line, "")
    call append(line, "\tprivate ".type." ".name.";")
    call append(line, "\t//".name)
    return line
endfunction






VimTip	{{{1 526: enhancing Benji Fisher's word_complete.vim script


I suggest you first look at the script itself:

	http://www.vim.org/scripts/script.php?script_id=73

Since the script has some problems (at least for me) when I paste text in X11 with the mouse, and since I need to switch to paste more anyway, I now use this in my .vimrc:

" the word_complete.vim plugin just *rocks*
autocmd VimEnter * call DoWordComplete()
fun! SetComplete()
    call DoWordComplete()
    set nopaste
    nunmap <F12>
    iunmap <F12>
    nmap <F12> :call UnsetComplete()<CR>
    imap <F12> <Esc>:call UnsetComplete()<CR>a
    echo 
endfun
fun! UnsetComplete()
    call EndWordComplete()
    set paste
    nunmap <F12>
    iunmap <F12>
    nmap <F12> :call SetComplete()<CR>
    imap <F12> <Esc>:call SetComplete()<CR>a
    echo 
endfun
nmap <F12> :call UnsetComplete()<CR>
imap <F12> <Esc>:call UnsetComplete()<CR>a

Issues: 
 (i) I'm sure this can be done better
 (ii) in insert mode, F12 switches to paste mode, but not back again. In normal mode, it works. I'm sure this is going to be something really, really silly.







VimTip	{{{1 527: vim (console/xterm) colors in gvim


You might have noticed that gvim uses slightly different colors compared to the console version.  If you like the console colors more than the gvim default colors (as I do), you can add the following to your .vimrc:

    set background=dark
    hi SpecialKey    guifg=Blue
    hi MoreMsg       guifg=Green
    hi Visual        guifg=NONE guibg=NONE
    hi Folded        ctermbg=4 guibg=Blue
    hi FoldColumn    ctermbg=7
    hi DiffAdd       guibg=Blue
    hi DiffChange    guibg=Magenta
    hi DiffDelete    guibg=Cyan
    hi Normal        guifg=Gray guibg=Black
    hi Cursor        guibg=White
    hi lCursor       guibg=White
    hi Comment       guifg=Cyan
    hi Constant      guifg=Magenta
    hi Special       guifg=Red
    hi Identifier    guifg=Cyan
    hi Statement     guifg=Yellow
    hi PreProc       guifg=Blue
    hi Type          guifg=Green
    hi Underlined    guifg=Blue
    hi Todo          guifg=Black

There's one little difference: Folded is changed to something better for console *and* gui and FoldColumn is left as is in gvim and changed for console vim to match the gvim version. 






VimTip	{{{1 528: Make search results appear in the middle of the screen.


Some useful mapping to make search results appear in the middle of the screen.

nmap n nmzz.`z
nmap N Nmzz.`z
nmap * *mzz.`z
nmap # #mzz.`z
nmap g* g*mzz.`z
nmap g# g#mzz.`z






VimTip	{{{1 529: Making <s-tab> (shift-tab) work


Shift Tab <s-tab> is a useful key combination to be able to use.
I wanted to use it for tab completion: vimtip #102
Many people also use it for unindenting: vimtip #456
But shift tab seemed not to work on my system (slackware 8.1)
but I managed to find a solution, and a workaround.

Diagnosis:

Make sure you are getting something from the keypress.
Go into insert mode:
and press <control-v> then <tab>
You should get a tab.
and press <control-v> then <shift-tab>
You should get ^[[Z

If this happens, it is good, you can skip the next part of the diagnosis.

Diagnosis Part 2:

If you get nothing when you do <control-v> then <shift-tab> go to a command line prompt (#) and type:
# xmodmap -pke | grep 'Tab'

It should either show:
keycode  23 = Tab
or
keycode  23 = Tab ISO_Left_Tab

Now, which one is the 'right' one seems to depend on what terminal program you are using its various settings.
(I need to use the 'ISO_Left_Tab' one with 'xterm' but the 'Tab' one with Eterm)
I suggest you try changing to the mapping to the other one and test what you get from the keypresses again. If it doesn't work, you can just change it back.

To change the mapping:
# xmodmap -e 'keycode  23 = Tab ISO_Left_Tab'
or
# xmodmap -e 'keycode  23 = Tab'

If changing the xmodmap setting worked, you'll probably need to put it somewhere where it will load on X startup or login.
(.xinitrc or .bashrc or somewhere else depending on your system config.)
If it didn't work see the other things to try below.

Interpreting shift-tab correctly:

Once you have the shift-tab key combo generating the correct string ^[[Z you just need to make sure that is then interpreted by vim as <s-tab>

As of version 6.2 vim does this, so upgrading to 6.2 would be good.
If you cannot upgrade for whatever reason try this workaround:

:map <esc>[Z <s-tab>
:ounmap <esc>[Z

This will map the key you get when you press shift tab to <s-tab> which
you can then use in other maps/scripts
I suggest adding these lines (minus the leading : of course) to your .vimrc

Other things to try:

If none of the above worked, here are some other things to investigate.

Make sure your window manager is not eating the keystrokes. - You don't have it mapped there to change desktop, or switch between windows
or something do you?
Use 'xev' to check that shift-tab is registering as a keypress and what it is returning.

Good Luck.









VimTip	{{{1 530: How do I get the name of the current file


To get the name of the file you are currently editing use:

@%

If you want to make sure of the path as well use:

expand("%:p")

see also: 

help @
help expand

vimtip #296 for why it might be a useful thing to do.







VimTip	{{{1 531: 1-2-3, let's make gvim.exe for free



This tip is for those who is interested to make gvim.exe on
Windows without using MSVC or BCC. The condition is that cygwin
is installed. (Another tip for Windows users: cygwin makes
Windows really useful!)

Following is three steps (under any shell and any directory)
step 1:
cvs -z3 -d:pserver:anonymous@cvs.vim.sf.net:/cvsroot/vim co vim
step 2:
cd vim/src
step 3:
make -f Make_cyg.mak IME=yes

I have tested under Windows 2000 and have used my own gvim.exe
for months without any problem.

Special thanks to Dan Sharp to develop/debug Make_cyg.mak, which
make it possible.








VimTip	{{{1 532: usefule keymaps -- for comment out,etc..


-->a key map for commenting out lines -- use f12 key
append this line into your .vimrc/.gvim rc file
map <F12> ^i#<Esc>j
-->key maps to avoid a long shift press
nmap  :X        :x
nmap  :W        :w
nmap  :Q        :q









VimTip	{{{1 533: Page 1 of 123 in header of :hardcopy


To get this to work you have to know how many lines per page :hardcopy
is normally making. Open empty document and in Normal mode "100o". Then
make ":%s/^/\=line('.')". Now ":hardcopy > nu.ps". Open nu.ps in
PostScript viewer. You will see how many lines per page Vim is printing.

In my case this is 73. 
Now set 'printheader' option:

:set printheader=%<%f%h%m%=Page\ %N\ of\ %{line('$')/73+1}

Explanations of % items in option are here |'statusline'|.
line('$') - number of lines in buffer
73 - number of lines per page
+1 - Vim don't know floating point math and everything rounds down.







VimTip	{{{1 534: for verilog users only


for all verilog users dealing with netlists,this an easier way to find out in which module you are really working in.add this map to your .vimrc/.gvimrc file.use `(tick) key to find out in which module u are actually residing in.

map ` ma?module<CR>Wyiw'a:echo "module -->" @0<CR>

note:
this map works only when u are whithin the module.placing it on module/endmodule does not make any sense.







VimTip	{{{1 535: Working with only one term/console?


Sometimes you can only work with a single terminal/console, or you hate having
too many windows open and need to switch between them, or QuickFix does not
work on your favourite languages? This simple, yet powerful key stroke (Ctrl-Z)
might be very useful to you.

For example, let's say you are composing an email using vim on mutt, or you want
to compile your <insert your favourite language> file, you can simply press Ctrl-Z,
gives you the prompt back, do multiple commands and whatever you want, and
goes back to vim editing by typing "fg" again.

If you need to admin some machine that only have vi instead of vim on some reason,
you can edit multiple files by suspend them, using "jobs" to list them and "fg %n" (n
is the job number) to load them back.

So by using the simple Ctrl-Z, not only that you can edit multiple files in the same vim,
you can edit multiple groups of files in different vim.

Although it is a shell feature, but it goes together nicely with vim.

Just in case for people that do not know, if all you want is to run a single external
command, use ":!cmd", or "!<motion><filter>" to filter <motion> text throught the
command.

For example, if you have a line "1 + 1 * 2", position cursor on it, and type "!}bc",
you got "3" for you answer back.

Or another example, position your cursor at the first line of your paragraph and
type "!}fmt", now the paragraph is nicely formatted.

With all these in hand, you don't need to waste key strokes to switch between
different windows anymore, the only drawback is it only works in *nix.






VimTip	{{{1 536: Automaticly quit Vim if quickfix window (buffer) is the last


I was confused when I do some development job. Usually I have open one window with source code and one with error codes (command :copen). When I quit the source code quickfix window stay open. I'm lazy man so I must close this window with additional typing. I make simple autocmd which this difficult work in my stead.

If you like it (or are lazy too) include this code in your .vimrc and use your spared time somewhere else :-).

au BufEnter * call MyLastWindow()

function! MyLastWindow()
    " if the window is quickfix go on
    if &buftype=="quickfix"
        " if this window is last on screen quit without warning
        if winbufnr(2) == -1
            quit!
        endif
    endif
endfunction







VimTip	{{{1 537: mimicking the shift-arrows (mark block) in terminals that don't understand shift-arrow (e.g. putty)


I like the MS-windows default behavior (ctrl-c for copy, ctrl-v for paste, etc) even when I'm running vimon a unix terminal. However, using mswin doesn't give the right "mark block" behavior in the terminal I use (putty). This may hold true for other Xterm emulators: the shift-arrows (mark block) don't work because shift-arrow sends exactly the same signal as just arrows. I have some maps that fix this by assinging some imaps and vmaps to the combination of ctrl-arrows (thanks to Antoine J. Mechelynck)

" make arrow keys work in visual mode
vmap <ESC>OA k
vmap <ESC>OB j
vmap <ESC>OC l
vmap <ESC>OD h
" simulate shift-arrows (select block in windows) with control-arrows
inoremap <ESC>[A <C-O>vk
vnoremap <ESC>[A k
inoremap <ESC>[B <C-O>vj
vnoremap <ESC>[B j
inoremap <ESC>[C <C-O>vl
vnoremap <ESC>[C l
inoremap <ESC>[D <C-O>vh
vnoremap <ESC>[D h







VimTip	{{{1 538: e-mail archive


This is a small archive of all the email sent to the Vim mailing list (vim_at_vim.org). This archive covers 2-1/2 years, they are gzipped text files that contain six months each. http://www.theswamp.org/vim/






VimTip	{{{1 539: Quick access to vim tips and scripts with konqueror / kde


For those of you using KDE and Konqueror to browse the vim.sf.net, you can add it to the so called "Web Shortcuts" in konqueror:

1. In Konqueror choose "Settings/Configure Konqueror"
2. Goto "Web Shortcuts", choose "Add..."
3. Now configure the shortcut:
 * Search Name Provider: "VIM Tips"
 * Search URI: "http://vim.sourceforge.net/tips/tip.php?tip_id=\{@}"
 * URI shortcuts: "vt,vimt,vimtip"
4. Click OK and Apply the changes to Konqueror

You can now use: "vt:4" in Konqueror's location bar to jump directly to Vim Tip #4.
Feel free to do the same for VIM scripts using "http://vim.sourceforge.net/scripts/script.php?script_id=\{@}" as the Search URI.






VimTip	{{{1 540: vim6.2 or vim6.1?


I have installed Vim6.1 from RH distro and now have downloaded vim6.2 and have installed. I didnot remove vim6.1 before installing...

I want to add the color schemes as given in \"http://www.vim.org/scripts/script.php?script_id=625\"

ButI am not able to find the /vim foolder... there is a folder as follows: /usr/share/vim with color folder, but that corresponds to vim61...

I didnt know where to post the problem, so am posting in a tip...

Sorry for the inconvenience.






VimTip	{{{1 541: How to get help using VIM


If you need help with vim and do not know where to go. Check out the Community link on the left. Or click this link
http://vim.sourceforge.net/community.php







VimTip	{{{1 542: Edit remote files locally via SCP/RCP/FTP


I'm frequently editing files remotely, but if the network traffic is tight, then a normal VIM session turns into a tortuous event. The solution to that was right under my nose: VIM's Network-Oriented File Transfers (:help netrw).

Instead of editing the file remotely, it can be transfered from the host server, to a local copy, edited and then sent back when done. I know that you can do this manually, but it's a hassle, besides, if it can be done automatically, why not go for that? :)

Assuming you have the following installed and properly configured:

1. VIM
2. netrw.vim (afaik comes in all recent vim installs)
3. scp, rcp, ftp or ftp+

Then to use, all you need to go is specify the protocol, user, host and path to the file you want to edit:

vim scp://konimi@vim.org//var/www/html/rtc_functions.php
gvim scp://konimi@vim.org//var/www/html/tips/add_tip.php

Every time you write the file (:w etc.) the file will get copied over to the source and you will be brought back to your session for further editing.

If you already have an open session, then just issue the following commands:

To read/load up a file: :Nread scp://konimi@vim.org//var/www/html/rtc_functions.php
To write the file back: :Nwrite scp://konimi@vim.org//var/www/html/rtc_functions.php

That's it! You'll be editing at local speed.







VimTip	{{{1 543: vim.po - Internationalizing the Vim editor


vim.po	- Internationalizing the Vim editor
+++++++++++++++++++++++++++++++++++++++++++

	For a given vim-###-src#.tar.gz release there is only one
	vim.po file that can be created for translation purposes.
	However, this vim.po is not unique since several options may
	be set while extracting with `xgettext', depending mostly on
	the format of comments.  For your convenience you can download
	a standard vim.pot to use as a translation template for
	vim-6.1 to most any language(s): 

		http://lynxx.org/misc/download/vim-6.1-pot.tgz

	This is the general template for translating messages in Vim 6.1
	using the Xgettext format. It contains all English messages in 
	the (untranslated) form:

		msgid "ABC" 		- English text
		msgstr "" 		- canditate language
	
	To translate Vim 6.1 messages, proceed line-by-line, taking
	care not to translate commands and options specific to the
	editor. See the  GNU `gettext' man-page for more info and
	details on this.
	
	This vim.pot should be used only with v. 6.1 to translate to
	any language.
	
	When Vim versions advance, a standard vim.po must be created
	from the newer sources, as delineated in the next VimTip "Vim
	goes INTL - Translating Vim Editor Messages, Menus, and
	Encodings' (VimTip#).

	You may also want to download a complete set in Greek to use as
	an example of full support for a specific language:


		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	Happy Intl-ing!

Vangelis Eustratius
vangelise@lynxx.org






VimTip	{{{1 544: Vim goes Greek - Greek language support for Vim 6.1


Vim goes Greek - Complete set of Greek language support for Vim 6.1
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


ENGLISH TEXT
------------

	This is the full set of messages, menus and encodings to
	be used to support Greek language. This set contains:

	vim.pot				-- dummy portable
						object template for 
						vim-6.1 (can be used 
						with any language)
	vim.po				-- the above vim.pot
						file with strings 
						translated in Greek
	lang/el/LC_MESSAGES/vim.mo	-- the Greek vim.po
						file formatted in 
						machine object mode 
						(vim.mo)
	lang/menu_gr_gr.greek.vim	-- Greek used as 
						the default encoding
	lang/menu_gr_gr.latin1.vimq	-- Greek for Latin
	lang/menu_gr_gr.iso_8859-1.vim	-- Latin-based ISO
						encoding sourceing 
						from iso_8859-7 spec
	lang/menu_gr_gr.iso_8859-7.vim	-- Greek-Latin-based
						ISO encoding
	lang/menu_greece_greek.737.vim	-- MS-DOS/wINDOWS codepage 
						for Greek (737) 
	lang/menu_greek_greece.1253.vim	-- MS-DOS/wINDOWS codepage
						for Greek (1253) 
	lang/menu_greek_greece.cp437.vim-- Unix CodePage for Greek
						(nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	-- UTF-8 for Greek
	tutor/tutor.gr			-- Vim TUTOR in Greek
	README.TXT 			-- this file

	These compressed archives can be downloaded from:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	To use Vim to edit in Greek (or any) language, we first enable
	the language option for the keyboard (Control
	Panel|Keyboard|Languages|Greek) and enable a key sequence
	(e.g. Ctrl-Shift) to toggle between the default language and
	Greek. In Vim the Greek language is displayed correcty.

	Finally, we unzip vim-6.1-menu_el to the vim61 directory. This
	ensures that the above files are place in the correct path. If
	you don't know how to extract to $VIMRUNTIME, unzip to any
	temporary folder. Then drag&drop or copy-and-paste each of the
	above files to its place after creating the container folders
	(/path/to/vim61/lang/el).
	This is what one may call manual extraction, so please wash your
	hands beforehand.

	For help on setting up Vim to support Greek -- from Vim do:

		:help language
		:help messages
		:help encoding

	For messages you'll have to set at least:

	let $LANG='el'		/	let $LANG='gr' 
	:lan mes el		/	:lan mes gr

	For menus:

	:menut	English	Greek 	/	let menut=Greek

	from the cmdline or in the _vimrc file.

	For more information see VimTip #    "Vim goes INTL - 
	Translating Vim Editor Messages, Menus, Encodings".

	The present document was posted as VimTip # and can be viewed 
	online at: 

		http://www.vim.org/tips/tip.php?tip_id=

	Enjoy Vim a la Greek!



GREEK TEXT
----------

Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; - &#928;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957; &#947;&#953;&#945; &#964;&#959; Vim 6.1
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++						


	&#913;&#965;&#964;&#972; &#949;&#943;&#957;&#945;&#953; &#964;&#959; &#960;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#956;&#965;&#957;&#951;&#956;&#940;&#964;&#969;&#957;, &#956;&#949;&#957;&#959;&#973; &#954;&#945;&#953; &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951;&#962;
	&#947;&#953;&#945; &#967;&#961;&#942;&#963;&#951; &#963;&#949; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951; &#964;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#942;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#956;&#949; &#964;&#959; Vim 6.1. 		

	&#928;&#949;&#961;&#953;&#949;&#967;&#972;&#956;&#949;&#957;&#945;:
	++++++++++++
	
	vim.pot				-- &#954;&#949;&#957;&#972; &#960;&#961;&#972;&#964;&#965;&#960;&#959; &#929;&#927;
						&#947;&#953;&#945; &#964;&#959; vim-6.1 (&#956;&#960;&#959;&#961;&#949;&#943; 
						&#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#951;&#952;&#949;&#943;
						&#956;&#949; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#947;&#955;&#974;&#963;&#963;&#945;
	vim.po				-- &#964;&#959; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#959; vim.pot 
						&#956;&#949; &#963;&#965;&#956;&#946;&#959;&#955;&#959;&#963;&#949;&#953;&#961;&#941;&#962; 
						&#956;&#949;&#964;&#945;&#966;&#961;. &#963;&#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945;
	lang/el/LC_MESSAGES/vim.mo   	-- &#964;&#959; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#972; &#945;&#961;&#967;&#949;&#943;&#959; vim.po
						&#956;&#959;&#961;&#966;&#959;&#960;&#959;&#953;&#951;&#956;&#941;&#957;&#959; &#963;&#949;   
						&#954;&#945;&#964;&#940;&#963;&#964;&#945;&#963;&#951; &#924;&#927; (vim.mo)
	lang/menu_gr_gr.greek.vim	                -- Greek &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#949;&#943;&#964;&#945;&#953; &#963;&#945;&#957; 
						&#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#959;&#947;&#942;&#962;
	lang/menu_gr_gr.latin1.vimq	                -- &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; &#947;&#953;&#945; Latin
	lang/menu_gr_gr.iso_8859-1.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951; &#964;&#951; 
						&#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;, &#949;&#954;&#960;&#951;&#947;&#940;&#950;&#949;&#953; &#945;&#960;&#972;
						&#964;&#951; &#960;&#961;&#959;&#948;&#953;&#945;&#947;&#961;&#945;&#966;&#942; iso_8859-7
	lang/menu_gr_gr.iso_8859-7.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951;
						&#964;&#951; &#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;-&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#942;
	lang/menu_greece_greek.737.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (737)
	lang/menu_greek_greece.1253.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (1253) 
	lang/menu_greek_greece.cp437.vim            -- &#922;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; Unix 
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	                -- UTF-8 &#947;&#953;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	tutor/tutor.gr			-- &#934;&#929;&#927;&#925;&#932;&#921;&#931;&#932;&#919;&#931; Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	README.TXT 			-- &#945;&#965;&#964;&#972; &#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959;			
						
	&#913;&#965;&#964;&#940; &#964;&#945; &#963;&#965;&#956;&#960;&#953;&#949;&#963;&#956;&#941;&#957;&#945; &#945;&#961;&#967;&#949;&#943;&#945; &#956;&#960;&#959;&#961;&#959;&#973;&#957; &#957;&#945; &#956;&#949;&#964;&#945;&#966;&#959;&#961;&#964;&#969;&#952;&#959;&#973;&#957; &#945;&#960;&#972;:	

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz
							
	&#915;&#953;&#945; &#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#942;&#963;&#949;&#964; &#964;&#959; Vim &#963;&#945;&#957; &#949;&#960;&#949;&#958;&#949;&#961;&#947;&#945;&#963;&#964;&#942; &#954;&#949;&#953;&#956;&#941;&#957;&#959;&#965; &#963;&#964;&#945;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (&#942; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#940;&#955;&#955;&#951; &#947;&#955;&#974;&#963;&#963;&#945;, &#960;&#961;&#974;&#964;&#945; &#949;&#957;&#949;&#961;&#947;&#959;&#960;&#959;&#953;&#942;&#963;&#964;&#949; &#964;&#951;&#957; 
	&#949;&#960;&#953;&#955;&#959;&#947;&#942; &#947;&#953;&#945; &#964;&#959; &#960;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959; (&#928;&#943;&#957;&#945;&#954;&#945;&#962; &#917;&#955;&#941;&#947;&#967;&#959;&#965;|&#928;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959;| 
	&#915;&#955;&#974;&#963;&#963;&#949;&#962;|&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;) &#954;&#945;&#953; &#948;&#953;&#945;&#955;&#941;&#958;&#964;&#949; &#956;&#953;&#945; &#948;&#953;&#945;&#948;&#959;&#967;&#942; &#960;&#955;&#942;&#954;&#964;&#961;&#969;&#957; (&#960;.&#967;. ) 
	&#947;&#953;&#945; &#957;&#945; &#945;&#955;&#955;&#940;&#950;&#949;&#964;&#949; &#956;&#949;&#964;&#945;&#958;&#973; &#964;&#951;&#962; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#949;&#947;&#956;&#941;&#957;&#951;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#954;&#945;&#953;
	&#964;&#969;&#957; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;. &#931;&#964;&#959; Vim &#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945; &#960;&#961;&#959;&#946;&#940;&#955;&#955;&#959;&#957;&#964;&#945;&#953; &#963;&#969;&#963;&#964;&#940;.					
						
	&#932;&#941;&#955;&#959;&#962;, &#945;&#960;&#959;&#963;&#965;&#956;&#960;&#953;&#941;&#949;&#964;&#949; &#964;&#959; vim-6.1-menu_el &#963;&#964;&#959;&#957; &#954;&#945;&#964;&#940;&#955;&#959;&#947;&#959; vim61.
	&#913;&#965;&#964;&#972; &#949;&#958;&#945;&#963;&#966;&#945;&#955;&#943;&#950;&#949;&#953; &#972;&#964;&#953; &#964;&#945;&#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#945; &#964;&#959;&#960;&#959;&#952;&#949;&#964;&#959;&#973;&#957;&#964;&#945;&#953; &#963;&#964;&#951; &#963;&#969;&#963;&#964;&#942;
	&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#942;. &#913;&#957; &#948;&#949;&#957; &#958;&#941;&#961;&#949;&#964;&#949; &#957;&#945; &#949;&#958;&#940;&#947;&#949;&#964;&#949; &#963;&#964;&#959; $VIMRUNTIME, &#958;&#949;&#950;&#953;&#960;&#940;&#961;&#949;&#964;&#949;
	&#963;&#949; &#959;&#960;&#959;&#953;&#959;&#948;&#942;&#960;&#959;&#964;&#949; &#960;&#961;&#959;&#963;&#969;&#961;&#953;&#957;&#972; &#966;&#940;&#954;&#949;&#955;&#959;.  &#922;&#945;&#964;&#972;&#960;&#953;&#957; &#963;&#973;&#961;&#949;&#964;&#949;-&#954;-&#945;&#966;&#942;&#963;&#949;&#964;&#949; &#942;
	&#945;&#957;&#964;&#953;&#947;&#961;&#940;&#968;&#964;&#949;-&#954;-&#949;&#960;&#953;&#954;&#959;&#955;&#955;&#942;&#963;&#964;&#949; &#964;&#945; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#953;&#945; &#963;&#964;&#951; &#952;&#941;&#963;&#951; &#964;&#959;&#965;&#962; &#956;&#949;&#964;&#940;
	&#964;&#951; &#948;&#951;&#956;&#953;&#959;&#965;&#961;&#947;&#943;&#945; &#964;&#969;&#957; &#954;&#945;&#964;&#945;&#955;&#972;&#947;&#969;&#957; &#960;&#959;&#965; &#952;&#945; &#964;&#945; &#960;&#949;&#961;&#953;&#941;&#967;&#959;&#965;&#957;
	(/&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#951;/&#960;&#961;&#959;&#962;/vim61/lang/el).  
	&#913;&#965;&#964;&#942; &#949;&#943;&#957;&#945;&#953; &#951; &#955;&#949;&#947;&#972;&#956;&#949;&#957;&#951; &#967;&#949;&#953;&#961;&#959;&#954;&#943;&#957;&#951;&#964;&#951; &#949;&#958;&#945;&#947;&#969;&#947;&#942;, &#947;&#953;&#900;&#945;&#965;&#964;&#972; &#960;&#945;&#961;&#945;&#954;&#945;&#955;&#959;&#973;&#956;&#949; 
	&#957;&#945; &#960;&#955;&#973;&#957;&#949;&#964;&#949; &#964;&#945; &#967;&#941;&#961;&#953;&#945; &#963;&#945;&#962; &#960;&#961;&#959;&#951;&#947;&#959;&#965;&#956;&#941;&#957;&#969;&#962;.				

	&#915;&#953;&#945; &#946;&#959;&#942;&#952;&#949;&#953;&#945; &#963;&#964;&#951; &#961;&#973;&#952;&#956;&#953;&#963;&#951; &#964;&#969;&#957; &#960;&#945;&#961;&#945;&#956;&#941;&#964;&#969;&#957; &#964;&#959;&#965; Vim &#947;&#953;&#945; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;, &#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim, &#948;&#974;&#963;&#964;&#949;:					
							
			:help language			
			:help messages
			:help encoding								
						
	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim. &#932;&#959;&#965;&#955;&#940;&#967;&#953;&#963;&#964;&#959;&#957; &#960;&#961;&#941;&#960;&#949;&#953; &#957;&#945; &#964;&#949;&#952;&#959;&#973;&#957;
	&#947;&#953;&#945; &#956;&#965;&#957;&#942;&#956;&#945;&#964;&#945;:

	let $LANG='el'		/	let $LANG='gr' 
	:lan mes el		/	:lan mes gr

	&#947;&#953;&#945; &#956;&#949;&#957;&#959;&#973;:

	:menut	English	Greek 	/	let menut=Greek

	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#942; &#963;&#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959; _vimrc.

	&#915;&#953;&#945; &#960;&#949;&#961;&#953;&#963;&#963;&#972;&#964;&#949;&#961;&#949;&#962; &#960;&#955;&#951;&#961;&#959;&#966;&#959;&#961;&#943;&#949;&#962;, &#948;&#949;&#962; VimTip # ("Vim goes INTL -
	Translating Vim Editor Messages, Menus, Encodings").				
	
	&#932;&#959; &#960;&#945;&#961;&#972;&#957; &#941;&#947;&#947;&#961;&#945;&#966;&#959; &#948;&#951;&#956;&#959;&#963;&#953;&#949;&#973;&#964;&#951;&#954;&#949; &#963;&#945;&#957; VimTip #  &#954;&#945;&#953; &#956;&#960;&#959;&#961;&#949;&#943; &#957;&#945;
	&#958;&#949;&#966;&#965;&#955;&#953;&#963;&#964;&#949;&#943; &#963;&#949; &#945;&#960;&#949;&#965;&#952;&#949;&#943;&#945;&#962; &#963;&#973;&#957;&#948;&#949;&#963;&#951; &#963;&#964;&#951;&#957; &#953;&#963;&#964;&#959;&#963;&#949;&#955;&#943;&#948;&#945;:	

		http://www.vim.org/tips/tip.php?tip_id=

	Kales epejergasies keimenou!


Vaggelis Efstratiou
vangelise@lynxx.org







VimTip	{{{1 545: Vim goes Greek - Greek language support for Vim 6.1


Vim goes Greek - Complete set of Greek language support for Vim 6.1
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


ENGLISH TEXT
------------

	This is the full set of messages, menus and encodings to
	be used to support Greek language. This set contains:

	vim.pot				   -- dummy portable
						object template for 
						vim-6.1 (can be used 
						with any language)
	vim.po				  -- the above vim.pot
						file with strings 
						translated in Greek
	lang/el/LC_MESSAGES/vim.mo	                 -- the Greek vim.po
						file formatted in 
						machine object mode 
						(vim.mo)
	lang/menu_gr_gr.greek.vim	                 -- Greek used as 
						the default encoding
	lang/menu_gr_gr.latin1.vimq	                 -- Greek for Latin
	lang/menu_gr_gr.iso_8859-1.vim	                 -- Latin-based ISO
						encoding sourceing 
						from iso_8859-7 spec
	lang/menu_gr_gr.iso_8859-7.vim	                 -- Greek-Latin-based
						ISO encoding
	lang/menu_greece_greek.737.vim	-- MS-DOS/wINDOWS codepage 
						for Greek (737) 
	lang/menu_greek_greece.1253.vim	-- MS-DOS/wINDOWS codepage
						for Greek (1253) 
	lang/menu_greek_greece.cp437.vim            -- Unix CodePage for Greek
						(nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	                -- UTF-8 for Greek
	tutor/tutor.gr			-- Vim TUTOR in Greek
	README.TXT 			-- this file

	These compressed archives can be downloaded from:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	To use Vim to edit in Greek (or any) language, we first enable
	the language option for the keyboard (Control
	Panel|Keyboard|Languages|Greek) and enable a key sequence
	(e.g. Ctrl-Shift) to toggle between the default language and
	Greek. In Vim the Greek language is displayed correcty.

	Finally, we unzip vim-6.1-menu_el to the vim61 directory. This
	ensures that the above files are place in the correct path. If
	you don't know how to extract to $VIMRUNTIME, unzip to any
	temporary folder. Then drag&drop or copy-and-paste each of the
	above files to its place after creating the container folders
	(/path/to/vim61/lang/el).
	This is what one may call manual extraction, so please wash your
	hands beforehand.

	For help on setting up Vim to support Greek -- from Vim do:

		:help language
		:help messages
		:help encoding

	For messages you'll have to set at least:

	let $LANG='el'		/	let $LANG='gr' 
	:lan mes el		/	:lan mes gr

	For menus:

	:menut	English	Greek 	/	let menut=Greek

	from the cmdline or in the _vimrc file.

	For more information see VimTip #    "Vim goes INTL - 
	Translating Vim Editor Messages, Menus, Encodings".

	Enjoy Vim a la Greek!



GREEK TEXT
----------

Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; - &#928;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957; &#947;&#953;&#945; &#964;&#959; Vim 6.1
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++						


	&#913;&#965;&#964;&#972; &#949;&#943;&#957;&#945;&#953; &#964;&#959; &#960;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#956;&#965;&#957;&#951;&#956;&#940;&#964;&#969;&#957;, &#956;&#949;&#957;&#959;&#973; &#954;&#945;&#953; &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951;&#962;
	&#947;&#953;&#945; &#967;&#961;&#942;&#963;&#951; &#963;&#949; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951; &#964;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#942;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#956;&#949; &#964;&#959; Vim 6.1. 		

	&#928;&#949;&#961;&#953;&#949;&#967;&#972;&#956;&#949;&#957;&#945;:
	++++++++++++
	
	vim.pot				-- &#954;&#949;&#957;&#972; &#960;&#961;&#972;&#964;&#965;&#960;&#959; &#929;&#927;
						&#947;&#953;&#945; &#964;&#959; vim-6.1 (&#956;&#960;&#959;&#961;&#949;&#943; 
						&#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#951;&#952;&#949;&#943;
						&#956;&#949; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#947;&#955;&#974;&#963;&#963;&#945;
	vim.po				-- &#964;&#959; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#959; vim.pot 
						&#956;&#949; &#963;&#965;&#956;&#946;&#959;&#955;&#959;&#963;&#949;&#953;&#961;&#941;&#962; 
						&#956;&#949;&#964;&#945;&#966;&#961;. &#963;&#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945;
	lang/el/LC_MESSAGES/vim.mo   	-- &#964;&#959; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#972; &#945;&#961;&#967;&#949;&#943;&#959; vim.po
						&#956;&#959;&#961;&#966;&#959;&#960;&#959;&#953;&#951;&#956;&#941;&#957;&#959; &#963;&#949;   
						&#954;&#945;&#964;&#940;&#963;&#964;&#945;&#963;&#951; &#924;&#927; (vim.mo)
	lang/menu_gr_gr.greek.vim	                -- Greek &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#949;&#943;&#964;&#945;&#953; &#963;&#945;&#957; 
						&#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#959;&#947;&#942;&#962;
	lang/menu_gr_gr.latin1.vimq	                -- &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; &#947;&#953;&#945; Latin
	lang/menu_gr_gr.iso_8859-1.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951; &#964;&#951; 
						&#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;, &#949;&#954;&#960;&#951;&#947;&#940;&#950;&#949;&#953; &#945;&#960;&#972;
						&#964;&#951; &#960;&#961;&#959;&#948;&#953;&#945;&#947;&#961;&#945;&#966;&#942; iso_8859-7
	lang/menu_gr_gr.iso_8859-7.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951;
						&#964;&#951; &#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;-&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#942;
	lang/menu_greece_greek.737.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (737)
	lang/menu_greek_greece.1253.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (1253) 
	lang/menu_greek_greece.cp437.vim            -- &#922;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; Unix 
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	                -- UTF-8 &#947;&#953;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	tutor/tutor.gr			-- &#934;&#929;&#927;&#925;&#932;&#921;&#931;&#932;&#919;&#931; Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	README.TXT 			-- &#945;&#965;&#964;&#972; &#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959;			
						
	&#913;&#965;&#964;&#940; &#964;&#945; &#963;&#965;&#956;&#960;&#953;&#949;&#963;&#956;&#941;&#957;&#945; &#945;&#961;&#967;&#949;&#943;&#945; &#956;&#960;&#959;&#961;&#959;&#973;&#957; &#957;&#945; &#956;&#949;&#964;&#945;&#966;&#959;&#961;&#964;&#969;&#952;&#959;&#973;&#957; &#945;&#960;&#972;:	

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz
							
	&#915;&#953;&#945; &#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#942;&#963;&#949;&#964; &#964;&#959; Vim &#963;&#945;&#957; &#949;&#960;&#949;&#958;&#949;&#961;&#947;&#945;&#963;&#964;&#942; &#954;&#949;&#953;&#956;&#941;&#957;&#959;&#965; &#963;&#964;&#945;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (&#942; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#940;&#955;&#955;&#951; &#947;&#955;&#974;&#963;&#963;&#945;, &#960;&#961;&#974;&#964;&#945; &#949;&#957;&#949;&#961;&#947;&#959;&#960;&#959;&#953;&#942;&#963;&#964;&#949; &#964;&#951;&#957; 
	&#949;&#960;&#953;&#955;&#959;&#947;&#942; &#947;&#953;&#945; &#964;&#959; &#960;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959; (&#928;&#943;&#957;&#945;&#954;&#945;&#962; &#917;&#955;&#941;&#947;&#967;&#959;&#965;|&#928;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959;| 
	&#915;&#955;&#974;&#963;&#963;&#949;&#962;|&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;) &#954;&#945;&#953; &#948;&#953;&#945;&#955;&#941;&#958;&#964;&#949; &#956;&#953;&#945; &#948;&#953;&#945;&#948;&#959;&#967;&#942; &#960;&#955;&#942;&#954;&#964;&#961;&#969;&#957; (&#960;.&#967;. ) 
	&#947;&#953;&#945; &#957;&#945; &#945;&#955;&#955;&#940;&#950;&#949;&#964;&#949; &#956;&#949;&#964;&#945;&#958;&#973; &#964;&#951;&#962; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#949;&#947;&#956;&#941;&#957;&#951;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#954;&#945;&#953;
	&#964;&#969;&#957; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;. &#931;&#964;&#959; Vim &#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945; &#960;&#961;&#959;&#946;&#940;&#955;&#955;&#959;&#957;&#964;&#945;&#953; &#963;&#969;&#963;&#964;&#940;.					
						
	&#932;&#941;&#955;&#959;&#962;, &#945;&#960;&#959;&#963;&#965;&#956;&#960;&#953;&#941;&#949;&#964;&#949; &#964;&#959; vim-6.1-menu_el &#963;&#964;&#959;&#957; &#954;&#945;&#964;&#940;&#955;&#959;&#947;&#959; vim61.
	&#913;&#965;&#964;&#972; &#949;&#958;&#945;&#963;&#966;&#945;&#955;&#943;&#950;&#949;&#953; &#972;&#964;&#953; &#964;&#945;&#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#945; &#964;&#959;&#960;&#959;&#952;&#949;&#964;&#959;&#973;&#957;&#964;&#945;&#953; &#963;&#964;&#951; &#963;&#969;&#963;&#964;&#942;
	&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#942;. &#913;&#957; &#948;&#949;&#957; &#958;&#941;&#961;&#949;&#964;&#949; &#957;&#945; &#949;&#958;&#940;&#947;&#949;&#964;&#949; &#963;&#964;&#959; $VIMRUNTIME, &#958;&#949;&#950;&#953;&#960;&#940;&#961;&#949;&#964;&#949;
	&#963;&#949; &#959;&#960;&#959;&#953;&#959;&#948;&#942;&#960;&#959;&#964;&#949; &#960;&#961;&#959;&#963;&#969;&#961;&#953;&#957;&#972; &#966;&#940;&#954;&#949;&#955;&#959;.  &#922;&#945;&#964;&#972;&#960;&#953;&#957; &#963;&#973;&#961;&#949;&#964;&#949;-&#954;-&#945;&#966;&#942;&#963;&#949;&#964;&#949; &#942;
	&#945;&#957;&#964;&#953;&#947;&#961;&#940;&#968;&#964;&#949;-&#954;-&#949;&#960;&#953;&#954;&#959;&#955;&#955;&#942;&#963;&#964;&#949; &#964;&#945; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#953;&#945; &#963;&#964;&#951; &#952;&#941;&#963;&#951; &#964;&#959;&#965;&#962; &#956;&#949;&#964;&#940;
	&#964;&#951; &#948;&#951;&#956;&#953;&#959;&#965;&#961;&#947;&#943;&#945; &#964;&#969;&#957; &#954;&#945;&#964;&#945;&#955;&#972;&#947;&#969;&#957; &#960;&#959;&#965; &#952;&#945; &#964;&#945; &#960;&#949;&#961;&#953;&#941;&#967;&#959;&#965;&#957;
	(/&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#951;/&#960;&#961;&#959;&#962;/vim61/lang/el).  
	&#913;&#965;&#964;&#942; &#949;&#943;&#957;&#945;&#953; &#951; &#955;&#949;&#947;&#972;&#956;&#949;&#957;&#951; &#967;&#949;&#953;&#961;&#959;&#954;&#943;&#957;&#951;&#964;&#951; &#949;&#958;&#945;&#947;&#969;&#947;&#942;, &#947;&#953;&#900;&#945;&#965;&#964;&#972; &#960;&#945;&#961;&#945;&#954;&#945;&#955;&#959;&#973;&#956;&#949; 
	&#957;&#945; &#960;&#955;&#973;&#957;&#949;&#964;&#949; &#964;&#945; &#967;&#941;&#961;&#953;&#945; &#963;&#945;&#962; &#960;&#961;&#959;&#951;&#947;&#959;&#965;&#956;&#941;&#957;&#969;&#962;.				

	&#915;&#953;&#945; &#946;&#959;&#942;&#952;&#949;&#953;&#945; &#963;&#964;&#951; &#961;&#973;&#952;&#956;&#953;&#963;&#951; &#964;&#969;&#957; &#960;&#945;&#961;&#945;&#956;&#941;&#964;&#969;&#957; &#964;&#959;&#965; Vim &#947;&#953;&#945; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;, &#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim, &#948;&#974;&#963;&#964;&#949;:					
							
			:help language			
			:help messages
			:help encoding								
						
	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim. &#932;&#959;&#965;&#955;&#940;&#967;&#953;&#963;&#964;&#959;&#957; &#960;&#961;&#941;&#960;&#949;&#953; &#957;&#945; &#964;&#949;&#952;&#959;&#973;&#957;
	&#947;&#953;&#945; &#956;&#965;&#957;&#942;&#956;&#945;&#964;&#945;:

	let $LANG='el'		/	let $LANG='gr' 
	:lan mes el		/	:lan mes gr

	&#947;&#953;&#945; &#956;&#949;&#957;&#959;&#973;:

	:menut	English	Greek 	/	let menut=Greek

	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#942; &#963;&#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959; _vimrc.

	&#915;&#953;&#945; &#960;&#949;&#961;&#953;&#963;&#963;&#972;&#964;&#949;&#961;&#949;&#962; &#960;&#955;&#951;&#961;&#959;&#966;&#959;&#961;&#943;&#949;&#962;, &#948;&#949;&#962; VimTip # ("Vim goes INTL -
	Translating Vim Editor Messages, Menus, Encodings").				

	Kales epejergasies keimenou!


Vaggelis Efstratiou
vangelise@lynxx.org







VimTip	{{{1 546: Vim goes INTL - Translating Messages, Menus, Encodings


Vim goes INTL - Translating Vim Editor Messages, Menus, Encodings
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Message Translation 
===================

The program used for internationalizing sources is the GNU `gettext'
utility. It is discussed in detail by its creators so we won't go into
it here.

Instead, we'll follow the GNU `gettext' diagram to the letter so that
we can visualize the process of creating our vim.po and vim.mo files
using the program.

	Numbers in parentheses represent the steps we'll actually
	carry out (1 through 5):

	~~~~~~~~~~~~~~~~ QUOTE ~~~~~~~~~~~~~~~~ 

        (#1)			          [1.1]

Original C Sources ---> PO mode ---> Marked C Sources ---.
                                                         |
              .---------<--- GNU gettext Library         |
.--- make <---+                                          |
|             `---------<--------------------+-----------'
       		 (#2)
|                                            |
|   .-----<--- PACKAGE.pot <--- xgettext <---'   .---<--- PO Compendium
|   |                                            |             ^
|   |                                            `---.         |
		     [2.1] 
|   `---.                                            +---> PO mode ---.
|       +----> tupdate -------> LANG.pox --->--------'                |
|   .---'                                                             |
|   |                                                                 |
|   `-------------<---------------.                                   |
		        (#3)				
|                                 +--- LANG.po <--- New LANG.pox <----'
|   .--- LANG.gmo <--- msgfmt <---'
|   |
	    (#4)					  (#5)

|   `---> install ---> /.../LANG/PACKAGE.mo ---.
|                                              +---> "Hello world!"
`-------> install ---> /.../bin/PROGRAM -------'


	~~~~~~~~~~~~~~ END QUOTE ~~~~~~~~~~~~~~ 


(drwng got distorted in textarea)

STEP #1	
-------
	Get the most recent of the vim sources (vim-6.1-src1.tar.gz, 
vim-6.1-src2.tar.gz) from http://www.vim.org/download.php

	# create a temporary folder - let's call it "vim_tmp" -
	# anywhere on your disk:
	mkdir /path/to/vim_tmp

	# copy the vim source tarball(s) in the temporary directory:  
	cp /original/location/vim???.tar.gz /path/to/vim_tmp

	# change to that directory:
	cd /path/to/vim_tmp

	# and decompress them (currently there are only two source
	# archives):
	tar xvfz vim-6.1-src1.tar.gz ; tar xvfz vim-6.1-src2.tar.gz

NOTE: 	Several subdirectories are created, but only the `src'
	directory contains really translatable strings.

[1.1] 	
------- 
	We bypass this step since all canditate strings for
translation in C sources are already marked with `N_()' or `_()' in
vim source files.  For a full discussion of how to mark strings as
translatable in C source files, please refer to the GNU `gettext'
utilities manpage.  We'll return later to this step as the keywords in
vim source files (`N_' and `_') are needed as an argument to the
`xgettext' command.


IMPORTANT: 	Before proceeding to make the PO file, we'll have to
tag the sources, i.e. create the `tags' file:
	
		# since the `src' directory is the only one containing
		# translatable strings, and because only *.c files plus
		# two more fileS (globals.h, if_perl.xs) have them, 
		# we switch to the `src' directory and issue:
		etags *.[ch] *.xs

		# to make sure all files get tagged
		# we could just as well have issued:
		etags src/*/*.*



STEP #2	
------- 
	The command-line options we'll use are fully described 
in the gettext manpage.


NOTE: 		(i) We'll add the `join' option in the second instance
of the command line so that the strings for the second keyword (`_')
be extracted and appended to the same vim.po file; otherwise a second
file vim.po would have to be created.  (ii) We use INPUTFILE=*.[ch]
because we know where the strings are to be exctracted from; else we
must use INPUTFILE=* to exctract from all files.

	# We are ready to issue the `xgettext' command - once for each
	# keyword, and only for the files we know they contain
	# 
	# translatable strings (i.e. *.c, globals.h and if_perl.xs):
	xgettext -a -d vim -k N_ -s *.c *.h *.xs

	xgettext -a -j -d vim -k _ -s *.c *.h *.xs

	# It can also be invoked in full:
	xgettext --extract-all --default-domain=vim \
		--keyword=N_ --sort-output *.c *.h *.xs 
	xgettext --extract-all --join-existing --default-domain=vim \
		--keyword=_ --sort-output *.c *.h *.xs

CAUTION:	Don't be surprised when opening a vim.po file in a
	text editor. It looks something like this:

	...  
		#: ex_cmds.c:4421 
		msgid "E149: Sorry, no help for %s"
		msgstr ""
		
		#: globals.h:1053 
		msgid "E14: Invalid address" 
		msgstr ""
	...

	
	Now before proceeding to get the binary text we're after
	(vim.mo), we'll have to translate _all_and_each_messages_
	listed in the vim.po file. The translator must insert the
	translated sting as the value of the `msgstr' variable 
	(between quotation marks).

	To stay with the previous quotation, the Italian translation 
	of the excerpt above is:

	...  
		#: ex_cmds.c:4421 
		msgid "E149: Sorry, no help for %s"
		msgstr "E149: Spiacente, nessun aiuto per %s"
		
		#: globals.h:1053 
		msgid "E14: Invalid address" 
		msgstr "E14: Indirizzo invalido"
	...


[2.1] 
------- 
	We currently have no use for the `tupdate' command since
there's no vim.po file yet; however, this program comes handy when we
already have a *.po file and must update it based on a new release of
sources. The command is simple enough. After unpacking the new
tarballs to our "vim_tmp" directory (step 1), we issue:

	# change to tmp directory 
	cd /path/to/vim_tmp

	# rename "vim.po" to "OLD_vim.po" assuming it's placed here:
	mv vim.po OLD_vim.po

	# update OLD_vim.po:
	tupdate NEW_vim.po OLD_vim.po

	# rename "NEW_vim.po" back to its usable filename:
	mv NEW_vim.po vim.po

	In case we don't want to go through the whole process of
	creating a vim.po file after a new vim-###-src#.tar.gz
	release, this program will take care of recreating our updated
	vim.po file (NEW_vim.po) from OLD_vim.po, including the old
	translations which will be taken over to the newly created
	file as long as they still match. However, it is recommended
	that, after a new vim_src### release, we actually start over.
	Just in case!


STEP #3	
------- 
	Next step is simplicity itself--assuming all messages
have already been translated in vim.po. We'll only use one option out
of several that the `msgfmt' program supports; they are fully described 
in the `msgfmt' manpage. For hints on internationalizing Vim see the
previous VimTip (VimTip#).
		
	# change to tmp directory where our vim.po is placed:
	cd /path/to/vim_tmp

	# create vim.mo from vim.po:
	msgfmt -o vim.mo vim.po

	# or in full-text:
	msgfmt --output-file=vim.mo vim.po


STEP #4	
------- 
	Installing the vim.mo file requires that a directory
in $VIMRUNTIME$ (i.e. currently /path/to/vim61) exists or is created
express for the language you'll be supporting.

	Let's suppose the language we support is Greek (abbreviated as
	`gr' or `el'). We do:

	# create directory named `el' in $VIMRUNTIME$/path/to/lang
	# with a standard subdirectory `LC_MESSAGES':
	mkdir /path/to/vim61/lang/el 
	mkdir /path/to/vim61/lang/el/LC_MESSAGES

	# copy our vim.mo file for Greek language supported:
	cp /path/to/vim_tmp/vim.mo /path/to/vim61/lang/el/LC_MESSAGES

STEP #5	
------- 
	Vim detects the system's local language settings when
starting and--if supported--loads it automatically; else you'll have
to change default message language from within Vim using:

	" lan[guage] {name} e.g.: lan el

	" now let's test if it's working by issuing an erroneous vim
	command--like: :HELP

	"	and you'll get the message:	
	&#916;&#949;&#957; &#949;&#943;&#957;&#945;&#953; &#949;&#957;&#964;&#959;&#955;&#942; &#954;&#949;&#953;&#956;&#949;&#957;&#959;&#947;&#961;&#940;&#966;&#959;&#965;: HELP

	"	that's all Greek to me: HELP 
	Not an editor command: HELP

Summary 
-------

	- Download and unpack the vim sources in a temporary directory.
	- Use GNU `gettext' to get your template (untranslated) file.
	- Translate all entries in the template in your language.
	- Convert the translated PO file into a MO file using `msgfmt'.
	- Place MO file in /vim##/lang/your_language/LC_MESSAGES folder.
	- Set the 'language', 'messages', 'menu' options in Vim.
	- Test Vim and use it with your newly installed language.


Menu Translation 
================

	BASICS 
	------ 
		For Latin-based languages, menu translation is
	fairly painless. Open a `menu_xx_xx.latin1.vim' and use it as
	a template to create the menu after translating the relevant
	strings into the Latin-based language you intend to support.
	You only have to pay attention that unique letter identifiers
	in a given submenu don't repeat (e.g. &Open binds the letter
	`O' uniquely so that the keyboard responds to Alt-O, and
	cannot be repeated in the "File" menu.  For Latin-based
	languages, at least one encoding must be defined as the
	default encoding for a given system; Latin1 is used on all
	OS'. If your canditate language is non-Latin but Latin-based, 
	--as a rough rule--do menu translations in at least one of the 
	following encodings:
	
	o	utf-8 
	o	iso-####-# 
	o	an MS-DOS/wINDOWS code page
		--consult old MS-DOS (v.5 or 6.2) online help for 
		codepage and/or country setting details).

	HOW-TO 
	------ 
		To create the menu file, we use one or several
	word processors that supports one or several of the encodings
	for the language we intend to support. If we can find the
	above encodings in the SaveAs option of our word processor(s),
	it's already sufficient -- depending on the number of OS' you
	wish to support.  We can use, for example, an existing
	menu_xx_xx.latin1.vim template and translate the translatable
	strings pretty much like the gettext program prepares them by
	distinguishing between `msgid "ABC"' and `msgstr "XYZ"'.
	Instead we'll do it manually.  Save only the translated
	strings of the supported language (i.e. `msgstr "XYZ"' in our
	example) into a separate file using the Save As option of a
	word processor (e.g. MS-Word). Now we have, for example, a
	file containing the translated stings, say in iso-####-x with
	filename `msgstr_iso-####-x'.

	Here's the Hungarian menu for the iso_8859-2 specification
	(lang/menu_hu_hu.iso_8859-2.vim):

	msgid "ABC"	 		msgstr "XYZ"
	~~~~~~~~~~~~~~~~~~~~~~ QUOTE ~~~~~~~~~~~~~~~~~~~~~~ 
	...
	scriptencoding iso-8859-2
	
	" Help menu
	menutrans &Help			&S&#970;g&#963;
	menutrans &Overview<Tab><F1>	&#913;&ttekint&#953;s<Tab><F1>
	menutrans &How-to\ links	&HOGYAN\ linkek
	menutrans &User\ Manual		&K&#953;zik&#966;nyv"
	...

	~~~~~~~~~~~~~~~~~~~~ END QUOTE ~~~~~~~~~~~~~~~~~~~~ 			


	We would create two plain text files, one with filename
	`msgid_iso-####-y', containing the left-most part of
	menu_hu_hu.iso_8859-2.vim:
	
	...
	menutrans &Help
	menutrans &Overview<Tab><F1>
	menutrans &How-to\ links
	menutrans &User\ Manual	
	...

	and one with filename `msgstr_iso-####-z' we got with the
	SaveAs option of our word processor, containing the right-side
	part of menu_hu_hu.iso_8859-2.vim:

	...
					&S&#970;g&#963;
					&#913;&ttekint&#953;s<Tab><F1>
					&HOGYAN\
					linkek
					&K&#953;zik&#966;nyv"
	...

	CAUTION:	Do not use a spreadsheet to do the job as
	these apps add/remove bytes to encodings and reset counters
	when saved and distort them. Only use your wordprocessor's
	SaveAs option and make sure it's a good one at that.

	Then we open both files in a simple text editor (Windows
	Notepad or vim) and paste line by line the left-side-file to 
	the right-side-file so that the we get the joined file. Now 
	them as a simple text. This is, say, our
	save menu_aa_bb.iso_8859-cc.vim

	CAUTION TOO:	Do not use a legacy word processessing
	program for this last Save-As-Text-Only file operation. Do
	not use the word processor that helped with the encoding; else
	you might get the wrong bytes in encodings when the left-most
	part of the file is saved along with the rest.
	
	We can repeat the same (painstaking, yet menus are short)
	process with utf-8 encoding, MS-wINDOWS codepage, and any
	other encoding we need to support.
	

Encodings 
=========

	To create the language encodings files for Vim in any
	language, we first jot down the full specification of the
	encodings in the most common OS' for the language we intend to
	support.

	Next we create a corresponding menu_xx_yy.ABC_mn-zz.vim file
	for each of these supported encondings (making sure they
	exist!).

	We may use only one or several menu translations (we suggested
	three basic ones above, sect. 2); one of these -- the one
	with the translated strings -- can be used as the default
	encoding to reference other ones. We reference the encodings
	we cannot create with a word processor to the default encoding
	using any menu_xx_yy.ABC_mn-zz.vim as a template.

	Here's the Spanish menu for the MS-wINDOWS codepage 850
	specification (lang/menu_spanish_spain.850.vim):

		~~~~~~~~~~~~~~~~~~~~~~ QUOTE ~~~~~~~~~~~~~~~~~~~~~~ 

		source <sfile>:p:h/menu_es_es.iso_8859-1.vim

		~~~~~~~~~~~~~~~~~~~~ END QUOTE ~~~~~~~~~~~~~~~~~~~~ 

	As you can see, it contains only one line and sources this spec
	here from another one (i.e. es_es.iso_8859-1 in this case).


Examples 
========

	As an example for fully supporting a specific language you may 
	download the Greek tarball:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	See also VimTip "Vim goes Greek - Complete set of Greek language 
	support for Vim 6.1" (VimTip#).


Disclaimer 
==========

	This document is freely redistributable, but I take no
	liability for the correctness and safety of any procedures or
	advice given here.  This document is distributed in the hope
	that it will be useful, but WITHOUT ANY WARRANTY, explicit or
	implied for the MERCHANTABILITY or FITNESS FOR A PARTICULAR
	PURPOSE.

	Happy PO-MO-ing!

Vangelis Eustratius
vangelise@lynxx.org










VimTip	{{{1 547: Smarter Table Editing


Smarter Table Editing

I frequently need to edit tables where the fields are of varying lengths.
Switching between fields is a pain as the fields can contain multiple words and
using the w key is impractical. Moreover adding a new row to the table is most
troublesome. The new fields need to be aligned with the old entries and tabs
don't work very well. Below is an example of such a table that I pulled from
the vim user's guide:

USAGE                         RESULT    DESCRIPTION

append( {lnum}, {string})     Number    append {string} below line {lnum}
argc()                        Number    number of files in the argument list
argidx()                      Number    current index in the argument list
argv( {nr})                   String    {nr} entry of the argument list

* The table above might not be aligned vertically because of the font vim-online 
is using

I wrote the NextField function (given below) to automatically check the fields
on the line directly above and move the cursor to the beginning of the next
field. The function pads the line if required. I am using 2 or more spaces as
the field separator but the field separator is an argument to the function and
can be changed easily. 

I have mapped <S-Tab> (Shift-Tab) to invoke the function. In the case of the
above table hitting <S-Tab> anywhere on the lines after the line that starts
with "append" will cause the cursor to move to the next field position or just
before it depending on the context. The function will not work on the line
starting with "append" as there is an empty line with no fields above it. It
will work on the empty line below the table titles as there are fields on the
line above it. Same is the case with the empty line below the last line of the
table.

The function takes the following arguments:

fieldsep:   A pattern that specifies the field separator between table columns
minlensep:  Minimum length of field separator. It is used to make the function
            move to the next field even when the cursor is positioned less than
            the length of a field separator from the next table column. Set this
            to 0 if you are not sure what this argument is for.  
padstr:     The string to be used for padding when the current line needs to be
            padded in order to reach the next table column.  
offset:     The offset at which you want the cursor to be positioned in the 
            next table column. Set it to 0 if you want the cursor positioned at
            the start of the next table column.  

(The above table is another case where the function is helpful)

To use the function, place the code below in vimrc and add the following lines
after it:

map <S-Tab> :call NextField(' \{2,}',2,' ',0)<CR>
map! <S-Tab> <C-O>:call NextField(' \{2,}',2,' ',0)<CR>

Note: If the whitespace between the fields consists of anything other than
spaces, the function will not work correctly without changing the field
separator. Use expandtab option if you must use tabs.

Many variations of the above idea are possible. One variation would be to have
a plugin that when invoked on a specific line, extracts the field information
on that line and maps the tab key to move to the next field then onwards. That
way there won't be any dependence on the line directly above the cursor. If you
have any suggestions of your own let me know. If enough people show interest in
enhancing this feature I most likely will code an enhanced version.

--------------------------------Cut Here----------------------------------------
" function: NextField 
" Args: fieldsep,minlensep,padstr,offset
"
" NextField checks the line above for field separators and moves the cursor on
" the current line to the next field. The default field separator is two or more
" spaces. NextField also needs the minimum length of the field separator,
" which is two in this case. If NextField is called on the first line or on a
" line that does not have any field separators above it the function echoes an
" error message and does nothing. 

func! NextField(fieldsep,minlensep,padstr,offset)
    let curposn = col(".")
    let linenum = line(".")
    let prevline = getline(linenum-1)
    let curline = getline(linenum)
    let nextposn = matchend(prevline,a:fieldsep,curposn-a:minlensep)+1
    let padding = ""

    if nextposn > strlen(prevline) || linenum == 1 || nextposn == 0
        echo "last field or no fields on line above"
        return
    endif

    echo ""

    if nextposn > strlen(curline)
        if &modifiable == 0
            return
        endif
        let i = strlen(curline)
        while i < nextposn - 1
            let i = i + 1
            let padding = padding . a:padstr
        endwhile
        call setline(linenum,substitute(curline,"$",padding,""))
    endif
    call cursor(linenum,nextposn+a:offset)
    return 
endfunc
--------------------------------Cut Here----------------------------------------









VimTip	{{{1 548: Using H and L keys as context sensitive pagedown/pageup


The H and L keys move the cursor to the top or bottom of the window
respectively. They can be a real time saver, instead of hitting j/k many times,
a single H/L can move the cursor to the proper place. However, when you are
already at the top of the window the H key does nothing and similarly at the
bottom of the window the L key does nothing. 

I started using the H/L keys a few days ago and quickly discovered that after
getting to the top using H, I often want to scroll up. Hitting H again does
nothing, so I wrote a function Hcontext which makes the H key context
sensitive. I then mapped Hcontext to the H key.  Now hitting the H key anywhere
other than at the top of the window leads to the usual behavior but hitting H
at the first line of the window causes the window to scroll one page back and
positions the cursor at the top of the window.  Similar behavior is implemented
by the Lcontext function but in the other direction. Hitting L on the last line
of the window now acts like the pagedown key.

Even if you have never used the H/L keys before you can now start using them 
as replacement pagedown/pageup keys. Just cut and paste the code at the end
into your vimrc and put the following maps after that.

noremap H :call Hcontext()<CR>
noremap L :call Lcontext()<CR>

The unmapped H and L keys take a numeric count as well. Unfortunately, I am not
aware of a way to make that count available to the user functions I wrote. The
typical vim behavior in case of user functions is to supply the count as a
range to the user function. This works most of the time but sometimes the count
gets rejected because of range checking. If you are aware of a workaround
please let me know.

You can contact me by writing to latif@techuser.net. If you have suggestions as
to other keys that can be made context sensitive without affecting their
original function, email me. I also maintain a webpage where you can ask help
for your text processing problems. The webpage is at http://www.techuser.net

---------------------------------Cut Here----------------------------------------
func! Hcontext()
    if (winline() == 1 && line(".") != 1)
        exe "normal! \<pageup>H"
    else
        exe "normal! H"
    endif
    echo ''
endfunc

func! Lcontext()
    if (winline() == winheight(0) && line(".") != line("$"))
        exe "normal! \<pagedown>L"
    else
        exe "normal! L"
    endif
    echo ''
endfunc
---------------------------------Cut Here----------------------------------------







VimTip	{{{1 549: Switching normal and insert-mode disturbes cursorposition


I've found that switching from insert-mode to normal mode (by <ESC>) and back to insert mode (by <INS>) will move the cursor 1 position to the left (Try it: open any file with some long line, put the cursor into it and alternatively press <ESC> and <INS>...).

Furthermore, you cannot distinguish between position 1 (insert-cursor before the 1st character) and position 2 (insert-cursor after 1st character).

Enter the following small function and source it:

:function! EchoCursor()
echo "-->" . col(".") . "<--"
" assume you will replace characters starting at current position...
:endfun  

and map it to an unsed key (I've used A-F12):

:map <A-F12> :call EchoCursor()<CR>
:imap <A-F12> <esc>:call EchoCursor()<CR>

While A-F12 will work fine in normal mode, it won't work correct in insert-mode: you get a "1" if the cursor is before or after the 1st character (compare it with the statusline!).

But when mapping

:imap <A-F12> <right><esc>:call EchoCursor()<CR>

you will get different (and correct) positions.








VimTip	{{{1 550: FreeBSD Fix: Arrow keys/cursor movement prints A B C D letters on remote shell: xterm, vt100.


Hi,
I wonder how many of you are pissed of with arrow keys behavior during INSERT mode in Vim.
So was I.
Leave all the key mappings default, do not change your TERM environment.
Here's a simple tip,
:set term=cons25 and save the settings for Vim usage.

It was tested with Vim 5.8 and 6.1 editions on; FreeBSD 4.X-STABLE; xterm(-color),VT100 remote terminals; (t)csh shells.

Greets.
Peace.
Legalize it.







VimTip	{{{1 551: automatic indenting XML file in VIM with the help of XSLT


Do you want to indent an XML file? Try the following XSLT:
---------------------------------------- name it indent.xsl
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="xml" indent="yes"/>
<xsl:strip-space elements="*"/>
<xsl:template match="/">
  <xsl:copy-of select="."/>
</xsl:template>
</xsl:stylesheet>
----------------------------------------
In VIM, whenever a file with the ".xml" extension is loaded into the buffer, you can try the following
in your ~/.vimrc to trigger the XSLT for filtering on the buffer contents:
----------------------------------------
  if version >= 540
    augroup filetype
       autocmd FileType xml '[,']!xsltproc indent.xsl %
    augroup END
  endif
  " other autocmds
  if version>540
    autocmd!
  endif
----------------------------------------
Voila! Next time when you load an XML file in VIM, it will be indented automatically.

Cheers,













VimTip	{{{1 552: replace buffer list when switching


I use vim's session file feature a lot to switch between projects. Preserving all that context is nice. Usually my process goes like this:

1. Save the current session:
 :mks! ~/v/project1.vim

2. Quit vim
:xa

3. Restart with different session file:
 vim -S ~/v/project2.vim

I was exiting and re-opening vim because if I just loaded the second project file, a list of /both/ projects buffers would appear in my buffer list. This was not what I wanted-- I wanted to replace the first buffer list completely wtih the second.
There is a simple way to do this. 

At the top of a session file, add this:

1,999bdelete

That will delete the first 999 existing buffers, effectively allowing any new buffer definitions in the rest of the session file to replace
what is currently there. Now you can switch directly to a new session without exiting. Just use:

 :so ~/v/project2.vim








VimTip	{{{1 553: Prev and Next


One of the most useful key combinatins that remain unknown to the masses are <C-o> and <C-i>.
They work like the "back" and "next" arrows in your HTTP user agent, meaning you can jump back and back again between files/locations within the same file very very easily and comfortable.

:jumplist        for a list of possible locations.

Try it.

Use it.

Have a nice day.







VimTip	{{{1 554: Smarter Table Editing II


In vimtip #547 I described some functions that enable easier navigation
and editing of tables. I have considerably enhanced the functionality
and placed all the relevant code in a script file vimscript #769.

The idea of the script is to automatically extract fields from a table
row and use that information to create maps that aid in editing and
navigation of the table. The user first marks a table row as table
heading. The line does not literally have to be the table heading, but
it should be representative of the typical row of the table in
question.

After this step the script maps tab and shift-tab keys to move between
fields. These mappings work in both insert and normal modes. The tab
mapping is especially useful in insert mode as it inserts the correct
amount of padding to reach the start of the next field. 

The script also has an alignment feature that aligns the fields of the
row with that of the heading. Editing a pre-existing table frequently
leads to misaligned rows and this feature alleviates the need to
manually add/remove padding.

To better illustrate the functionality of the script, I have created
the table below:

====================================================================                                                 
This table      illustrates the use of         table.vim script
====================================================================                                                 
<Leader>th      marks a line as table heading  and
activates maps  for <Tab>                      and <S-Tab> keys
<Leader>th      must be invoked on a well      formed line with
the right       number of columns
This means      that the above line does not   qualify
Also notice     that the field separator is    atleast two spaces
--------------------------------------------------------------------                                                 
when the maps   are active, pressing           <Tab> here
<-- moves here  <Tab> here                     <-- moves here
<==             <S-Tab> moves back to "<=="    <**
<S-Tab> here    moves to "<**" above
--------------------------------------------------------------------                                                 
The maps for    <Tab> and <S-Tab> work in      insert and normal
modes, and can  be deactivated by pressing     <Leader>tt
pressing        <Leader>tt again,              re-enables the maps
--------------------------------------------------------------------                                                 
The script      has some very basic support    for field alignment
 It is very       easy to get out of alignment        when editing
<Leader>ta      on the line above will         fix the line to:
It is very      easy to get out of alignment   when editing
--------------------------------------------------------------------                                                 
<Leader>ta      can be very handy if the user  wants to expand or
contract        fields, just change the width  of the fields on the
  heading line      and press                      <Leader>th
  to mark the       new heading and then           num<Leader>ta
  on the top        line of the table.             num is the
  number of         lines in the table
--------------------------------------------------------------------                                                 
The alignment   command fails when a row has   more fields than
the heading     or when the contents of a      field don't fit
inside the      field, as specified by the     heading row
case1           is        this                 row
case2 is this row      ...                       ...  
this is another     example of case2, there    is no space for 
field           separator on the first         field on above line
====================================================================                                                 

If you don't like the default mappings change them to whatever you
like. The mappings are defined on top of the table.vim script file.

To install the script, place table.vim in the vim macros directory 
and source it in your vimrc using:
source $VIMRUNTIME/macros/table.vim

If you simply want to check the functionality of the script, place
the script file in your current directory, open vim in the same 
directory and use 
:so table.vim

If you have questions/comments or bug-reports to submit, send them
to latif@techuser.net or visit my website http://www.techuser.net

The script can also be downloaded from http://www.techuser.net/files







VimTip	{{{1 555: Vim as bookmark manager


Vim as bookmarks manager

Sometimes you are collecting bookmarks from various sources, not only
web, mail client, usenet even newspapers. Sometimes it is not possible, easy etc.
to insert them in your favorite web browser bookmark manager. But
nothing is lost - you can use your Editor :)

Keep all URLs in one file called eg. url. One URL per line.
Put this in your .vimrc:

autocmd BufRead ~/url map <F8> :call BrowserURL()<cr>
let g:web_browser = "konqueror"
function! BrowserURL()
	if getline('.') !~ '^\s*\#'
		if g:web_browser == "konqueror"
			exe ":!dcop `dcopfind -a 'konqueror*'` konqueror-mainwindow\\#1 newTab ".getline('.')
		elseif g:web_browser == "mozilla"
			exe ":!mozilla -remote \"openurl(".getline('.').", new-tab)\""
		endif
	endif
endfunction

Note: you can select in Visual mode few lines and open in one keypress
few tabs. Comment lines with # at the beginning. This lines won't be
precessed with function.

I am sure such operation are possible also with other webbrowsers with
tabs.

Konqueror from KDE3.2-Alpha1 (but this dcop commands should work also
	with older versions)
Mozilla 1.4







VimTip	{{{1 556: Help on <F2> for Python with pydoc


Add the following 2 lines to your ~/.vim/ftplugin/python.vim, open an pythonscript place the cursor over an keyword and press F2 and be happy.

map <F2> :exec "!xterm -e 'pydoc ".expand("<cword>")."'"<CR><CR>
imap <F2> <ESC>:exec "!xterm -e 'pydoc ".expand("<cword>")."'"<CR><CR>i








VimTip	{{{1 557: Opening several files in vim via ListFile


Suppose You want to open several files in vim, but the names of the files to open are stored in a file, each file name on separate line. This is the case with Total Commander, when You open a program and pass it %L as a parameter.

It is possible to do it like that:

gvim "+gl/^/exec 'badd '.getline('.')" +bdel +nohls +"cd %:h" LISTFILE

where LISTFILE contains list of file names to open.

For abovementioned Total Commander, I create new item in "start menu", and assign a shortcut, let's say CTRL+ALT+F4 to it. Set path\gvim.exe as a command.

This is what i put in a "parameters" section:

"+gl/^/exec 'badd '.getline('.')" +bdel +nohls +"cd %%:h" %L

Then I can select several files, press CTRL+ALT+F4 and load all of them into my favourite text editor :)






VimTip	{{{1 558: Using TagList for ANT build files


ANT is a XML based make utility (mainly for Java, http://ant.apache.org).

A build file can have several projects, and each project can have many targets.
Here is a simple example:
ant clean
ant compile
ant run

Editing an ANT file can be tiresome looking for the appropriate target entry.

Using the taglist plugin at least version 2.02 (http://vim.sourceforge.net/script.php?script_id=273) you can easily navigate an ANT file by creating these entries:

In your _vimrc file:
let g:tlist_ant_settings = 'ant;p:Project;t:Target'

And either add to or create a ctags.cnf file:
--langdef=ant
--langmap=ant:.xml
--regex-ant=/^[ \t]*<[ \t]*project.*name="([a-zA-Z0-9 ]+)".*>/\1/p,project/i
--regex-ant=/^[ \t]*<[ \t]*target.*name="([a-zA-Z0-9 ]+)".*>/\1/t,target/i

To determine where to create the ctags.cnf file see the ctags documentation (http://ctags.sourceforge.net/ctags.html, on WinXP this file goes into C:\Documents and Settings\local_user_name\ctags.cnf). 

When this is used in conjuction with the Vim compiler for ANT and a Vim Menu  for ANT (http://www.vim.org/script.php?script_id=155), it can be very powerful.







VimTip	{{{1 559: Use Vim to Expire your Mail (So that Mutt can delete them later)


Mutt has a feature to list expired mails (~E). Sadly, there's no built in way to 
set the expiry date of a certain mail so I came up with a vim mapping to manually 
insert the "Expiry:" field of the mail header.  It will ask for the date the email should 
expire (default is 'today') and then run the date command to produce the rfc-822 
compliant date.

Here's the mapping and related function:

" Set expire date for the currently edited mail
nmap ,e gg/^Date: <CR>:call GetExpiryDate()<CR>:exe "normal! oExpires:\ndate --rfc-822 -d '". ExpiryDate."'"<ESC>!!sh<CR>kJ<CR>

function GetExpiryDate()
 call inputsave()
 let g:ExpiryDate = input("Enter expiry date: ", "today")
 call inputrestore()
endfunction






VimTip	{{{1 560: Generate calendar file


Since I work on different machines, I prefer all my calendar items to be
available in one single ASCII file, which is easily handable with vim.
The function Calendar() below generates the following output (extract)

...............
----- Week 1 -----
Mo 30
Tu 31
====================    2003    ========================================
====================    Q 1     ========================================
--------------------  Jan 2003  ----------------------------------------
We 01
Th 02
Fr 03
Sa 04
Su 05
----- Week 2 -----
Mo 06
Tu 07
...............


This may be stored in a file accessible by a single key stroke from vim.

Here is the function:

function! Calendar(year, month, day, weekday, week, daycount)
  " output daycount calendar days starting from given date
  " into new buffer
  new
  set buftype=nofile bufhidden=hide noswapfile
  let year = a:year
  let month = a:month
  let day = a:day
  let wd = a:weekday
  let week = a:week

  let index = 0 
  let date = ''
  let diy = 777 " day in year, wrong before next year
  while (index < a:daycount) " no of days to output
    let diy = diy + 1
    if (wd > 7)
       let wd = 1
       let week = week + 1
       if (week >= 53)
         if (week >= 54)
           let week = 1
	 elseif (day >= 28 || day <= 3)
           let week = 1
	 endif
       endif
    endif
    if (wd == 1) " day name
       let dn = "Mo"
    elseif (wd == 2)
       let dn = "Tu"
    elseif (wd == 3)
       let dn = "We"
    elseif (wd == 4)
       let dn = "Th"
    elseif (wd == 5)
       let dn = "Fr"
    elseif (wd == 6)
       let dn = "Sa"
    elseif (wd == 7)
       let dn = "Su"
    else
       let dn = "** ERROR: Unknown day name ** "
    endif
    if ((day > 31) || (month == 2 && (day > 29 || day > 28 && year % 4)) 
    	\ || (month == 4 && day > 30) || (month == 6 && day > 30) 
	\ || (month == 9 && day > 30) || (month == 11 && day > 30))
       let day = 1
       let month = month + 1
       if (month > 12)
	  let month = 1
	  let diy = 1
	  let year = year + 1
	  if (wd <= 3)
	    let week = 1
          endif
       endif
       if (month == 1)
	 let yline = "===================="
	 call append(line("$"), yline . "    " . year . "    " . yline . yline )
	 call append(line("$"), yline . "    Q 1     " . yline . yline )
	 let monthn = "Jan"	" month name
       elseif (month == 2)
	 let monthn = "Feb"
       elseif (month == 3)
	 let monthn = "Mar"
       elseif (month == 4)
	 let monthn = "Apr"
	 call append(line("$"), yline . "    Q 2     " . yline . yline )
       elseif (month == 5)
	 let monthn = "May"
       elseif (month == 6)
	 let monthn = "Jun"
       elseif (month == 7)
	 let monthn = "Jul"
	 call append(line("$"), yline . "    Q 3     " . yline . yline )
       elseif (month == 8)
	 let monthn = "Aug"
       elseif (month == 9)
	 let monthn = "Sep"
       elseif (month == 10)
	 let monthn = "Oct"
	 call append(line("$"), yline . "    Q 4     " . yline . yline )
       elseif (month == 11)
	 let monthn = "Nov"
       elseif (month == 12)
	 let monthn = "Dec"
       else
	 let monthn = "** ERROR: Unknown month ** "
       endif
       let mline = "--------------------"
       call append(line("$"), mline . "  " . monthn . " " . year . "  " . mline . mline )
    endif
    if (wd == 1)
       "call append(line("$"), "----- Week " . week . " (" . diy . "..) -----")
       call append(line("$"), "----- Week " . week . " -----")
    endif
    let date = dn . " " " beginn with name of day of week
    if (month < 10)
       let date = date . year . '-0' . month
    else
       let date = date . year . '-' . month
    endif
    " skip month, year
    let date = dn . " " " not interested in year, month
    if (day < 10)
       let date = date . '0' . day
    else
       let date = date . day
    endif
    " let date = date . " (" . diy . ")"
    call append(line("$"), date)

    let index = index + 1
    let day = day + 1
    let wd = wd + 1
  endwhile
endfunction

map <S-F7> :call Calendar(2002, 12, 30, 1, 1, 1000)<CR><CR>
" Dec 30, 2003 is Monday (day 1 in week), week 1 in 2003


Put the above code in your vimrc and call the function, here it is shown
with entries for 1000 days. Of course, if you do not use correct
arguments matching and existing day, all output will be mess.







VimTip	{{{1 561: Context Sensitive h and l


While writing an email I noticed that the h key does nothing when pressed at
the start of the line. It occurred to me that it would be very natural behavior
for the h key to move to the end of the previous line under the above situation.
Similarly, it would be fairly useful behavior for the l key to move to the
start of the next line when the cursor is at the end of the line.

The following illustration should clarify the behavior I am talking about:

pressing l at the end of this line -->
<-- should move to the beginning of this line

pressing h at the start of the next line, should move to end of this line -->
<-- 

I have coded two functions that implement the desired behavior. Putting the
code given at the end of this tip in your vimrc will map the h and l keys to
behave in a context sensitive manner. The only caveat is that under
"virtualedit=all" h/l keys will revert to their usual vim behavior.

This tip is similar in spirit to vimtim# 548, which concerned the H and L keys.
Robert Kelly created vimscript# 763 for the code in vimtip# 548. I suggest that
he adds the code below to that script. You can also retrieve a script
with mappings for all the above mentioned keys on my download page
http://www.techuser.net?content=5

------------------------------------cut here-----------------------------------
nmap <silent> h :<C-U>call ContextLeft()<CR>
nmap <silent> l :<C-U>call ContextRight()<CR>

func! ContextLeft()
    let cnt = v:count == 0 ? 1 : v:count
    if col('.') == 1 && line('.') != 1 && &ve != "all"
        exe "normal! " . cnt. "k$"
    else
        exe "normal! " . cnt. "h"
    endif
endfunc

func! ContextRight()
    let cnt = v:count == 0 ? 1 : v:count
    if col('.') >= strlen(getline('.')) && line('.') != line('$') && &ve != "all"
        exe "normal! " . cnt . "j^"
    else
        exe "normal! " . cnt . "l"
    endif
endfunc
------------------------------------cut here-----------------------------------








VimTip	{{{1 562: modeline sets vimrc options on a per file basis


Sometimes I want vi to treat a file different than the .vimrc file.
For example, I have a file that has fixed length text records,
 tabs in this file would mess it up.
Setting the option expandtab will force tabs to be converted to spaces.

Near the top of the file I put a line that says:
# vim: set expandtab:

When I open the file after that it will replace ^I (tab characters) with the correct number of spaces.






VimTip	{{{1 563: useful Occurences under cursor and with prompt


[I is very useful  display all lines that contain the keyword under the cursor
so following are two function for selection contain in two way under cursor or prompt find

a big thanx Yegappan give me the hint for ijump


function! s:UnderOccurences()
   exe "normal [I"
   let nr = input("Which one: ")
   if nr == ""
       return
   endif
   exe "normal " . nr . "[\t"
endfunction!

function! s:FindOccurences()
   let pattern = input("Prompt Find: ")
   if pattern == ""
       return
   endif
   exe "ilist " . pattern
   let nr = input("Which one: ")
   if nr == ""
       return
   endif
   exe "ijump " . nr . pattern 
endfunction







VimTip	{{{1 564: mouse wheel for scroll only - disable paste on middle button press.


I have had a problem when using the mousewheel for scrolling. I occasionaly press the wheel and it pastes text in the clipboard's "*" register at the place where the scroll wheel was pressed accidentally. This has been a constant irritation.

The workaround is documented in VIM help - 
:help <MiddleMouse>

From change.txt (VIM help):
"If you have a scrollwheel and often accidentally paste
text, you can use these mappings to disable the
pasting with the middle mouse button: >
    :map <MiddleMouse> <Nop>
    :imap <MiddleMouse> <Nop>"

Also, to revert to the original setting for middle button click, simply unmap the previous setting.
    :unmap <MiddleMouse>
    :iunmap <MiddleMouse>

Enjoy!







VimTip	{{{1 565: never see ^M again


There have been plenty of tips dealing with ridding of ^M characters
appended to dos text files. However, all of the previous tips involve
some typing. With the following command in your vimrc, you won't have to
type anything. Moreover, you are not likely to see ^M characters again
at all, they get removed before you get to view the file. The only
exception being readonly files.

autocmd BufRead * silent! %s/^M$//

Note: Use <C-V><C-M> to enter ^M and not caret followed by M








VimTip	{{{1 566: Autocomplete with TAB when typing words


"-- Use TAB to complete when typing words, else inserts TABs as usual.
"-- Uses dictionary and source files to find matching words to complete.

"-- See help completion for source, 
"-- Note: usual completion is on <C-n> but more trouble to press all the time.
"-- Never type the same word twice and maybe learn a new spellings!
"-- Use the Linux dictionary when spelling is in doubt.
"-- Window users can copy the file to their machine.
"-- http://www.cs.albany.edu/~mosh - Mohsin Ahmed

function! Mosh_Tab_Or_Complete()
    if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
        return "\<C-N>"
    else
        return "\<Tab>"
endfunction

:inoremap <Tab> <C-R>=Mosh_Tab_Or_Complete()<CR>

:set  dictionary="/usr/dict/words"     









VimTip	{{{1 567: Edit a temporary copy of the current file


" Edit a copy of the current file as $TMP/file-$DATE by pressing 'zs'

:map  zs    :exe "sav $TMP/" . expand("%:t") . strftime("-%Y-%m-%d_%H%M%S")<CR>
 









VimTip	{{{1 568: Use temporary tags file when browsing new source.


" Create and Use $TMP/tags for local source dir (which may be unwriteable)
" Unix users can change c:/tmp to ~/tmp/ (I use $TMP with sh).

:map  <c-k>t  :!(cd %:p:h;ctags -o c:/tmp/tags -R .)&<CR>:set tags^=c:/tmp/tags<CR>   








VimTip	{{{1 569: Insert line numbers or filter thru perl.


" Create a menu item to call perl on the file
" Edit the -e "script" before pressing return to filter thru perl
" Script below works shell=sh, and add line numbers to the file.

:amenu Mo1.Format.NumberLines<TAB>:!perl :1,$!perl -ne \"printf(\\"\%3d:\%s\\",\$.,\$_);\"     

" 
" http://www.cs.albany.edu/~mosh Mohsin






VimTip	{{{1 570: Align badly formatted text region into table.


" What: Aligns badly formatted text into a table.

" How: Select region and press <A-a>, 
"    in this case aligns the '=', you decide the centering string
"    before pressing return

" You need the perl script "align" from
"    http://www.cs.albany.edu/~mosh/Perl/align 
" Inspired by Emacs align.el  
" Works on Windows and Unix.

" Default key Mapping is:

:vmap <A-a> !perl ~/perl/align -c:=  


" Example input:
"  x = 1;
"    xyz = 245;
"  a=1;

" Example Output:
"    x = 1;
"  xyz = 245;
"    a = 1;

" 
   

" I know not what; but format in apparel,
" In gait and countenance surely like a father.
" -- BIONDELLO in Taming of Shrew by Shakespeare.






VimTip	{{{1 571: source ..../vimrc and use ..../tags in an ancestor directory.


" Source .../.vimrc and use .../tags in ancestor of source directory.
" useful when you have source tree eight fathom deep,
" an exercise in vim loops.

    let parent=1
    let local_vimrc = ".vimrc"
    let local_tags = "tags"
    while parent <= 8
        if filewritable(local_vimrc)
            echomsg "sourcing " . local_vimrc
            exe ":so " . local_vimrc
        endif
        let local_vimrc = "../". local_vimrc
        let local_tags = "../". local_tags
        exe ":set tags+=".local_tags
        let parent = parent+1
        " ToDo: stop at the root on windows and ~ on unix.
    endwhile
    unlet parent local_vimrc     


" Vat be all you, one, two, tree, four, come for?
" -- DOCTOR CAIUS, Windsor, Shakespeare.

" http://www.cs.albany.edu/~mosh - Mohsin.







VimTip	{{{1 572: auto highlight word under cursor (when reading new code)


" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Turn on/off with z/ (or key of your choice)

:map z/ :call Mosh_Auto_Highlight_Toggle()<CR>

:function! Mosh_Auto_Highlight_Cword()
    :exe "let @/='\\<".expand("<cword>")."\\>'"
:endfunction

function! Mosh_Auto_Highlight_Toggle()
    :if exists("#CursorHold#*")
    :  au! CursorHold * 
    :  let @/=''
    :else
    :  set hlsearch
    :  set updatetime=500
    :  au! CursorHold * nested call Mosh_Auto_Highlight_Cword()
    :endif 
endfunction


" There is cold meat i' the cave; we'll browse on that,
" -- GUIDERIUS, in Cymbeline by Shakespeare.


" No occupation; all men idle, all;
" -- GONZALO, Tempest by ShakesPear.

" http://www.cs.albany.edu/~mosh - Mohsin.







VimTip	{{{1 573: Repeating a substitute from current cursor position


The :RS /pattern/subpattern/{flags} command+function as shown
below allows one to repeat a RS-substitute after the current
cursor position.

   Ex.
       cursor starts...
       one two three one two three one two three
       o^here

       :RS /two/TWO/
        one TWO three one two three one two three
        one TWO^cursor ends up here

       move cursor:
        one TWO three one two three one two three
        one TWO three one two ^

       cursor ends up:
        one TWO three one two three one TWO three
        one TWO three one two three one TWO^

   (normally I'd have left the characters preceding the ^ as blanks but I'm
   trying to avoid problems with proportional fonts)

Put the following into your <.vimrc> if you'd like to be able to do this:

" ---------------------------------------------------------------------
" RS: repeat substitution command
com! -range -nargs=* RS call RepeatSubst(<q-args>)

" RepatSubst:
fun! RepeatSubst(subexpr)
  if a:subexpr != ""
   let g:repeatsubst= a:subexpr
  endif
  let curcol= col(".")
  let sep   = strpart(g:repeatsubst,0,1)
  let pat   = substitute(g:repeatsubst,'^.\(.\{-}\)'.sep.'.*$','\1','')
  s/\%#./\r&/
  let curcol= curcol + matchend(getline("."),pat)
  exe "s".g:repeatsubst
  norm! k
  j!
  exe 'norm! '.curcol.'|'
endfun
" ---------------------------------------------------------------------







VimTip	{{{1 574: delete/move matching paragraphs/lines


" Put these in .vimrc, and these four items will become menu items.
" You can of course just type these one liners, if you don't have menus.
" Edit /word/ before pressing return, 
" Note: /word/ can be any perl expression to select paras.

:amenu Mo1./.Delete-Matching-Paras<tab>:1,$!perl :1,$! perl -0000lne 'print if m/word/'

:amenu Mo1./.Delete-Matching-Lines<TAB>:g//d     :g//d<CR>
:amenu Mo1./.Delete-Non-Matching-Lines<TAB>:v//d :v//d<CR>

:amenu Mo1./.Move-Matching-Lines-Top<TAB>g//\.m0     ma:g// .m0<CR>`a
:amenu Mo1./.Move-Non-Matching-Lines-Last<TAB>v//\.m$ ma:v// .m$<CR>`a    


" - Mohsin Ahmed http://www.cs.albany.edu/~mosh

" > To match thy goodness? My life will be too short,
" > And every measure fail me. -- Cordelia, King Lear 4.7







VimTip	{{{1 575: chop long lines.


" Some regexp substitutions for your menus from .vimrc

:amenu Mo1.Format.ChopLongLines         :%s!\(.\{-80,}\)\s!\1<C-v>\r!gc       

:amenu Mo1.Format.JoinHypenatedLines    :%s,\v\s+(\w+)-\n(\s*)(\S+)\s*, \1\3^M\2,gc

:amenu Mo1.Format.JoinBackSlashLines    :%s,\\\n,,gc



" - Mohsin Ahmed http://www.cs.albany.edu/~mosh
" > How now, how now, chop-logic! What is this? - Capulet, R & Juliet 3.5, WS.






VimTip	{{{1 576: one call to generate all unicode "characters" from within vim



This is a small function to generate all unicode "characters".
It might be interesting to those who are familiar with CJK. 

I modified Frank's idea, http://groups.yahoo.com/group/vim/message/43907,
with a neat format. (Thank you, Frank)

Tony Mechelynck offered a great tip as how to work with utf-8 in


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! GenerateUnicode()
  let i = 0
  while i <= 16*16*16*16
    let n = i
    let j = 0
    let h = ""
    while n
       let h = '0123456789ABCDEF'[n%16].h
       let n = n/16
    endwhile
    let c = h.' '
    while j<16
      let u = i+j
      let c = c.nr2char(u).' '
      let j = j+1
    endwhile
    $put = c
    let i = i+16
    if (i%(16*16) == 0)
      $put='----------------------------------------------------'
      $put='     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F '
      $put='----------------------------------------------------'
    endif
  endwhile
endfunction
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""









VimTip	{{{1 577: Access vim@vim.org using Newsgroup Reader


For some reason one may not prefer mailling lists over usenet newsgroups (like me).

IMHO Newsgroup reader is a lot more versatile and easy to use. So, find a newsgroup equivalent for vim@vim.org is improtant for newsgreoup users. Unfortunately, the comp.editors on USENET is not as active as vim@vim.org.

The non-official news server news.gmane.org, have a mirror to vim@vim.org, named gmane.editors.vim, the maillist vim@vim.org and newsgroup gmane.editors.vim seemed to be syncronised together. 

To access the gmane news, just new an account with the NNTP server news.gmane.org, then find the newsgroup gmane.editors.vim, then you can enjoy vim@vim.org with your favorate news reader program, and without messing up mailling list messages with your private e-mail client (which is what the newsgroup designed for).

I think gmane.editors.vim should be highly recommended for newsgoup users.






VimTip	{{{1 578: Specify Range with search patterns


I was recently using sed to pull out multi-line fields with sed when I wondered if I could specify a range using two search patterns in vim as I can in sed.  Sure enough it works.  I am using 6.1 and do not know if this feature is new but I suspect it  has probably been around.

Here is a contrived example.  Suppose I had a vim script I was editing and I want to comment out the function declaration of a function named My_func.  Instead of searching for it, marking the range and then adding a comment to the start of the line, the following command will work:

:/^ *function *My_funct\>/,/^ *endfunction/s/^/" /

The range is specified by two patterns.  For the start of the range I look for the line which contains function My_funct.  I added the \> end of word delimeter to the pattern in case I had other functions that had names beginning with My_func.

The end of the range will be the first occurance of the second pattern, /^ *endfunction/ starting from where the first pattern was matched.

The two patterns are separated with a comma as any range would be and the command to perform on the range follows.  In this case a substitution, s/^/: / but it could be any command.

This has become useful and even though I have used vim for several years this was a new discovery for me.







VimTip	{{{1 579: Cut&Paste without too much newlines, eg. into WORD


Sometimes I am forced to enter text into MS Word. Since this tool is not
reliable and fast enough for me, I often prefer to create the text in
VIM before and cut&paste it into Word.
Unfortunately, Word creates newlines of its own and regards entered
newlines as paragraphs. So I created a mapping that deletes all single
newlines from a selected area but keeps multiple ones. Here it is:

vmap <C-C> "+y:let @+ = substitute(@+, "\n\n\n*", "±", "g")
	\\|:let @+ = substitute(@+, "\n", " ", "g")<CR>
	\\|:let @+ = substitute(@+, "±", "\\n", "g")<CR>
	\\|'<


Just shortly what is does:
Copy the visual area into the selection register +, subsitute two and
more newlines but a strange symbol hopefully not contained in the area
(±), substitute single newlines by a blank and resubstitute the strange
symbol by one newline, then go back to the beginning of the selected area.

If you select now text in VIM with V, it is copied with <Ctrl-C> as
described and can be pasted normally into another application.


Siegfried







VimTip	{{{1 580: Switching back and forth between ViM and Visual Studio .NET


This tip is for when you work on a devstudio project and need the debugger heavily and/or can't stay in ViM all the time. But when it comes time to make changes you want to do them in ViM and don't want to relocate the file and line number. 

After you have made the change and perhaps opened another file or navigated your way to a new section of the code you want to switch back to devstudio at the spot you were in ViM. It may be because you want to set a breakpoint or any reason.

The easy part:
Launching ViM from DevStudio.NET is easy. 

From the DevStudio menu item Tools|External Tools...  add a new entry where:
The "Command Line" field is set to the path of the ViM executable
The "Arguments" field contains: --servername gmain --remote-silent +$(CurLine) +"normal zz" $(ItemPath)
The "Initial Directory" may optionally contain: $(ItemDir)

This will start a ViM session or connect to an already existing one (--remote-silent) named gmain (--servername gmain). This will use only one instance of ViM for all devstudio editing. It will open the file specified by $(ItemPath) and set the cursor pos to $(CurLine). It will also execute the normal command zz to center the cursor.

You can then create a keyboard shorcut to map to this tool (Tools|Options||Environment|Keyboard, select Tools.ExternalCommandX) and you will be able to switch to ViM quickly.


The hard part:
Opening a file in an existing DevStudio.NET instance is a pain and setting the cursor to a line number is even more so.

DevStudio cannot be controlled by the command line. To open a file in an existing instance a DDE call must be initiated. Its an old and obsolete technology called Dynamic Data Exchange used for interprocess communication. When you click on a .cpp file in the Windows Explorer it calls devenv.exe with the /DDE switch (its undocumented) and sends it an Open DDE command. You can see it for yourself if you look at the file type mapping of .cpp in the Windows Explorer (if you haven't already changed them to open ViM :-)). The Explorer shell is DDE enabled but I found no way to send DDE from the command line (I didn't really look for it either ;-)). So I wrote a small C++ console app from the code I got from an Experts Exchange question. I formatted the code, renamed references from DevStudio to DevEnv and put it in a project. 

Setting the line number is a different problem. I wrote a Perl script using the Win32::GuiTest module. This module allows interacting with the Windows GUI and provides a very useful function called SendKeys. The script finds the Visual C++ window (if you are using a different language change the script) and sends it: a CTRL-G, the current line number as specified on the command line and ENTER.

It is integrated in ViM by a function (in _vimrc) that gets the current file name and line number and silently executes the script:
function! DevEnvDDE()
	let cmd = '!devenvdden.pl %:p ' . line(".")
	silent execute cmd
endfunction

All that is left is to map the function to a key.


You can get the source files for the Perl script and DDE project at http://dunderxiii.tripod.com/vimtips/devenvdde.zip
The original DDE code was taken at http://www.experts-exchange.com/Programming/Programming_Platforms/Win_Prog/Q_20489782.html
Win32::GUITest is located at http://groups.yahoo.com/group/perlguitest/






VimTip	{{{1 581: Using vim to view source and edit textarea in mozilla/firebird



This is the feature I have dreamed for months, please refer to
http://mozex.mozdev.org








VimTip	{{{1 582: Quick way to write to your file.


Put this in your .vimrc
map , :w^M

When you need to save your file instead of typing :w and hitting enter, just hit the comma (,) Note that with vim you may need to type CTRL-Q first to get the verbose CTRL-M character in your file.  For those who have earlier versions or non-PC compatible, CTRL-V before CTRL-M will get that character in there.  Has been life-changing for me :-).  I can't take the credit as I found this one years back when scanning info about building html pages.  The author had a little script that checked the update of the file and sent a message to the browser to re-read the file when the file was written.  He's the one who suggested mapping an unmapped button to do this.








VimTip	{{{1 583: Vim as XML Editor



If Vim is your main text editor, and if you do a lot of XML editing, then this mini howto might help you to make that even more fun:

Vim as XML Editor
http://www.pinkjuice.com/howto/vimxml/









VimTip	{{{1 584: Awesome text formatter


The berkeley program 'par' can format/justify 
text/c-comments (examples below) better (and much more) than 
the default unix formatters.

Download from: http://www.cs.berkeley.edu/~amc/Par/  

Usage:

Select region and press <A-q> to format.
In ~/_vimrc put (-j is for justify lines)

  :set formatprg=par\ -w60          
  : map <A-q> {v}!par -jw60<CR>
  :vmap <A-q> !par -jw60<CR>          


Examples from par.man

    Before:

        /*   We the people of the United States, */
        /* in order to form a more perfect union, */
        /* establish justice, */
        /* insure domestic tranquility, */
        /* provide for the common defense, */
        /* promote the general welfare, */
        /* and secure the blessing of liberty */
        /* to ourselves and our posterity, */
        /* do ordain and establish the Constitution */
        /* of the United States of America. */

    After "par -59":

        /*   We the people of the United States, in      */
        /* order to form a more perfect union, establish */
        /* justice, insure domestic tranquility, provide */
        /* for the common defense, promote the general   */
        /* welfare, and secure the blessing of liberty   */
        /* to ourselves and our posterity, do ordain     */
        /* and establish the Constitution of the United  */
        /* States of America.                            */

    Or after "par -59f":

        /*   We the people of the United States,  */
        /* in order to form a more perfect union, */
        /* establish justice, insure domestic     */
        /* tranquility, provide for the common    */
        /* defense, promote the general welfare,  */
        /* and secure the blessing of liberty to  */
        /* ourselves and our posterity, do ordain */
        /* and establish the Constitution of the  */
        /* United States of America.              */

    Or after "par -59l":

        /*   We the people of the United States, in      */
        /* order to form a more perfect union, establish */
        /* justice, insure domestic tranquility,         */
        /* provide for the common defense, promote       */
        /* the general welfare, and secure the           */
        /* blessing of liberty to ourselves and our      */
        /* posterity, do ordain and establish the        */
        /* Constitution of the United States of America. */

    Or after "par -59lf":

        /*   We the people of the United States,  */
        /* in order to form a more perfect union, */
        /* establish justice, insure domestic     */
        /* tranquility, provide for the common    */
        /* defense, promote the general welfare,  */
        /* and secure the blessing of liberty     */
        /* to ourselves and our posterity, do     */
        /* ordain and establish the Constitution  */
        /* of the United States of America.       */

    Or after "par -59lft0":

        /*   We the people of the United States,         */
        /* in order to form a more perfect union,        */
        /* establish justice, insure domestic            */
        /* tranquility, provide for the common           */
        /* defense, promote the general welfare,         */
        /* and secure the blessing of liberty            */
        /* to ourselves and our posterity, do            */
        /* ordain and establish the Constitution         */
        /* of the United States of America.              */

    Or after "par -59j":

        /*   We  the people  of  the  United States,  in */
        /* order to form a more perfect union, establish */
        /* justice, insure domestic tranquility, provide */
        /* for the  common defense, promote  the general */
        /* welfare, and  secure the blessing  of liberty */
        /* to ourselves and our posterity, do ordain and */
        /* establish  the  Constitution  of  the  United */
        /* States of America.                            */

    Or after "par -59jl":

        /*   We  the   people  of  the   United  States, */
        /* in   order    to   form   a    more   perfect */
        /* union,  establish  justice,  insure  domestic */
        /* tranquility, provide for  the common defense, */
        /* promote  the  general   welfare,  and  secure */
        /* the  blessing  of  liberty to  ourselves  and */
        /* our  posterity, do  ordain and  establish the */
        /* Constitution of the United States of America. */

    Before:

        Preamble      We the people of the United States,
        to the US     in order to form
        Constitution  a more perfect union,
                      establish justice,
                      insure domestic tranquility,
                      provide for the common defense,
                      promote the general welfare,
                      and secure the blessing of liberty
                      to ourselves and our posterity,
                      do ordain and establish
                      the Constitution
                      of the United States of America.

    After "par -52h3":

        Preamble      We the people of the United
        to the US     States, in order to form a
        Constitution  more perfect union, establish
                      justice, insure domestic
                      tranquility, provide for the
                      common defense, promote the
                      general welfare, and secure
                      the blessing of liberty to
                      ourselves and our posterity,
                      do ordain and establish the
                      Constitution of the United
                      States of America.

    Before:

         1  We the people of the United States,
         2  in order to form a more perfect union,
         3  establish justice,
         4  insure domestic tranquility,
         5  provide for the common defense,
         6  promote the general welfare,
         7  and secure the blessing of liberty
         8  to ourselves and our posterity,
         9  do ordain and establish the Constitution
        10  of the United States of America.

    After "par -59p12l":

         1  We the people of the United States, in order to
         2  form a more perfect union, establish justice,
         3  insure domestic tranquility, provide for the
         4  common defense, promote the general welfare,
         5  and secure the blessing of liberty to ourselves
         6  and our posterity, do ordain and establish the
         7  Constitution of the United States of America.

    Before:

        > > We the people
        > > of the United States,
        > > in order to form a more perfect union,
        > > establish justice,
        > > ensure domestic tranquility,
        > > provide for the common defense,
        >
        > Promote the general welfare,
        > and secure the blessing of liberty
        > to ourselves and our posterity,
        > do ordain and establish
        > the Constitution of the United States of America.

    After "par -52":

        > > We the people of the United States, in
        > > order to form a more perfect union,
        > > establish justice, ensure domestic
        > > tranquility, provide for the common
        > > defense,
        >
        > Promote the general welfare, and secure
        > the blessing of liberty to ourselves and
        > our posterity, do ordain and establish
        > the Constitution of the United States of
        > America.

    Before:

        >   We the people
        > of the United States,
        > in order to form a more perfect union,
        > establish justice,
        > ensure domestic tranquility,
        > provide for the common defense,
        >   Promote the general welfare,
        > and secure the blessing of liberty
        > to ourselves and our posterity,
        > do ordain and establish
        > the Constitution of the United States of America.

    After "par -52d":

        >   We the people of the United States,
        > in order to form a more perfect union,
        > establish justice, ensure domestic
        > tranquility, provide for the common
        > defense,
        >   Promote the general welfare, and secure
        > the blessing of liberty to ourselves and
        > our posterity, do ordain and establish
        > the Constitution of the United States of
        > America.

    Before:

        # 1. We the people of the United States.
        # 2. In order to form a more perfect union.
        # 3. Establish justice, ensure domestic
        #    tranquility.
        # 4. Provide for the common defense
        # 5. Promote the general welfare.
        # 6. And secure the blessing of liberty
        #    to ourselves and our posterity.
        # 7. Do ordain and establish the Constitution.
        # 8. Of the United States of America.

    After "par -37p13dh":

        # 1. We the people of the
        #    United States.
        # 2. In order to form a more
        #    perfect union.
        # 3. Establish justice,
        #    ensure domestic
        #    tranquility.
        # 4. Provide for the common
        #    defense
        # 5. Promote the general
        #    welfare.
        # 6. And secure the blessing
        #    of liberty to ourselves
        #    and our posterity.
        # 7. Do ordain and establish
        #    the Constitution.
        # 8. Of the United States of
        #    America.

    Before:

        /*****************************************/
        /*   We the people of the United States, */
        /* in order to form a more perfect union, */
        /* establish justice, insure domestic    */
        /* tranquility,                          */
        /*                                       */
        /*                                       */
        /*   [ provide for the common defense, ] */
        /*   [ promote the general welfare,    ] */
        /*   [ and secure the blessing of liberty ] */
        /*   [ to ourselves and our posterity, ] */
        /*   [                                 ] */
        /*                                       */
        /* do ordain and establish the Constitution */
        /* of the United States of America.       */
        /******************************************/

    After "par -42r":

        /********************************/
        /*   We the people of the       */
        /* United States, in order to   */
        /* form a more perfect union,   */
        /* establish justice, insure    */
        /* domestic tranquility,        */
        /*                              */
        /*                              */
        /*   [ provide for the common ] */
        /*   [ defense, promote the   ] */
        /*   [ general welfare, and   ] */
        /*   [ secure the blessing of ] */
        /*   [ liberty to ourselves   ] */
        /*   [ and our posterity,     ] */
        /*   [                        ] */
        /*                              */
        /* do ordain and establish the  */
        /* Constitution of the United   */
        /* States of America.           */
        /********************************/

    Or after "par -42re":

        /********************************/
        /*   We the people of the       */
        /* United States, in order to   */
        /* form a more perfect union,   */
        /* establish justice, insure    */
        /* domestic tranquility,        */
        /*                              */
        /*   [ provide for the common ] */
        /*   [ defense, promote the   ] */
        /*   [ general welfare, and   ] */
        /*   [ secure the blessing of ] */
        /*   [ liberty to ourselves   ] */
        /*   [ and our posterity,     ] */
        /*                              */
        /* do ordain and establish the  */
        /* Constitution of the United   */
        /* States of America.           */
        /********************************/

    Before:

        Joe Public writes:
        > Jane Doe writes:
        > >
        > >
        > > I can't find the source for uncompress.
        > Oh no, not again!!!
        >
        >
        > Isn't there a FAQ for this?
        >
        >
        That wasn't very helpful, Joe. Jane,
        just make a link from uncompress to compress.

    After "par -40q":

        Joe Public writes:

        > Jane Doe writes:
        >
        >
        > > I can't find the source for
        > > uncompress.
        >
        > Oh no, not again!!!
        >
        >
        > Isn't there a FAQ for this?
        >

        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Or after "par 40qe":

        Joe Public writes:

        > Jane Doe writes:
        >
        > > I can't find the source for
        > > uncompress.
        >
        > Oh no, not again!!!
        >
        > Isn't there a FAQ for this?

        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Or after "par -40qi":

        Joe Public writes:
        > Jane Doe writes:
        > >
        > >
        > > I can't find the source for
        > > uncompress.
        > Oh no, not again!!!
        >
        >
        > Isn't there a FAQ for this?
        >
        >
        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Or after "par -40qie":

        Joe Public writes:
        > Jane Doe writes:
        > > I can't find the source for
        > > uncompress.
        > Oh no, not again!!!
        >
        > Isn't there a FAQ for this?
        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Before:

        I sure hope there's still room
        in Dr. Jones' section of archaeology.
        I've heard he's the bestest.  [sic]

    After "par -50g":

        I sure hope there's still room in
        Dr. Jones' section of archaeology.  I've
        heard he's the bestest. [sic]

    Or after "par -50gc":

        I sure hope there's still room in
        Dr. Jones' section of archaeology.  I've
        heard he's the bestest.  [sic]

    Before:

        John writes:
        : Mary writes:
        : + Anastasia writes:
        : + > Hi all!
        : + Hi Ana!
        : Hi Ana & Mary!
        Please unsubscribe me from alt.hello.

    After "par Q+:+ q":

        John writes:

        : Mary writes:
        :
        : + Anastasia writes:
        : +
        : + > Hi all!
        : +
        : + Hi Ana!
        :
        : Hi Ana & Mary!

        Please unsubscribe me from alt.hello.

    Before:

        amc> The b option was added primarily to deal with
        amc> this new style of quotation
        amc> which became popular after Par 1.41 was released.
        amc>
        amc> Par still pays attention to body characters.
        amc> Par should not mistake "Par" for part of the prefix.
        amc> Par should not mistake "." for a suffix.

    After "par B=._A_a 50bg":

        amc> The b option was added primarily to
        amc> deal with this new style of quotation
        amc> which became popular after Par 1.41
        amc> was released.
        amc>
        amc> Par still pays attention to body
        amc> characters.  Par should not mistake
        amc> "Par" for part of the prefix.  Par
        amc> should not mistake "." for a suffix.

     






VimTip	{{{1 585: Keymap for normal mode


I generated a keymap for the vim 6.X normal mode on a german keyboard layout.
Keymaps for other layouts may follow, if someone tells me about how they look.
The keymap is here:
http://michaelsen.kicks-ass.net/bjoern/keymap.pdf

The author may be contacted here:
bjoern@michaelsen.kicks-ass.net







VimTip	{{{1 586: Smarter Pasting


Frequently I yank a few words or part of a line and like to have them pasted on a separate line. Vim provides the put and put! commands for that purpose but they are not mapped by default to anything.  Typing the commands is much slower than inserting a line and pasting to it so I have created the following maps:

nnoremap ,p :pu "<CR>
nnoremap ,P :pu! "<CR>







VimTip	{{{1 587: Preview current file in Mozilla through localhost


This is something I 'discovered'  whilst trying to preview html or php files in mozilla using the apache server locally.

Put the path as the first line of a file wrapped in the appropriate comments. 
eg: php:
<?php	// http://localhost/examples/chapter02/vieworders2.php	?>
eg html:
<!-- http://localhost/examples/chapter02/orderform.html -->

Place the following mappings in your .vimrc file 
" Typing <S-F12> will open the file in moz through the server.
nmap <S-F12> :sil! !start mozilla "<cfile>"<CR> 
imap <S-F12> <esc>:sil! !start mozilla "<cfile>"<CR>i

As I'm working through Wellings PHP and MySQL Web Development I can use my tokens plugin to speed creating the first line as follows:
 
Add these as the string parts of the array:
(for php)
"phpf <?php	// http://localhost/examples/chapter¤«  chapter?   »/¤«  file name  ».php  ?>"
(for html)
"htmlf <!--  http://localhost/examples/chapter¤«  chapter?   »/¤«  file name  ».html  -->"

then on the first line of the file if I type phpf <leader>et I'll only have to enter the chapter number and the filename without the extension. eg    04<cr>  orders<cr>
This will insert:
<?php	// http://localhost/examples/chapter04/orders.php	?>

Place the cursor anywhere on the file path, <S-F12> and the file will load (through apache) in moz.

Hope someone finds this useful,
Mark






VimTip	{{{1 588: How to sort using visual blocks


1. To sort lines based on a visually-selected column:

	Check out
	http://www.erols.com/astronaut/vim/index.html#VimFuncs ;
	look under "Visual Block Sorting".  It uses Piet Delport's
	vim-based binary insertion sort and some vim-glue to provide
	visual-block sorts!

	To enable it, put <bisort.vim> into your <.vim/plugin>
	directory.

	To then perform sorting based on a visual-block selection
	(ctrl-v):

		:'<,'>Vissort

2. To sort a visually-selected block (and leave the text outside the
   block in place):

	Check out
	http://www.erols.com/astronaut/vim/index.html#VimFuncs ;
	look under "Visual Block Commands".  The <vis.vim> plugin
	provides a command which allows other commands to be applied
	only to the visually selected block.

	To then perform sorting of just a visual-block (ctrl-v):

		:'<,'>B !sort

	Or, using Piet Delport's binary insertion sort:

		:'<,'>B Bisort

Examples:

	Original, visual-block select the central column
		one   two    three
		four  five   six
		seven eight  nine
		ten   eleven twelve

	:'<,'>Vissort
		seven eight  nine
		ten   eleven twelve
		four  five   six
		one   two    three

	:'<,'>B !sort
		one   eight  three
		four  eleven six
		seven five   nine
		ten   two    twelve

	:'<,'>B Bisort
		one   eight  three
		four  eleven six
		seven five   nine
		ten   two    twelve







VimTip	{{{1 589: Vim as refactoring tool (with examples in C#)


You can use vim as a refactoring tool.

The advantages are:

1. You automatisate repetitive writing tasks
2. You learn refactoring

You can expect much from a refactoring tool but if you have a look at the
commercial refactoring tools there is much (not all!) vim can do too.

Whatever your opinion is, my experience is that vim helps to refactor.

I give you three examples, all in C#.

Example 1:

Anti-sphagetti code weapon or the "Extract Method" refactoring.

Sphagetti code example:

public string CreateMenu(string startMenu,string file) 
{
	string strOutput = "";
	int i = 0;
	ArrayList startArray = new ArrayList();
	string strVariable = "";
	string strTemp = "";

	XmlDocument XMLDoc = new XmlDocument();
	try {
		XMLDoc.Load(file);
	}
	catch (Exception e) 
	{
		strOutput = e.GetBaseException().ToString();
		return strOutput;
	}

	XmlNodeList nodeList = XMLDoc.DocumentElement.ChildNodes;

	... 
	
Imagine 50 lines of code here.

Use the "extract method refactoring" to make a "composed method".

I use a vim function (see below) to build the exracted method.

I highlight the code part I want to extract and press \em (for e-xtract m-ethod).

A dialog appears and asks me how to name the new method.

I type in "GetXmlDocumentFrom" and do get this:

// = GetXmlDocumentFrom();
private GetXmlDocumentFrom()
{
	XmlDocument XMLDoc = new XmlDocument();
	try {
		XMLDoc.Load(file);
	}
	catch (Exception e) 
	{
		strOutput = e.GetBaseException().ToString();
		return strOutput;
	}
	// return ;
}

Now I have time to think what parameters the method needs and what to return.

I end up with the following function and  remove it from the original function:

private XmlDocument GetXmlDocumentFrom(string XmlFile)
{
	XmlDocument XMLDoc = new XmlDocument();
	string strOutput = "";
	try 
	{
		XMLDoc.Load(XmlFile);
	}
	catch (Exception e) 
	{
		strOutput = e.GetBaseException().ToString();
		ErrorMessage(strOutput);
	}
	return XMLDoc;
}

In the original code I put two lines.

XmlDocument XMLDoc = new XmlDocument();
XMLDoc = GetXmlDocumentFrom(XmlFile);

So I reduced the original code for 8 lines and made it clearer what the code does.

I do this with the rest of the code again and again.

Since the class gets bloated because of the many new methods I later will use
the "Extract Class" refactoring to put this method in an own XmlDocument-class.

This has the advantage that our new function is also available for other
similar purposes.

I will create the new class also with the help of vim, the actual extracting of
the method into the new class is just a matter of copy & paste.

Here is the vim-code:

vmap \em :call ExtractMethod()<cr>
function! ExtractMethod() range
	let name = inputdialog("Name of new method:")
	'<
	exe "normal O\<bs>private " . name ."()\<cr>{\<esc>"
	'>
	exe "normal oreturn ;\<cr>}\<esc>k"
	s/return/\/\/ return/ge
	normal j%
	normal kf(
	exe "normal yyPi// = \<esc>wdwA;\<esc>"
	normal ==
	normal j0w
endfunction


Example 2:

The "Self Encapsulate Field" refactoring.

I have heard a programmer who just uses Visual Studio (nothing against Visual
Studio, it's a great tool!) say: "I do not use properties. It's too much
work." He just uses fields instead.

With vim it is no problem to write a property, id est to use the "Self
Encapsulate Field" refactoring.

I write a name e.g. "Name" press CTRL-C CTRL-P CTRL-S (c-reate p-roperty with
s-tring).  Voila, the new property appears in just a second:

private string m_Name;
public string Name
{
	get
	{
		return m_Name;
	}
	set
	{
		m_Name = value;
	}
}

Here are the vim mappings and the underlying function:

"Create property
imap <C-c><C-p><C-s> <esc>:call CreateProperty("string")<cr>a
imap <C-c><C-p><C-i> <esc>:call CreateProperty("int")<cr>a

function! CreateProperty(type)
	exe "normal bim_\<esc>b\"yywiprivate ".a:type." \<esc>A;\<cr>public ".a:type." \<esc>\"ypb2xea\<cr>{\<esc>oget\<cr>{\<cr>return \<esc>\"ypa;\<cr>}\<cr>set\<cr>{\<cr>\<tab>\<esc>\"yPa = value;\<cr>}\<cr>}\<cr>\<esc>"
	normal 12k2wi
endfunction	

You can combine Visual Studio and vim. You can work in Visual Studio and load
the file in vim for refactoring. I have made a menu entry in Visual Studio that
loads the actual file I am writing in vim (cf. Tip #580 http://vim.sourceforge.net/tips/tip.php?tip_id=580).


Example 3:

The "Replace Conditional with Polymorphism" refactoring.

Imagine a switch and you want to replace it with an abstract class and some
concrete classes which inherit from this parent class.

You may think "Why should I replace this switch? It's too much work. Writing
all these classes ..."

With vim it's just a question of a few seconds.

To build the abstract class  I type, say  "Fruit". 
Then I press CTRL-C CTRL-A CTRL-C (c-reate a-bstract c-lass) and get

public abstract class Fruit
{
	public abstract void |();
}

| means the Cursor position.

Now I fill in the methods.

public abstract class Fruit
{
	public abstract void Taste();
	public abstract void Color();
	public abstract string GetSize();
}


Now I go on the first letter of "Fruit" and type CTRL-C CTRL-C CTRL-C (c-reate c-oncrete c-lass). 

A dialog appears and asks me for the new name of the concrete class. I type in Apple and get

public class Apple : Fruit
{
	public override void Taste()
	{
	}

	public override void Color()
	{
	}

	public override string GetSize()
	{
	}
}

I continue doing so with all the child classes of the abstract class.
In this way I get code templates that I can implement now.

Here are my mappings and the underlying funtion.

"Create abstract class
imap <C-c><C-a><C-c> <esc>bipublic abstract class <esc>A<cr>{<cr>public abstract void X();<cr>}<esc>:?X<cr>0fXs
"Create concrete class
map <C-c><C-c><C-c> :silent! call ImplementAbstractClass()<cr>

function! ImplementAbstractClass() range 
	exe "normal \<esc>\"yyw"
	/{
	normal "xy%
	normal %o
	exe "normal \<esc>o"
	let name = inputdialog("Name of new method:")
	exe "normal ipublic class " .name." : \<esc>\"yp\"xp"
	exe "normal }O}\<esc>=="
	normal %v%
	normal gv
	'<,'>s/abstract/override/g
	normal gv
	'<,'>s/;/\r{\r}\r/g
	normal ==
	normal %kdd%k
endfunction	


Happy vimming ... and happy refactoring!


Klaus











VimTip	{{{1 590: Using vim to send mail on windows


The question of using Vim for writing email messages with 
Vim on windows was raised many times.

Finally there *is* an elegant solution.

go to 
http://sylpheed-claws.sourceforge.net/win32/
and download 
sylpheed-0.9.6claws.exe
Install an application

go to menu 
configuration -> Common preferences
go to tab Other
and fill something like
c:\Progra~1\Vim\vim62b\gvim.exe -f "%s"
(depending on where your Vim is installed)
as the the editor option
The -f option is very important so Vim does not fork.

You might also go to Compose tab and select 
Automatically launch an external editor.

Tada.......

Beware
Sylphed-Claws is a bleeding edge software.

Have a nice time
Stano







VimTip	{{{1 591: Have a nice and easy use of plugins


Are you tired of hundreds of mappings and functions that pollute your .vimrc ? Do you want to
nicely organize your customization to quickly find what you search ? Perhaps is it time for you to
consider the use of plugins (if it is not already done).

Plugins are really easy to do and provide a simple way to organize functions and mappings. They are
automaticaly loaded

Here is an example of simple and very short plugin that provides a command MyCommand that saves the
selected text in the file passed in parameter.
I don't know if the function is useful but the example show the parameter passing, the
autocompletion and the use of ranges in a function.

Autocompletion is very practical to help to remember the commands you defined. It is often a
problem to remember all the mappings you've done so it may be faster to type your command than to
remember the mapping you've chosen.
Using user-commands allows you to use mappings only when it is absolutely pertinent

------------------ file MyPlugin.vim -----------------------
" save 'cpo'
let s:cpo_save = &cpo
set cpo&vim

" To Edit the Plugin
nnoremap <F12> :e $VIMRUNTIME/plugins/MyPlugin.vim
" To reload the plugin if you modify it
nnoremap <S-F12> :so $VIMRUNTIME/plugins/MyPlugin.vim

" It is very interesting to define commands to call your functions because you can then use
" autocompletion and other features you cannot use for usual functions
if !exists(':MyCommand')
    command -range=% -nargs=1 -complete=file MyCommand <line1>,<line2>call s:MyCommandFunction(<f-args>)
endif

" the ! allows you to modify the function and reload the plugin. It will be your new version that
" will be considered
function! s:MyCommandFunction(...) range
    split
    execute "norm " . a:firstline . "GV"
    execute "norm " . a:lastline . 'G"ay'
    enew
    norm "ap
    exe "sav! " . a:1
    q
endfunction

" restore 'cpo'
let &cpo = s:cpo_save
unlet s:cpo_save
---------------------End of file --------------------------

commented version of the function :

function! s:MyCommandFunction(...) range
    " create a temporary window
    split
    " select and copy the lines in the range passed (a:firstline and a:lastline are the vim
    " variables for the first and the last lien of the range
    execute "norm " . a:firstline . "GV"
    execute "norm " . a:lastline . 'G"ay'
    " create a new file and paste
    enew
    norm "ap
    " saves the file with the name passed in parameter
    " exe executes the string passed as a command
    " a:1 is the first parameter (if you have more, a:2, a:3. a:0 gives you the number of parameter
    " passed
    exe "sav! " . a:1
    " quit the temporary window
    q
endfunction


Of course you can separate your functions in different plugins (one for the mapping, one for the
functions...
You can use prefix to classify your functions and use the autocompletion more efficiently.

Where to find help on these subjects

General considerations on plugins
:help plugins

How to create a user-command and how to use the parameters (-range, -nargs, -complete...)
:help user-commands

How to program vim
:help eval.txt

all the buildin functions
:help functions 
How to define a function
:help user-functions







VimTip	{{{1 592: Smart <Home> and <End> keymaps


I found interesting the way <Home> and <End> keys act in some editors and I wondered why try not 
carry it out with Vim.
Put the following lines in your ~/.vimrc and so <Home> will move the cursor between the first column and
the first non-blank character. <End> is similar but work at the end of the line.
I think this should be very useful to the indented code and trailing characters.

let g:home_key = '0'
let g:end_key = '$'

function ToggleHome()
  exe "normal! \<Esc>".g:home_key
  let g:home_key = g:home_key == '0'? '^' : '0'
endfunction

function ToggleEnd()
  exe "normal! \<Esc>".g:end_key
  let g:end_key = g:end_key == '$'? 'g_' : '$'
endfunction

inoremap <silent> <Home> <Esc>:call ToggleHome()<CR>i
nnoremap <silent> <Home> :call ToggleHome()<CR>
inoremap <silent> <End> <Esc>:call ToggleEnd()<CR>a
nnoremap <silent> <End> :call ToggleEnd()<CR>






VimTip	{{{1 593: basic postfix abbreviations


     I'm learning VIM in order to be more competitive in online programming competitions where speed of accurate typing is a factor. This may be a basic tip for some more advanced VIM users out there. I'm very used to editors that provide prefix abbreviation expansion; for example, in jEdit I'd type FA,array,<C-ENTER> in order to make a basic for loop that scanned the array. I wanted this in VIm as well, but found that it was harder to program. When I discovered that I could use a postfix abbreviation instead of a prefix one, I realized that I really didn't need any programming, but rather a long :ab statement like this:

"this is for java, c++,c# can reshape as necessary
:ab ff <ESC>^d$ifor(int i=0;i<<ESC>pi.length;i++){<CR><CR>}//end for loop over array <ESC>pi[i]<ESC>==k==k==ji<TAB>

this way, if I need a loop over the array lines[] then I would type
lines<SPACE>ff<SPACE> and vim would transform this into (with proper indentation)

for(int i=0;i<lines.length;i++){
        <CURSOR>
}//end for loop over array lines[i]

similar abreviations with multiple arguments could be delimited by spaces and could be yanked into multiple registers and plunked down as necessary. You could even use a similar structure to writing abbreviations in jEdit. But, this opens up possibilities for many different things, because VIM allows you to map real commands into the abbreviations, instead of just vanilla text like in jEdit. 







VimTip	{{{1 594: Lookup javadoc HTML help from vim


Do you use VIM for lot of Java Coding, but miss the feature of looking up
javadoc help like some other Java based IDEs ?
Well I have written I plugin to do just that, right now its in an infant state, but
can lookup javadoc html of a java Class, from VIM
get it at
http://vim.sourceforge.net/scripts/script.php?script_id=801
Please leave any comments , notes, feature request on this tip or
email me at vim_power@yahoo.com
thanks






VimTip	{{{1 595: suppressing file changed warnings in a specific buffer


I generally liked the warnings that VIM gives when a file changes outside of the editor. However, there are times when I want to run a shell command that changes the buffer, and I don't want to hear about it.

I've come up with the following convoluted method to do this, but if there's a better way, I'd love to know.

function ChangeThisBuffer
    "set an environment variable to current buffer name
    let $aucfile = expand( "%" )
    "add autocmd which only applies to this buffer which removes itself once it runs once
    autocmd FileChangedShell $aucfile autocmd! FileChangedShell $aucfile
    execute( 'silent !mycommand' )
endfunction

One problem with this approach is that if the shell command fails, or doesn't really change the file, then you won't be notified the <b>next</b> time it changes.







VimTip	{{{1 596: Insert location of the currently edited file


With 
:imap <C-r>@ <C-r>=expand("%:p:h")<cr>







VimTip	{{{1 597: indet a code block - >i{


Let's say we have:
// some code
{ // start block
//some other code
// HERE IS THE CURSOR
// other code
} // end block

The command ">i{" will indent the current block of lines, inside {}.
The { and } are unmodified.
The ">a{" will modify also the { } lines.

"<i{" will shift to the left (let's say UNindent).
Similar "<a{"

Hope this helps.






VimTip	{{{1 598: (PHP) on line help


Hi,
vim is my favorite; so, I use it for .php file.
Very often I need the php manual to see the parametrs order for functions. 
Unitl a month ago I always opened a browser and gone to http://http://ro.php.net/FUNCTION_NAME
for example http://ro.php.net/printf .

A month ago I have discovered  
set keywordprg=a_script

What it does:
default, when you ar with the cursor on a WORD and press K (SHIFT+k) in `command mode',
the vim will run 'man WORD'.
If you set keywordprg=a_script,  the  vim will run `a_script WORD'

So I have 
set keywordprg=/home/marcel/php_doc
and php_doc looks like:
#######
#!/usr/bin/bash
links http://www.php.net/$1
#######
And now I have the online help

`links' is a text browser for *nix, http://links.browser.org/
Of course you can use the `lynx'.


Hope this helps






VimTip	{{{1 599: vim plugin for clearcase


The ccase.vim vim clearcase plugin is very useful. But there is a bug in clearcase, if you are doing multisite development, even if you checkout file unreserved, it still hold the mastership. So your partner on other side still cannot checkin code. 

The default unreserved checkout swith on ccase.vim is "-unreserved", need to change to "-unreserved -nma".






VimTip	{{{1 600: Copy current file name into windows clipboard


Sometimes I need to use a file name that I'm editing in other applications (compiling, attaching to e-mail, referencing in document) etc.
I found these two mappings to be useful for copying file name to the windows clipboard.

Inside VIm I do ",cs" or ",cl"  and then simply paste into other document using regular windows paste command. The mappings work in normal mode.
,cs is used to copy just the file name
,cl is used to copy file name including the full path

nmap ,cs :let @*=expand("%")<CR>
nmap ,cl :let @*=expand("%:p")<CR>







VimTip	{{{1 601: Tag with line:column


Tags allow us to jump to a particular line,
but I needed to get to the exact column also,
eg. when I have many tags on one long line.

This is not possible with the tag format, however
with Vim's regexp extensions, I am able to generate 
and use such tags, eg:

> tail -1 ./tags

main	mohsin.c	/^\%89l\%12c/ ;" Goto line 89, column 12.   






VimTip	{{{1 602: How to remove one mark or all marks at once


To remove a mark you can use \mh in normal mode. Go to the mark and type \mh.

If you are using marks in a script you can use the function below.
Then you would write e.g.

function! MyFunction()
	...
	kl "set mark l
	...
	"do something
	...
	call RemoveMark("l") "Mark l is no longer used, remove it
	...
endfunction 

Here is the function:

function! RemoveMark(mark)
	try 
		exe "normal '" . a:mark "go to the mark
		normal \mh "remove it
	catch
	endtry	
endfunction	

If you want to remove all  your marks in normal mode you can use the mapping
map \rm :call RemoveMarks()<cr>

It calls the function:

function! RemoveMarks()
	try 
		call RemoveMark("a")
		call RemoveMark("b")
		call RemoveMark("c")
		call RemoveMark("d")
		call RemoveMark("e")
		call RemoveMark("f")
		call RemoveMark("g")
		call RemoveMark("h")
		call RemoveMark("i")
		call RemoveMark("j")
		call RemoveMark("k")
		call RemoveMark("l")
		call RemoveMark("m")
		call RemoveMark("n")
		call RemoveMark("o")
		call RemoveMark("p")
		call RemoveMark("q")
		call RemoveMark("r")
		call RemoveMark("s")
		call RemoveMark("t")
		call RemoveMark("u")
		call RemoveMark("v")
		call RemoveMark("w")
		call RemoveMark("x")
		call RemoveMark("y")
		call RemoveMark("z")
	catch
	endtry	
endfunction	

Could you think of other possibilities?
Please share it with us.

Note:
I am using the try-catch clause so the following works only for >= vim 6.2.
If you want to use the functions for an older version remove the try-catch
clauses.


Happy vimming

Klaus








VimTip	{{{1 603: Bookmarks as menu item


I like to save location of files I am editing
in a bookmark file. Each bookmark shows up as a 
menu item.

Add the attached lines to ~/_vimrc, and the Bookmark->Add
menu items will appeare in gvim (I use it on Windows/NT).

Note: I used cmd.exe,sh.exe,echo.exe to write the bookmark
to a file, it is tricky to get the quotes right.
It would be whole lot easier if vim had a function
append-register-or-string-to-file. Maybe someone can
find a way to do this without external shells?

- Mohsin (mosh.cs.albany.edu)

:set shell=sh shellslash shellcmdflag=-c shellxquote=\" shellpipe=\|\ tee
:amenu Mo2.BookMarks.Add
                \ :let @b='\\042 Bookmark: '.
                \    " DATE=".strftime("%Y-%b-%d_%X").
                \    " PWD=".escape(getcwd(),'\').
                \ escape("\\n",'\').
                \ ":amenu Mo2.BookMarks.".
                \ escape(escape(expand("%:t"),'.\'),'\').
                \ ' :sp +'.line(".").' '.
                \ escape(expand("%:p"),' \')<CR>
                \ :exe ':!(echo '.@b.' >> $HOME/bookmark.vim)'<CR>
                \ :so $HOME/bookmark.vim<CR>

:amenu Mo2.BookMarks.Edit :sp $HOME/bookmark.vim<CR>
:amenu Mo2.BookMarks.Load :so $HOME/bookmark.vim<CR>
 
if filereadable(expand("$HOME/bookmark.vim"))
    :amenu Mo2.BookMarks.-Sep-	:
    :so $HOME/bookmark.vim
endif

  






VimTip	{{{1 604: Doing <enter> in nmode


Although very simple, I think this is nifty:

:nmap <enter> _i<enter><esc>

Now one can press enter in normal mode to insert an empty line. This spares me from alot of typing.






VimTip	{{{1 605: replace a word with the yanked text


I often need to replace a word with the yanked text when programming, so I add this map:

map S diw"0P

I rarely use S command, because it's equal to cc.






VimTip	{{{1 606: Seeing the man pages while being in VIM


You can see the man pages of anything you want from VIM. No need to exit VIM. Just put the cursor under the word.and press shift+k (Capital K) and you will be in the man page section. when you are through just press 'q' and you will be out of VIM. Press enter to come back to VIM.






VimTip	{{{1 607: Opening gvim atop a console window


I like to have gvim open atop the current xterm I'm using, rather
like a vim console would.  Here's some Korn shell script for
setting up a function "gv" which queries X for the current window's
geometry and adjusts the window for the current fontsize, borders,
and menu region.

Admittedly the adjustments for that vary with border sizes, etc,
so you'll likely need to adjust x,y,w,h in the Adjustments section.

Usage:  gv files, options, etc

# =======================================
# gv: gvim covers starting console window 
function gv
{
if [[ "${WINDOWID}" = "" ]]; then
 echo "***error*** unknown window id!"
 return
fi
xwi=$(xwininfo -id $WINDOWID)
xyposn=${xwi##*Corners:  }
xyposn=${xyposn%% -*}
wh=${xwi##*geometry }
wh=${wh%+0+0}
integer x y w h
x=${xyposn%+[0-9]*}
y=${xyposn#+[0-9]*}
w=${wh%x*}
hh=${wh#*x}
h=${hh%[-+]*}
# ----------------------------
# Adjustments:
#   x,y in pixels
#   w,h in characters
# ----------------------------
# for RH8 Linux, GTK, courier-12-r
h=h-4
x=4
y=y-18
# ----------------------------

# invoke gvim
gvim -geometry "${w}x${h}+${x}+${y}" $*
}
# =======================================







VimTip	{{{1 608: Evaluate current line (or pease of line) using Python


Pyhton language has more powerfull evaluation functions than vim editor. If you have need to evaluate some by python you can use command

:py print 2*2

(see :help :if_pyth.txt)
But I can tell you more pleasant example. Write in your .vimrc file followings:

=== begin paste ========
python << EOL
import vim
# do not say from vim import * beacuse this instraction
# delete builtins function eval
def EvaluateCurrentLine(*args):
	cur_str = vim.current.line
	action, symb = None, None
	for i in args:
		if i in ["r","p"]: action = i
		else:              symb   = i
	try:    start = cur_str.rindex(symb)+len(symb)
	except: start = 0
	result = eval(cur_str[start:],globals())
	if action == "r":
		vim.current.line = cur_str[:start]+str(result)
	else:
		print result
EOL
command -narg=* PyEv python EvaluateCurrentLine(<f-args>)
=== end paste ============

Be carefull about identation in python part. This text provide command
:PyEv
This command evaluate expression in line under cursor and print result in echo area. With r argument
:PyEv r
evaluate expression and replased it by resalt of evaluation. And other arg in argument searching the arg backword from the end of current line and evaluate followed expression. For example: let we have string
\setlength{\textwidth}{450-63
:PyEv r {
\setlength{\textwidth}{387







VimTip	{{{1 609: Execute python from within current file


Inspired by vimtip #608.

To execute python from a range within the current text file and write the output to that file (replacing the python), add the snippet below to .vimrc (or other suitable *rc file).

Requires a 'proper' python setup so that the imported modules can be found.

I find it a handy intermediate step between using the python interpreter on command line and running a complete script. Can be used for easy buffer manipulation, filtering input, preprocessing text and templating-like tasks.

def PyExecReplace(line1,line2):
    r = vim.current.buffer.range(int(line1),int(line2))
    redirected = cStringIO.StringIO()
    sys.stdout = redirected
    exec('\n'.join(r[:]) + '\n')
    sys.stdout = sys.__stdout__
    output = redirected.getvalue().split('\n')
    r[:] = output[:-1] # the -1 is to remove the final blank line
    redirected.close()
EOL
command -range Pyer python PyExecReplace(<f-line1>,<f-line2>) 

Some examples of use:
Simple
------
print 2 + 2
:Pyer
(if cursor is on the 'print' line, replaces line with 4)

Filter
------
for line in vim.current.buffer:
    if line[0] != '\t':
        print line
:%Pyer
(filters out lines beginning with a tab in the current buffer)

Inserting time
--------------
import time
print time.ctime()
:%Pyer
(replaces line with date/time)

Getting web content without tags
-------------------------------
import urllib2,htmllib,formatter
h = htmllib.HTMLParser(formatter.AbstractFormatter(formatter.DumbWriter()))
h.feed(urllib2.urlopen('http://www.somesite.com').read())
:%Pyer
(inserts the web page text, but not the html tags, for a given site)

I also use a slightly modified version that appends the output, leaving the python intact.






VimTip	{{{1 610: Saves you frequent typings of certain words.


You can use VIM's autocomplete feature in insert mode. Just edit the .vimrc file and add this lines

iab <key> <expansion>
<key> is the letter which should be expanded to <expansion>

Example: 
              iab #i #include          ( typing "#i" and space will be expanded to "#include")
              iab #d #define           ( typing "#d" and spacet will be expanded to "#define")
              iab s struct               (typing  "s" and space will be expanded to "struct")
              iab t typedef           ( typing "t" and space  will be expanded to "typedef")

You can add your custon expansion words.

PITFALLS:
                  In some cases VIM expands a letter automatically you dont want. You have to take care of that. But this is a good utility.






VimTip	{{{1 611: Open big files and work fast


When opening big files, having no swap file and no undo levels speeds up Vim dramatically.  Here are lines to set that up automatically beyond a given file size threshold (BufSizeThreshold):

let g:SaveUndoLevels = &undolevels
let g:BufSizeThreshold = 1000000
if has("autocmd")
    " Store preferred undo levels
    au VimEnter * let g:SaveUndoLevels = &undolevels
    " Don't use a swap file for big files
    au BufReadPre * if getfsize(expand(<afile>)) >= g:BufSizeThreshold | setlocal noswapfile | endif
    " Upon entering a buffer, set or restore the number of undo levels
    au BufEnter   * if getfsize(expand(<afile>)) < g:BufSizeThreshold | let &undolevels=g:SaveUndoLevels | hi Cursor term=reverse ctermbg=black guibg=black | else | set undolevels=-1 | hi Cursor term=underline ctermbg=red guibg=red | endif
endif

Many thanks to Antoine and Chip, and to Ron who triggered the thread on vim@vim.org.

William

PS: I have not done a search for big file handling tips...
PPS: we could also disable syntax highlighting and restore it for small files, but I just thought about it now.






VimTip	{{{1 612: save a nanosecond with marks


Instead of marking all the time with "ma", mark with "ml".  When you need to return to the mark, `l is a little quicker to type than `a.  

If you save a fraction of a second many times, you'll have saved as much time as it took to read this tip!






VimTip	{{{1 613: open last edited file, AKA lvim for bash


The starting.txt help file (http://vim.org/htmldoc/starting.html) tells you how to open the last edited file in csh. In bash, do it like so:

alias lvim='vim -c "normal '\''0"'






VimTip	{{{1 614: perldoc function and module keyboard mappings


" put the cursor over a perl function and try backslash-pf to see perldoc
:nmap <Leader>pf :!perldoc -f <cword><CR>

" put the cursor over a perl module name and try backslash-pd to see perldoc
:nmap <Leader>pd :e `perldoc -ml <cword>`<CR>

" see ':help mapleader' for more info... default is backslash.






VimTip	{{{1 615: Moving to the next word in insert mode


You can move to the next word in insert mode using <shift> <right arrow key>
You can move to the next word in command mode using w

You can move to the previous word in insert mode using <shift> <left arrow key>






VimTip	{{{1 616: Have Vim check automatically if the file has changed externally


You can place this in your vimrc file, and then run:
:CheckForUpdates

This will toggle the behaviour for the given buffer.

" If you are using a console version of Vim, or dealing
" with a file that changes externally (ie a web server log)
" then Vim does not always check to see if the file has been changed.
" The GUI version of Vim will check more often (for example on Focus change), 
" and prompt you if you want to reload the file.
" 
" There can be cases where you can be working away, and Vim does not
" realize the file has changed.  
" 
" This function will force Vim to check more often.
"
" The function will turn on the :checktime command so that the
" file is checked based on the CursorHold event.
" 
" Thanks to Jürgen Krämer, Antoine J. Mechelynck for the help.
"
" CheckForUpdates will toggle the behaviour on the current buffer.
function! CheckForUpdates() 

    " Save the current default register
    let saveB=@"

    " Check to see if the checkforupdates autocommand exists
    redir @"
    silent! exec 'au checkforupdates'
    redir END

    if @" =~ 'E216'
        augroup checkforupdates 
        if has("win32")
            " will do this except for file paths that contain spaces -- and if
            " you are on Windows, backslashes should be converted to slashes,
            " too:
            exec "au Cursorhold " . escape(
                        \ substitute(expand("%:p"), '\', '/', 'g')
                        \ , ' ') . " :checktime"
        else
            exec "au Cursorhold " . expand("%:p") . " :checktime"
        endif
        augroup END
    else
        " Using a autogroup allows us to remove it easily with the following
        " command.  If we do not use an autogroup, we cannot remove this 
        " single :checktime command
        " augroup! checkforupdates
        au! checkforupdates 
        augroup! checkforupdates 
    endif

    let @"=saveB
endfunction
command! CheckForUpdates :call CheckForUpdates()







VimTip	{{{1 617: Fun with case twiddling


Someone came on #vim asking about "sentence case", meaning Capitalization Of Every Word.

I came up with some bad solutions before learning this:

:s/\(^\|\s\)\([a-z]\)/\1\U\2/g

This inspired me to come up with a silly script for rotating between ALL CAPS, all lower, and Sentence Case.
MiXed Case is set to UPPER.

Then I mapped it (in visual mode) to ~, thus breaking the wonderful tilde :)

Here's the script:

fun! TwiddleCase(str)
	if a:str == toupper(a:str)
		let ans = tolower(a:str)
	elseif a:str == tolower(a:str)
		let ans = substitute(a:str,"\\(^\\|\\s\\)\\([a-z]\\)","\\1\\U\\2","g")
	else
		let ans = toupper(a:str)
	endif
	return ans
endfun

And the mapping:

vmap ~ x:call setreg('"', TwiddleCase(getreg('"')))^MP






VimTip	{{{1 618: how to make and submit a patch


     Vim is developed using an open-source model, and users are encouraged to contribute to its development.  Users with programming experience should have a look at the to-do list from time to time (:help todo), and even beginners can help by asking and answering questions on the mailing lists, adding tips to this database, and suggesting improvements to the documentation.  (IMHO, if you get a question answered on one of the lists, a good way to repay the Vim community is by posting the answer as a tip here.)  Even rating tips and scripts on the vim web site helps others, by pointing them to the most useful ones.

     Another way to give back to the community is to support vim's charity:

:help uganda

     Here is how to make a patch.  Make a local copy of the file you are going to change, and edit it.  Then, change to the directory (such as vim62/) containing the src/ source directory.  If you are editing one of the help files and do not have the vim source files, change to your $VIMRUNTIME directory (usually /usr/local/share/vim/vimxx/ on *NIX systems).  Use the diff program to make the patch like this:

$ diff -c /src/eval.c path/to/my/eval.c > /tmp/eval.c.diff

for a patch to the source or (assuming you do not have the sources)

$ diff -c doc/help.txt path/to/my/help.txt > /tmp/help.txt.diff

The directory and file name for the patches are just suggestions.  If you change more than one file, you can concatenate the patches or read the man page for diff to create one big patch.

     If you are on a Windows system that does not have the diff program, you may be able to get one from http://gnuwin32.sourceforge.net/ .  (I have not used Windows for a while now, so I have not tried this.)  If the usage is substantially different from the above, perhaps someine will be kind enough to add a comment below explaining this.

      The -c option produces a "context diff."  This is fairly easy for both humans and machines to read, and all official patches for vim are released in this form.

     Once you have your patch, you can submit it to the vim-dev mailing list.

:help vim-dev

or

http://www.vim.org/maillist.php#vim-dev






VimTip	{{{1 619: HowTo make a keymap


The present tip explains how to make a keymap for yourself. It is based on what is said under

    :help mbyte-keymap
    :help keymap-file-format

and you'll also find relevant information under

    :help 'keymap'
    :help 'iminsert'
    :help language-mapping
    :help <Char>

*1*  How to name the file and where to place it.

Keymaps reside in the "keymap" subdirectory of the directories named in 'runtimepath'. Their names are of one of the forms

    <keymap>.vim
    <keymap>_<encoding>.vim

so if you need keymaps for Czech and Norwegian, and want to use them under UTF-8, you will probably create two keymaps, named, for instance, "czech_utf8.vim" and "norwegian_utf8.vim". If those names collide with names already present in $VIMRUNTIME/keymap/, then either use slightly different names before the underline, or put them in the "keymap" subdirectory of a directory named earlier than $VIMRUNTIME in 'runtimepath', so yours will be found first (but in the latter case you won't be able to use the default keymap of the same name). Create the needed directory if it doesn't exist yet.

*2* What a keymap consists of.

A keymap consists of three parts:

a) a Vim script

b) a line containing only the word "loadkeymap" (without quotes)

c) the key mappings themselves.

*3* First part of a keymap: the Vim script.

This may contain any Ex-commands and Vim comments germane to the use of the keymap. In particular, the following Ex-commands are useful:

a) If this keymap is only a slight modification of another, preexisting one: a "source" statement for the keymap on which this one is based. Then you will only have to code the changes.

b) A short name, for instance in a keymap for Czech

    let b:keymap_name="cz"

This will appear as <cz> near the right end of the standard status line for any window where the keymap in question is enabled (by having its long name set ot setlocal'ed in 'keymap' and 'iminsert' setlocal'ed to 1).

c) A cursor color for when keymaps are in use. This one is more controversial (Bram comments it out in published keymaps) but I find it useful in my "private" ones.

    highlight lCursor ctermbg=red guibg=red

Use any color that pleases you, and beware that highlight groups are global for the whole of Vim, so it is possible to use different keymaps in split windows of a single Vim instance, but not different language cursor colors, unless you set up an autocommand to change the lCursor highlight at the WinEnter event. (How to make that work is outside the scope of this HowTo.)

*4* Second part: the "loadkeymap" command.

This is just to tell Vim that whatever comes after, to the end of the file, is a series of language-mappings, in a special format which will be described hereafter.

*5* Third part: The mappings themselves.

Each key mapping line consists of three parts; the optional third one may contain spaces but not the first two:

    {lhs}    {rhs}    [comment]

Vim interprets this line as if (in a standard Vim script) there had been

    lmap    <buffer>    {lhs}    {rhs}

The {lhs} is what you press, as interpreted by your default (English) keyboard. It is usually a single character, but it may be more than one: in that case all of them but the last act as "dead keys". For instance, in a German keymap, you may want to use the colon as a prefix to tell that the following vowel gets an umlaut (so that :A maps to Ä, :a to ä etc.)
Any key or key combination which does not appear as an {lhs} keeps its "English" meaning in the target language. (This will usually be the case for the space bar :-) and for any punctuation, or even letters, that you don't want to move about on the keyboard.) This means that if, for instance, you map the sz letter pair to the German eszet, you'll still be able to use the small-s letter with its usual meaning whenever it is not followed by z. Similarly, if you map the colon as above, a colon remains a colon if followed by anything other than a vowel, for instance a space or a digit.
In all cases, you can force the initial key(s) of a mapping to keep their original meaning, either by waiting for the mapping to time out, or by moving the cursor about, for instance with <Left><Right>.

The {rhs} is what it translates to, in the target language. For UTF-8 the {rhs} may be of the form <Char-0> to <Char-2347483647> (decimal), or <Char-0x0> to <Char-0x7FFFFFFF> (hex), or <Char-00> to <Char-017777777777> (octal) -- see ":help <Char>". For other encoding targets, the <Char> notation may also be used, but of course only as far as the target permits: e.g. in 8-bit encodings, only till 255 / 0xFF / 0377.

The [comment] is the easiest: it's for the human reader of the keymap, not for Vim.







VimTip	{{{1 620: getting to know the function prototypes


Use "[ i" for display of function prototypes at bottom or "[ ctl i" for jumping to the file containing the prototype. also can use " I" for listing of proto.






VimTip	{{{1 621: Vim as a syntax highlighting engine for web publishing


Geoff Richards has written a Perl module to turn Vim into a highlighting
engine for the web. 
Text::VimColor (http://search.cpan.org/perldoc?Text::VimColor).

See some basic usage at http://www.perlmonks.org/index.pl?node_id=314528
where I also show a caching module to improve Text::VimColor performance.

Enjoy

gmax






VimTip	{{{1 622: Deleting a buffer without changing your window layout


Here's a small command for your <.vimrc>:

    com! Kwbd let kwbd_bn= bufnr("%")|enew|exe "bdel ".kwbd_bn|unlet kwbd_bn

To use it, type   :Kwbd

Kwbd stands for:  Keep window (layout) and delete the associated buffer.







VimTip	{{{1 623: External Paste Buffer


We are forever using copy and paste to copy information from application to application. Inevitably however we need to edit/reformat the buffer contents . This tip allows you to quickly open a separate VIM containing just the paste contents. You may then edit these contents as required, writing or closing VIM automatically causes the changed contents to be rewritten to the paste buffer.

The following is a CygWin script (could just as easily be a Win32 batch file)

function vxp
{
# description : Edit paste contents
gvim -c 'normal ggdG"*p' c:/aaa/xp 
}

Such that I just type vxp and it opens a new Vim just containing the
current paste buffer.

To automatically cause the rewriting of the paste buffer add the following to your .vimrc

autocmd bufWritePost c:/aaa/xp normal ggVG"*y

(Thanks to Bob Chan et al from comp.editors)







VimTip	{{{1 624: Insert template files into buffer ( HTML editing for example)


While editing HTML I want to use template files to be expanded on my html pages. Say for example I have something like this on my html file:

<!--"header.html"-->
<p>html code here</p>
<p>more html code here...</p>
<!--"footer.tml"-->

I want the files "header.html" and "footer.html" to be inserted on my page, you can do this with the following global command:

:g%<!--"\w\+.\w\+"--\>%exe ":r " . matchstr(getline("."), "\\w\\+\\.\\w\\+")









VimTip	{{{1 625: Typing print statements faster and more ergonomically (esp in C++)


Guess what the most common word is in the C++ language? I wager it is 'cout'.

Interactive debuggers and logging libraries are all very well, but most of us still have in our debugging toolboxes the technique of adding short-lived statements to our programs whose only purpose is to help us figure out the bug currently occupying us by printing the value of a variable. If you find yourself often typing such statements they are worth optimizing for.

For example, strings in most languages are surrounded by double quotes which require an extra motion and keystroke for the left shift key. With my coding style I multiply that motion towards the shift key by 4-6 times per print statement and 10-100 print statements everyday. The result is to significant slow me down and bring me closer to the Home for the Aged Wrist. The analogous cout statement in c++ is even more egregious in this regard. Consider statements like the following that I frequently find myself typing:

cout << "AAA: " << someVarName << ": " << someOtherVarName << "\n" ;

That's *12* times my left hand moves towards the shift key for *one* statement! Unacceptable. My solution is to remap keys to interchange '<' and ',' as well as double quotes and single quotes. Rather than force myself to learn a new keyboard mapping within vim I cause the mappings to trigger in a context-sensitive mannter, within only a cout statement, from the time I type 'cout' to the time I type the ';' in the end.

Here's my code fragment to do this:
function! CppSetupCout ()
    inoremap , <Space><<
    inoremap < ,
    inoremap ' "
    inoremap " '
    imap ; <Esc>:call CppResetCout ()<CR>a;
    map <Esc>, :call CppResetCout ()<CR>
    imap <Esc>, <C-o>:call CppResetCout ()<CR>
endf
function! CppResetCout ()
    iunmap ,
    iunmap <
    iunmap '
    iunmap "
    iunmap ;
    imap <Esc>, <C-o>:call CppSetupCout ()<CR>
    map <Esc>, :call CppSetupCout ()<CR>
endfunction

function! AuCpp ()
    inoremap cout <End><Esc>:call CppSetupCout ()<CR>acout <<
    imap <Esc>, <C-o>:call CppSetupCout ()<CR>
    map <Esc>, :call CppSetupCout ()<CR>
endfunction

autocmd FileType cpp call AuCpp()

Notice that I use <Esc>, (or Alt-,) to quickly toggle these mappings on or off in other situations.

For some other languages it's prob sufficient to simply switch single- and double-quotes. Java might call for switching '+' and '=' within system.out.println. Come to think of it:

autocmd FileType java iabbrev sop system.out.println

You get the idea.






VimTip	{{{1 626: open vimrc file


I edit my _vimrc file on a frequent basis. 
I usually browse for the file then select it, but this can be a bit tedious so I made command that loads the file into a new window
Put this line into your _vimrc file
:com Openvimrc :new c:\vim\_vimrc

adjust the path as necessary - this assumes win32 platform
So now you can just  go ':Openvimrc' and you get the file to edit.






VimTip	{{{1 627: Customizing ftplugin, syntax etc. (eg for TeX)


    
It is possible to customize the default environment that vim
provides (based on filetype).  In older versions of vim (5.x),
this was done with a "myfiletypefile" file.  In newer versions,
one customizes by adding files to the appropriate subdirectory
under the vimfiles directory. 

For example, to customize the default TeX environment (of 6.1), 
I added the following ftplugin and syntax files:

"--------------------------
" vimfiles/ftplugin/tex.vim
"--------------------------
if exists("b:did_myftplugin")
  finish
endif
let b:did_myftplugin = 1

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Allow "[d" to be used to find a macro definition:
" Recognize plain TeX \def, \gdef, \let and \font 
setlocal define=\\\\def\\\\|\\\\gdef\\\\|\\\\let\\\\|\\\\font\\\\|\\\\\\(re\\)\\=newcommand{
"---*---*---*---*---*---

"--------------------------
" vimfiles/syntax/tex.vim
"--------------------------
if exists("b:did_mysyntax")
  finish
endif
let b:did_mysyntax = 1
"hilight 1 true in, 1truein, 1 truein, 1true in, 1in, 1 in, 1.1 truein, etc.
syn match  texTrueLength	"\<\d\+\(\.\d\+\)\=\(\ *true\ *\|\ *\)\
                                             \(\ *pt\|\
                                               \ *he\|\
                                               \ *bp\|\
                                               \ *cc\|\
                                               \ *cm\|\
                                               \ *dd\|\
                                               \ *em\|\
                                               \ *ex\|\
                                               \ *in\|\
                                               \ *mm\|\
                                               \ *pc\|\
                                               \ *pt\|\
                                               \ *sp\)\>"

if version >= 508 || !exists("did_c_syn_inits")
  if version < 508
    let did_c_syn_inits = 1
    command -nargs=+ HiLink hi link <args>
  else
    command -nargs=+ HiLink hi def link <args>
  endif

  HiLink texTrueLength	Number

  delcommand HiLink
endif
"---*---*---*---*---*---
    






VimTip	{{{1 628: Execut "things" in Win98 from within VIM


      
The following mappings help to execute "things" in win98.

1) If you are editing a file (eg, html file) file and want 
   to view it, the mapping \xf will do it.

2) If you want to execute the string under the cursor (<cWORD>):  

        The mapping \x executes the <cWORD> "as is", whereas 
        the mapping \xl executes it after pre-pending it with the 
        full path to the current file.

Example for \xf -- viewing an html file while editing it.

Example for \x -- the string under the cursor can be a google 
search for the word mail on this web-site:

http://www.google.com/search?q=mail+site:vim.sourceforge.net

(It can also be things such as the name of a file (foo.pdf, 
foo.bat) or directory etc.) 

"__________________________________________
"The mappings:

" eXecute File being edited
nmap \xf  :silent !start rundll32 url.dll,FileProtocolHandler %:p <CR>        

"eXecute string below cursor
nmap \x   :silent !start rundll32 url.dll,FileProtocolHandler <cWORD> <CR>        

" eXecute string below cursor after prepending it with path to file
nmap \xl  :silent !start rundll32 url.dll,FileProtocolHandler %:p:h/<cWORD> <CR>        

"__________________________________________
See:
  help  filename-modifiers
  help  <cWORD>
   






VimTip	{{{1 629: After quitting VIM, comeback to the same file position where you were while quitting.


many a times while editing a big file we may temporarily want to go to command prompt and 
open the same file again. Then again you will be in the first character of the file. This is a smarter tip for 
taking the cursor to the same position where you were while quitting.

Just when you want to quit VIM instead of pressing ESC :q   just press ctrl+z. You can see this 
[1]+  Stopped                 vim <filename>

you are in command prompt now. Do your work and when u want to return to VIm press fg.

Thats it.






VimTip	{{{1 630: usefull for  programming


Hello,

I was looking for that feature for the very long time.

I use vim for programming and I always keep forgetting about closing the parents, quotes etc.

I wanted to remap the keyboard in insert mode in that way that when I open a quote or parent I will get the closing one and the cursor would be placed between these two characters.

here is the stuff I put in my ~/.vimrc file 
<pre>
:imap ( ()<Left>
:imap [ []<Left>
:imap " <C-V>"<C-V>"<left>
</pre>

I had to use <C-V> to avoid recursive mapping of the " character.

Maybe there is the feature build in vim already but I couldn't find it :)

Every comment is welcome :)








VimTip	{{{1 631: Disabling IME input in Windows


Often, your Windows locale will reflect a foreign country (e.g. Japan) so you can write text in another character set, but you don't want Vim to do that by default. It is annoying to have to disable IME input every time you start up Vim. But it's much easier than that. Simply add this line to your vimrc (usually at C:\vim\_vimrc):

set iminsert=0

Now, you will start out in regular Roman input mode, without IME. Enjoy!






VimTip	{{{1 632: Setting the font in the GUI


This tip concerns the setting of the 'guifont' option. It is assumed that 'guifontset" and 'guifontwide' will, if available, be left empty or set to a non-conflicting value. Of course, this apples only to the GUI, since the font for 'console' vim is determined by the particular terminal or terminal emulator being used.

Background
----------

1. As of this writing (January 2004) there are 3 different possible formats for the 'guifont' option, namely GTK+2, other-X11 and other. Each version of the GUI accepts only one of them.

2. Some versions allow selecting the font by means of a menu, using

    :set guifont=*

However, the result is usually too restrictive.

3. Most versions allow setting an option by editing the current value, using

    :set guifont=<Tab>        (if 'nocompatible'), or
    :set guifont=<Ctrl-E>     (if 'compatible')

The current value appears, with escaping backslashes if and where needed. Change what you want to change, write it down so you can later enter it in your vimrc if you find out that you like it, then press <Enter> to accept the new result.

How to proceed
--------------

The default value for 'guifont' is the null string. However, a default or system vimrc may already have set some value. If what you see is "almost" what you want, use method 3 above. If the current value is empty, you will have to proceed in some other way. In that case, press <Esc> to leave command-line mode.

If the current value is empty, or if the current font has neither the shape nor the size that you want, try method 2 above. If it doesn't work, copy the code snippet found at the end of this tip into your vimrc and start from there, changing one thing at a time until you're satisfied.

If your version of vim allows selecting fonts via a menu, I recommend (for X11 without GTK+2) keeping only what is required to have a working font and replacing the rest (including, most especially, the last parameter, which is the encoding) by dash-separated asterisks; or (for other systems) keeping the font name and size and removing the rest (or, for non-X11, setting the encoding to cDEFAULT). See the examples below.

Now here is a snippet of code, applicable (I hope) to all versions of gvim. The only reason I haven't tested them all is I don't have them all. Start with that, change the "set" statements as needed, and put it in your vimrc.

    if has("gui_running")
        if has("gui_gtk2")
            set guifont=Courier\ New\ 11
        elseif has("x11")
            set guifont=-*-courier-medium-r-normal-*-*-180-*-*-m-*-*
        else
            set guifont=Courier_New:h11:cDEFAULT
        endif
    endif

Happy Vimming!
Tony.






VimTip	{{{1 633: spell check of word below cursor


poor man's grep of spell checking for unix based systems

requires aspell/ispell to be available in path or use full path in map command

map <A-e> :!echo <cword> \| ispell -d british -a -- <return>
map <A-d> :!echo <cword> \| ispell -d danish -a -- <return>

spell check words in either english or danish






VimTip	{{{1 634: To view all colours available to gvim



What: To see all the colours available in gvim, with their names.

How:  Save this tip and open in gvim and do ':source %'

Caveats: some colours appear wrong in gvim, 
         but are correct in opera/eudora/emacs.

See: Color names are from X11/rgb.txt, see also $VIM/syntax/colortest.vim

- http://www.cs.albany.edu/~mosh

---- cut-here -------

/\ssnow/,$ g/^" \\w/ exec 'hi col_'.expand("<cword>").' guifg='.expand("<cword>")|
           \\ exec 'syn keyword col_'.expand("<cword>")." ".expand("<cword>")

" snow
" GhostWhite
" WhiteSmoke
" gainsboro
" FloralWhite
" OldLace
" linen
" AntiqueWhite
" PapayaWhip
" BlanchedAlmond
" bisque
" PeachPuff
" NavajoWhite
" moccasin
" cornsilk
" ivory
" LemonChiffon
" seashell
" honeydew
" MintCream
" azure
" AliceBlue
" lavender
" LavenderBlush
" MistyRose
" white
" black
" DarkSlateGray
" DarkSlateGrey
" DimGray
" DimGrey
" SlateGray
" SlateGrey
" LightSlateGray
" LightSlateGrey
" gray
" grey
" LightGrey
" LightGray
" MidnightBlue
" navy
" NavyBlue
" CornflowerBlue
" DarkSlateBlue
" SlateBlue
" MediumSlateBlue
" LightSlateBlue
" MediumBlue
" RoyalBlue
" blue
" DodgerBlue
" DeepSkyBlue
" SkyBlue
" LightSkyBlue
" SteelBlue
" LightSteelBlue
" LightBlue
" PowderBlue
" PaleTurquoise
" DarkTurquoise
" MediumTurquoise
" turquoise
" cyan
" LightCyan
" CadetBlue
" MediumAquamarine
" aquamarine
" DarkGreen
" DarkOliveGreen
" DarkSeaGreen
" SeaGreen
" MediumSeaGreen
" LightSeaGreen
" PaleGreen
" SpringGreen
" LawnGreen
" green
" chartreuse
" MediumSpringGreen
" GreenYellow
" LimeGreen
" YellowGreen
" ForestGreen
" OliveDrab
" DarkKhaki
" khaki
" PaleGoldenrod
" LightGoldenrodYellow
" LightYellow
" yellow
" gold
" LightGoldenrod
" goldenrod
" DarkGoldenrod
" RosyBrown
" IndianRed
" SaddleBrown
" sienna
" peru
" burlywood
" beige
" wheat
" SandyBrown
" tan
" chocolate
" firebrick
" brown
" DarkSalmon
" salmon
" LightSalmon
" orange
" DarkOrange
" coral
" LightCoral
" tomato
" OrangeRed
" red
" HotPink
" DeepPink
" pink
" LightPink
" PaleVioletRed
" maroon
" MediumVioletRed
" VioletRed
" magenta
" violet
" plum
" orchid
" MediumOrchid
" DarkOrchid
" DarkViolet
" BlueViolet
" purple
" MediumPurple
" thistle
" snow1
" snow2
" snow3
" snow4
" seashell1
" seashell2
" seashell3
" seashell4
" AntiqueWhite1
" AntiqueWhite2
" AntiqueWhite3
" AntiqueWhite4
" bisque1
" bisque2
" bisque3
" bisque4
" PeachPuff1
" PeachPuff2
" PeachPuff3
" PeachPuff4
" NavajoWhite1
" NavajoWhite2
" NavajoWhite3
" NavajoWhite4
" LemonChiffon1
" LemonChiffon2
" LemonChiffon3
" LemonChiffon4
" cornsilk1
" cornsilk2
" cornsilk3
" cornsilk4
" ivory1
" ivory2
" ivory3
" ivory4
" honeydew1
" honeydew2
" honeydew3
" honeydew4
" LavenderBlush1
" LavenderBlush2
" LavenderBlush3
" LavenderBlush4
" MistyRose1
" MistyRose2
" MistyRose3
" MistyRose4
" azure1
" azure2
" azure3
" azure4
" SlateBlue1
" SlateBlue2
" SlateBlue3
" SlateBlue4
" RoyalBlue1
" RoyalBlue2
" RoyalBlue3
" RoyalBlue4
" blue1
" blue2
" blue3
" blue4
" DodgerBlue1
" DodgerBlue2
" DodgerBlue3
" DodgerBlue4
" SteelBlue1
" SteelBlue2
" SteelBlue3
" SteelBlue4
" DeepSkyBlue1
" DeepSkyBlue2
" DeepSkyBlue3
" DeepSkyBlue4
" SkyBlue1
" SkyBlue2
" SkyBlue3
" SkyBlue4
" LightSkyBlue1
" LightSkyBlue2
" LightSkyBlue3
" LightSkyBlue4
" SlateGray1
" SlateGray2
" SlateGray3
" SlateGray4
" LightSteelBlue1
" LightSteelBlue2
" LightSteelBlue3
" LightSteelBlue4
" LightBlue1
" LightBlue2
" LightBlue3
" LightBlue4
" LightCyan1
" LightCyan2
" LightCyan3
" LightCyan4
" PaleTurquoise1
" PaleTurquoise2
" PaleTurquoise3
" PaleTurquoise4
" CadetBlue1
" CadetBlue2
" CadetBlue3
" CadetBlue4
" turquoise1
" turquoise2
" turquoise3
" turquoise4
" cyan1
" cyan2
" cyan3
" cyan4
" DarkSlateGray1
" DarkSlateGray2
" DarkSlateGray3
" DarkSlateGray4
" aquamarine1
" aquamarine2
" aquamarine3
" aquamarine4
" DarkSeaGreen1
" DarkSeaGreen2
" DarkSeaGreen3
" DarkSeaGreen4
" SeaGreen1
" SeaGreen2
" SeaGreen3
" SeaGreen4
" PaleGreen1
" PaleGreen2
" PaleGreen3
" PaleGreen4
" SpringGreen1
" SpringGreen2
" SpringGreen3
" SpringGreen4
" green1
" green2
" green3
" green4
" chartreuse1
" chartreuse2
" chartreuse3
" chartreuse4
" OliveDrab1
" OliveDrab2
" OliveDrab3
" OliveDrab4
" DarkOliveGreen1
" DarkOliveGreen2
" DarkOliveGreen3
" DarkOliveGreen4
" khaki1
" khaki2
" khaki3
" khaki4
" LightGoldenrod1
" LightGoldenrod2
" LightGoldenrod3
" LightGoldenrod4
" LightYellow1
" LightYellow2
" LightYellow3
" LightYellow4
" yellow1
" yellow2
" yellow3
" yellow4
" gold1
" gold2
" gold3
" gold4
" goldenrod1
" goldenrod2
" goldenrod3
" goldenrod4
" DarkGoldenrod1
" DarkGoldenrod2
" DarkGoldenrod3
" DarkGoldenrod4
" RosyBrown1
" RosyBrown2
" RosyBrown3
" RosyBrown4
" IndianRed1
" IndianRed2
" IndianRed3
" IndianRed4
" sienna1
" sienna2
" sienna3
" sienna4
" burlywood1
" burlywood2
" burlywood3
" burlywood4
" wheat1
" wheat2
" wheat3
" wheat4
" tan1
" tan2
" tan3
" tan4
" chocolate1
" chocolate2
" chocolate3
" chocolate4
" firebrick1
" firebrick2
" firebrick3
" firebrick4
" brown1
" brown2
" brown3
" brown4
" salmon1
" salmon2
" salmon3
" salmon4
" LightSalmon1
" LightSalmon2
" LightSalmon3
" LightSalmon4
" orange1
" orange2
" orange3
" orange4
" DarkOrange1
" DarkOrange2
" DarkOrange3
" DarkOrange4
" coral1
" coral2
" coral3
" coral4
" tomato1
" tomato2
" tomato3
" tomato4
" OrangeRed1
" OrangeRed2
" OrangeRed3
" OrangeRed4
" red1
" red2
" red3
" red4
" DeepPink1
" DeepPink2
" DeepPink3
" DeepPink4
" HotPink1
" HotPink2
" HotPink3
" HotPink4
" pink1
" pink2
" pink3
" pink4
" LightPink1
" LightPink2
" LightPink3
" LightPink4
" PaleVioletRed1
" PaleVioletRed2
" PaleVioletRed3
" PaleVioletRed4
" maroon1
" maroon2
" maroon3
" maroon4
" VioletRed1
" VioletRed2
" VioletRed3
" VioletRed4
" magenta1
" magenta2
" magenta3
" magenta4
" orchid1
" orchid2
" orchid3
" orchid4
" plum1
" plum2
" plum3
" plum4
" MediumOrchid1
" MediumOrchid2
" MediumOrchid3
" MediumOrchid4
" DarkOrchid1
" DarkOrchid2
" DarkOrchid3
" DarkOrchid4
" purple1
" purple2
" purple3
" purple4
" MediumPurple1
" MediumPurple2
" MediumPurple3
" MediumPurple4
" thistle1
" thistle2
" thistle3
" thistle4
" gray0
" grey0
" gray1
" grey1
" gray2
" grey2
" gray3
" grey3
" gray4
" grey4
" gray5
" grey5
" gray6
" grey6
" gray7
" grey7
" gray8
" grey8
" gray9
" grey9
" gray10
" grey10
" gray11
" grey11
" gray12
" grey12
" gray13
" grey13
" gray14
" grey14
" gray15
" grey15
" gray16
" grey16
" gray17
" grey17
" gray18
" grey18
" gray19
" grey19
" gray20
" grey20
" gray21
" grey21
" gray22
" grey22
" gray23
" grey23
" gray24
" grey24
" gray25
" grey25
" gray26
" grey26
" gray27
" grey27
" gray28
" grey28
" gray29
" grey29
" gray30
" grey30
" gray31
" grey31
" gray32
" grey32
" gray33
" grey33
" gray34
" grey34
" gray35
" grey35
" gray36
" grey36
" gray37
" grey37
" gray38
" grey38
" gray39
" grey39
" gray40
" grey40
" gray41
" grey41
" gray42
" grey42
" gray43
" grey43
" gray44
" grey44
" gray45
" grey45
" gray46
" grey46
" gray47
" grey47
" gray48
" grey48
" gray49
" grey49
" gray50
" grey50
" gray51
" grey51
" gray52
" grey52
" gray53
" grey53
" gray54
" grey54
" gray55
" grey55
" gray56
" grey56
" gray57
" grey57
" gray58
" grey58
" gray59
" grey59
" gray60
" grey60
" gray61
" grey61
" gray62
" grey62
" gray63
" grey63
" gray64
" grey64
" gray65
" grey65
" gray66
" grey66
" gray67
" grey67
" gray68
" grey68
" gray69
" grey69
" gray70
" grey70
" gray71
" grey71
" gray72
" grey72
" gray73
" grey73
" gray74
" grey74
" gray75
" grey75
" gray76
" grey76
" gray77
" grey77
" gray78
" grey78
" gray79
" grey79
" gray80
" grey80
" gray81
" grey81
" gray82
" grey82
" gray83
" grey83
" gray84
" grey84
" gray85
" grey85
" gray86
" grey86
" gray87
" grey87
" gray88
" grey88
" gray89
" grey89
" gray90
" grey90
" gray91
" grey91
" gray92
" grey92
" gray93
" grey93
" gray94
" grey94
" gray95
" grey95
" gray96
" grey96
" gray97
" grey97
" gray98
" grey98
" gray99
" grey99
" gray100
" grey100
" DarkGrey
" DarkGray
" DarkBlue
" DarkCyan
" DarkMagenta
" DarkRed
" LightGreen 










VimTip	{{{1 635: getting colors to work on solaris


You need to get the latest ncurses package available at http://www.sunfreeware.com/ and then configure with this option:
--with-tlib=ncurses

This will link to ncurses which fully supports the color codes.  Then make sure your display is exported as a  color capable terminal.






VimTip	{{{1 636: Adding Vim to MS-Windows File Explorer Menu


What:  To Add 'Edit with Vim' to 'Windows File Explorer'  
'right click Menu'

1. Save this file as edit-with-vim.reg, 
2. Make sure the paths are right for your machine
3. Change each fowardslash to backslash
   with the vim command :%s,/,\\,g
4. Click on it in explorer or import this file in regedit.exe
   voila, your explorer right-click menu will have extra action items,
   it's better than the send-to.
5. The double quotes are needed for filenames with spaces.
6. The '*' means 'for all files'.

REGEDIT4
[HKEY_CLASSES_ROOT/*/shell]
[HKEY_CLASSES_ROOT/*/shell/vim]
@="Edit with &vim"
[HKEY_CLASSES_ROOT/*/shell/vim/command]
@="c://bin32//gvim.exe /"%1/""
[HKEY_CLASSES_ROOT/*/shell/_emacs]
@="Edit with &Emacs"
[HKEY_CLASSES_ROOT/*/shell/_emacs/command]
@="c://emacs//bin//runemacs.exe /"%1/""      

    






VimTip	{{{1 637: execute accidently inserted commands


If you are in insert mode and typed an command for normal mode, you can use it.

inoremap <somekey> <esc>u@.

This mapping switches to normal mode, undo'es the last insertion and takes it as a command.

Most times I need it, if I typed dd and the line still remains because of Insert-Mode and the unwanted 'dd' ist somewhere
in my text. 






VimTip	{{{1 638: Editing ActiveState Perl batch files


To run Perl scripts under Windows, you can either add the .pl extension to the PATHEXT env variable, or use pl2bat, which comes with ActiveState's Perl and makes a very nice batch file.  A quirk of Perl under Win32 is that piping doesn't work with .pl files (as in bar.pl | foo.pl) but works fine with the batch files.  It has something to do with how Windows loads files.  Anyway, this all works fine, but every time I do any extensive edits to a perl/batch file, I have to set cindent and syntax=perl or it drives me crazy.  This tip modifies filetype.vim to check batch files to see if they're really perl scripts in disguise.

--->First, find these lines:

" Batch file for MSDOS (*.cmd is close enough)
au BufNewFile,BufRead *.bat,*.cmd,*.sys		setf dosbatch

--->Then change them to this:

" Batch file for MSDOS (*.cmd is close enough)
au BufNewFile,BufRead *.bat,*.cmd,*.sys		call FTCheck_bat()

" Perl scripts converted to bat by pl2bat have a unique string that
" identifies the file.  It should be the first line.
fun! FTCheck_bat()
  if exists("g:filetype_bat")
    exe "setf " . g:filetype_bat
  else
    let l = getline(nextnonblank(1))
    if l =~ '--\*-Perl-\*--'
      setf perl
    else
      setf dosbatch
    endif
  endif
endfun


--->That's it!  This is very specific to look for the string pl2bat adds to the file, but can be easily modified to your needs.








VimTip	{{{1 639: Comment highlight #ifdef DEBUG for code-read ease (C/C++)


Hi all,

If your C/C++ code is scattered with statements like
#ifdef DEBUG
   // Some code..
   cout << "Debug output: blah" << endl;
#endif

and you would like to highlight these segments in a different colour (so that
you can skip them visually), add the following code in your .vimrc (colouring
follows that of comments)

CODE STARTS
syn region MySkip contained start="^\s*#\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*#\s*endif\>" contains=MySkip

let g:CommentDefines = ""

hi link MyCommentOut2 MyCommentOut
hi link MySkip MyCommentOut
hi link MyCommentOut Comment

map <silent> ,a :call AddCommentDefine()<CR>
map <silent> ,x :call ClearCommentDefine()<CR>

function! AddCommentDefine()
   let g:CommentDefines = "\\(" . expand("<cword>") . "\\)"
   syn clear MyCommentOut
   syn clear MyCommentOut2
   exe 'syn region MyCommentOut start="^\s*#\s*ifdef\s\+' . g:CommentDefines . '\>" end=".\|$" contains=MyCommentOut2'
   exe 'syn region MyCommentOut2 contained start="' . g:CommentDefines . '" end="^\s*#\s*\(endif\>\|else\>\|elif\>\)" contains=MySkip'
endfunction

function! ClearCommentDefine()
   let g:ClearCommentDefine = ""
   syn clear MyCommentOut
   syn clear MyCommentOut2
endfunction

CODE ENDS

To see the effect, position the cursor on the word DEBUG in the C code snippet above and type ,a






VimTip	{{{1 640: See your vim templates in Windows Explorer's New context menu


Do you wish you had your own vim settings for a file appear automatically when
you right click in Windows Explorer? If so then read on, following these steps
sequentially:

- Create a template file where the last few lines control vim. See below for a
  sample: 

	-[sample template file begins below this line]-

--------------------------------End of Text----------------------------------
The line below controls vim, which you can get free from: http://www.vim.org/
vim:tw=80:ai:ft=txt:norl:
	-[sample template file ends above this line]-

- Call the above sample template file GVIM.vtd and save it in
  "C:\Windows\ShellNew\" directory.  You may use another extension, but I
  played it safe and used one that wasn't being used on my system. Moreover, I
  did not change the default location of Windows installation, but you may
  need to do so if your system does not match mine.

- Open Explorer and click on Tools->Folder Options... in the dialog box that
  appears, click on File Types and then scroll the file types until you reach
  VTD.  Click on the file extension VTD and click on Change; now associate
  gvim.exe with this file extension.

- Next, open the registry with regedit by clicking on Start->Run and typing
  regedit in the Run dialog box

- In the registry, scroll  HKEY_CLASSES_ROOT until you get to Vim.Application
		- then add a key; call it "shell"
		- next scroll into: 
			[HKEY_CLASSES_ROOT\Vim.Application\shell]
		- and add a key; call it "open"
		- once more scroll into:
		  	[HKEY_CLASSES_ROOT\Vim.Application\shell\open]
		- and add yet another key; call it "command"
		- now change, by double clicking on, the "(Default)" value of
		  "command" to point it to the location of gvim.exe on your
		  hard drive. On my system, I entered the following in the text
		  field "Value data" 
		  	C:\PROGRA~1\Vim\vim62\gvim.exe "%1"
	
- Finally open up Explorer and navigate to any directory on your hard drive.
  Now, right click on, the pane displaying the files, to see "Vim" as one of
  your options. When you choose Vim, you will create a file called "New
  Vim.vtd" in that directory. When you open "New Vim.vtd" you should see the
  above sample text and Vim uses the settings used in the last line of the file.

- Any changes made to the original template in C:\Windows\ShellNew appear in
  the new files that you create.

I tried to get this to work with using TweakUI but that did not help in Windows
XP, so I had to do it the long way. So, I hope this tip helps at least a few of
you,

Enjoy!







VimTip	{{{1 641: Highlighting of method names in the definition (C++)


When editing big cpp files, it can be very convenient to highlight the method name
(the part after "::") in a method definition.

--> I use the following function in my .vimrc:

" Add highlighting for function definition in C++
function! EnhanceCppSyntax()
    syn match cppFuncDef "::\~\?\zs\h\w*\ze([^)]*\()\s*\(const\)\?\)\?$"
    hi def link cppFuncDef Special
endfunction

--> I have another line to call this function automatically when editing a C++ file:

autocmd Syntax cpp call EnhanceCppSyntax()

--> That's it! This doesn't work in all cases (for instance, it doesn't highlight constructors
using an initialization list on the same line) but it shouldn't highlight function calls
(such as "MyClass::MyStaticMethod( int foo );" )
Don't hesitate to extend the regular expression for a more accurate matching...






VimTip	{{{1 642: Windows: Get K to not display a DOS box that needs closing


To get the K command to open a Windows program without creating DOS box that needs to be closed you can do the following:

In your _vimrc add the following:

map K yiw:exec "silent !".&kp." ".@0<CR>

You can then set the keywordprg (abbreviated kp above) to the program you want to run.

Thanks to Jacob Lerner, Tim Chase, and Suresh Govindachar for coming up with this.







VimTip	{{{1 643: Disable built-in command



If there's a built-in key command in vim that you just can't stand, find annoying, and/or often hit by accident(for me it's "K", with ">" a close second), then you can disable it using ":map".  You can't use ":unmap", as you might think.  Instead, you can map it to nothing, like:

:map K <Nop>

(<Nop> is not the "Nop" key on your keyboards, but literal letters inside literal pointy brackets.)

Of course, you can always

:unmap K

if you start doing C programming and want to instantly "man" things under the cursor again.







VimTip	{{{1 644: restoring indent for '#'


In 'smatrindent' mode '#' removes the indent if it is the first char on the line.
Very annoying for me.

From Vim's help:
        When typing '#' as the first character in a new line, the indent for
        that line is removed, the '#' is put in the first column.  The indent
        is restored for the next line.  If you don't want this, use this
        mapping: ":inoremap # X^H#", where ^H is entered with CTRL-V CTRL-H.

This helps, but it failes to work when placed in ~/.vimrc.
The fillowing mapping work in any case:

:inoremap # a#^Oh^Ox^OA, where ^O is entered with CTRL-V CTRL-O.







VimTip	{{{1 645: Enabling Windows shortcuts (eg alt+space, F10 etc) for gvim window


I was trying to figure out why Alt+space would not work, as i would have to use the mouse to maximize/restore/minimize my gvim window (on Win32) which was a pain
and found that i needed to 
     set winaltkeys=yes 
to make this work. Now I can use 
Alt+Space followed by 'x to maximize
Alt+Space followed by 'n' to minimize
Alt+Space followed by 'r' to restore!
See 
help winaltkeys

Also see this:
vimtip #494






VimTip	{{{1 646: moving lines up/down in a file


The following mappings in .vimrc provide a quick way to move a line of text up or down within a file:

    map <C-Up> dd-P
    map <C-Down> ddp

Hold down the Control key, and the <Up> and <Down> arrow keys move the line.  Check it out!

This is particularly useful when editing a file consisting of single-line items in a particular order (such as priority) - it makes it easy to change the relative position of items in the list.






VimTip	{{{1 647: Single letter insert



 Often I have to insert only one character ( typically a paren)
:map <C-x> ylpr









VimTip	{{{1 648: Uniq - Removing duplicate lines


There are two versions, the first leaves only the last line, the second leaves only the first line.

g/^\(.*\)$\n\1$/d

g/\%(^\1$\n\)\@<=\(.*\)$/d

Breakdown of the second version:

g//d    <-- Delete the lines matching the regexp

\@<=    <-- If the bit following matches, make sure the bit preceding this symbol directly precedes the match

\(.*\)$   <-- Match the line into subst register 1 

\%( )     <--- Group without placing in a subst register.
^\1$\n   <--- Match subst register 1 followed by end of line and the new line between the 2 lines

In this simple format (matching the whole line), it's not going to make much difference, but it will start to matter if you want to do stuff like match the first word only 

This does a uniq on the first word in the line, and deletes all but the first line:

g/\%(^\1\>.*$\n\)\@<=\(\k\+\).*$/d









VimTip	{{{1 649: expand existing abbreviation


This mapping expands existing abbreviation 

map <C-X><C-X> diw:exe "normal i".@"<cr>






VimTip	{{{1 650: abbreviation that prompts whether to expand it or not


You can define abbreviation in such a way that it will ask whether to expand it or not. The trick is to define it as insert-mode mapping with special body, not as abbreviation.
Here is how to define it:

   function! MyExpand(abbr,expansion)
     let answer=confirm("Expand '".a:abbr."' [y] ", "&Yes\n&No")
     if answer==2
        exec "normal! a".a:abbr
     else
         exec "normal! a".a:expansion
     endif
   endfunction

imap ABC <esc>:call AskExpand("ABC","...expansion for ABC ...")<cr>a
imap XYZ <esc>:call AskExpand("XYZ","...expansion for XYZ ...")<cr>a






VimTip	{{{1 651: Edit gnupg-encrypted files.


It can be somewhat laborious to edit a file which you have encrypted: first you have to decrypt to plaintext, then use vim and save; then encrypt again.  The method below lets vim take care of some of the dirty work.

First, be sure you have gnupg setup to the point where you can ascii-armor encrypt a file using your own public key, and decrypt it again.

Then put this into your .vimrc (don't duplicate the 'if has("autocmd")' part if it is already there):
  if has("autocmd")
      augroup GPGASCII
         au!
         au BufReadPost *.asc  :%!gpg -q -d
         au BufReadPost *.asc  |redraw
         au BufWritePre *.asc  :%!gpg -q -e -a
         au BufWritePost *.asc u
         au VimLeave *.asc :!clear
      augroup END
  endif " has ("autocmd")
 
you might also want to add these options to your ~/.gnupg/options file to decrease the messages gnupg outputs:
    no-greeting
    quiet
    default-recipient-self  #to always encrypt for yourself.

Now vim a new file, the name of which ends with .asc:
     vim important.asc
and edit.  When you save and quit, gnupg may prompt for gnupg ids to encrypt for (if you don't have default-recipient-self set).  Enter your own.  To edit, just vim it again and you'll be prompted for your passphrase.

This isn't perfect -- in particular, you occasionally have to tell vim to redraw with ctrl-L to get rid of gnupg crud -- but it works pretty well for me.  I'd love to hear about improvements!






VimTip	{{{1 652: save all open buffers at once


Since i like to work with more than one buffer, i always have had the problem 
that i left one of them unsaved by mistake. For this purpose i wrote this
small function which saves all open buffers (only if changes were made).
If you map the function to a key (e.g. F12), this is quite a convenient way.  

add this to your .vimrc:

function! SaveBuffers()
  if !buflisted(bufnr('%'))
    return
  end
  let myBufferNumber = bufnr('%')
  exec("bufdo update")
  exec("b".myBufferNumber)
endfunction

nmap <F12> :call SaveBuffers()<CR>








VimTip	{{{1 653: doxygen '///' :comments setting


This will continue lines of '///' doxygen comments when you reach the end of a line while typing a comment.  It also works if you use 'o' to open a new line while on a comment starting with '///'.  It only works if there is a space between the last '/' and the first letter of the comment, that is no big deal, since it lends itself to readability.  So for example:
/// This will work.
///This won't.

Here is the magic line.  Make sure you put it somewhere that will get sourced whenever you open a file you want to use with doxygen.  I have it in ~/.vim/after/ftplugin/c/c.vim, so it gets sourced for all C and C++ files.

set comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,bO:///,O://

All other comments will continue to work as expected.

- Michael






VimTip	{{{1 654: special characters in VIM substitution


Let's think about the code below

void
howdy(void)
{
   M00 =
   M01 =
   M10 =
   M11 =
   M20 =
   M21 = 0;
}

Now you want to change the code like

void
howdy(void)
{
   M[0][0] =
   M[0][1] =
   M[1][0] =
   M[1][1] =
   M[2][0] =
   M[2][1] = 0;
}

You can easily do that with

:g/\(M\)\([0-9]\)\([0-9]\)/s//\1[\2][\3]/g

Here,
   \1 is a special substitute character meaning first pair of the search pattern.

To specify a pair in your search pattern,
simply enclose your search pattern with "\(" and "\)".

Thus, in the above example
\(M\) corresponds to \1, and
\([0-9]\) to \2 and etc...

And substitute pattern "\1[\2][\3]" means
"1st pair" + "[" + "2nd pair" + "]" + "[" + "3rd pair" + "]",
which is what we want here.

For more information on special substitute characters, simply do :help substitute.
Happy Vim-ing!






VimTip	{{{1 655: search with one key


* is 2 keys (shift and press 8)
I found it simpler to map these to a single key.

put these mappings in your _vimrc file

:nmap  <F8> :execute ":normal #"<CR>

:nmap  <F9> :execute ":normal *"<CR>

Now you can search for the word under the cursor in normal mode with the F8 key backwards and the F9 key forwards.

Can this be done in insert mode?







VimTip	{{{1 656: Recursive mappings - (2 examples to learn from)


Recursive mappings are fun to learn and really handy when you want to do repetitive tasks.  One way to do this is Tip#144 (recording).  This is another way when you find that you are using the same **editing pattern** again and again.  Recursion may seem a bit complicated at first but it is very intuitive once you get the hang of it.   Here are two examples for you to learn from.

For example, you have a file with the following contents -

aaa.txt
bbbbbb.txt 
ccc.txt

You want to change the file as follows -

wc aaa.txt> aaa.log
echo "HelloWorld"
wc bbbbbb.txt > bbbbbb.log
echo "HelloWorld"
wc ccc.txt> ccc.log
echo "HelloWorld"

A simple recursive mapping that will do the job is 
:map z Iwc <Esc>lyawA><Esc>pa.log<CR>echo "HelloWorld"<Esc>jz

Now type z in the first line and everything else is magic.

Here is the breakup where {} contain the vim commands.  
1.  Goto the beginning of the line and type "wc " and then come back to normal mode {Iwc <Esc>}
2.  Copy the word aaa (or bbbb or ccc).  We do this by going right one character and copying the word under it. {lyaw}
3.  Goto the end of the line and append > and then come back to normal mode.   {A><Esc>}
4.  Paste what we had copied {p}
5.  Append .log<CR>echo "HelloWorld" to the line.  {a.log<CR>echo "HelloWorld"}
6.  Goto the next line but first we switch to the normal mode. {<Esc>j}
7.  Do steps 1 to 7 all overagain {z}

The recursion terminates when the j cannot take you one more line further.  If you manually execute a command for one line, you will find it very intuitive to create recursive mappings. 

Here is another example.

Say you want to change
#define myid   199
#define myid2 200
#define myid3 201 

To
#define myid   201
#define myid2 202
#define myid3 203 

The simple  mapping would be -
:map z 2^Ajz  

Where ^A is CTRL_V+A

1.  Add 2 to the number in the line
2.  Go down one line.  
3.  Do steps 1 to 3 again.

Also see 
:help recursive_mapping
:help CTRL-A
:help nowrapscan  // when using recursion with searching.

There may be many ways to solve the above problems... this is just another way which I like to use.  Recursion is very powerful espcially when I manipulate many open windows where the content of one is to be used in another.  






VimTip	{{{1 657: have a question about vim?


www.vim.org is a great place to find tips and scripts, but if you have a question about vim, don't post it here! (People don't take kindly to that.)

Check out http://www.vimuser.com/ 






VimTip	{{{1 658: Switching to unit test module for python


Doing a lot of programming in Python, I need to switch quickly between Python module and corresponding unit-test module. Often there is one unit-testing module for multiple python modules. 

This function allows you to switch to correct unit testing module quickly, using the filename hardcoded at the end of the file. Idea is stolen from Twisted sources.

Put this to your ftplugin/python.vim:

nmap <buffer> <F5> :call JumpToTestFile()<CR>

fun! JumpToTestFile()
	let line = getline("$")
	if line =~ "^### testfile: "
		let filename = strpart(line, 14)
		execute ":e " . filename
	else
		echo "TEST PATTERN ### testfile: NOT FOUND!"
	endif
endfun







VimTip	{{{1 659: Collect filenames of current subtree


In vim you can edit directories, but sometimes for me it is more convenienant to have the names of all files in the complete subtree listed in one buffer. The below function does just this. In essential, it globs the file names of the current directory and iterates throught all the names, globbing it again if it is a directory.
The following mapping abbreviates the invocation to pressing '_L':

map _L :call ListTree('.')<CR>

function! ListTree(dir)	
  new
  set buftype=nofile
  set bufhidden=hide
  set noswapfile
  normal i.
  while 1
    let file = expand("<cWORD>")
    if (file == '')
      normal dd
    elseif (isdirectory(file))
      normal dd
      let @" = glob(file . "/*")
      normal O
      normal P
      let @" = glob(file . "/.[^.]*")
      if (@" != '')
      normal O
      normal P
      endif
    else
      if (line('.') == line('$'))
	return
      else
	normal j
      endif
    endif
  endwhile
endfunction







VimTip	{{{1 660: Comment lines in different filetypes


This code snippet is a part of .vimrc (_vimrc 4 Win) file to set comments in various filetypes. The funtion CommentIt() decides itself, according to the current file's type which variant of comments to use. 

--> IMPORTANT this function should be started with "autocmd BufEnter * call CommentIt ()" some where after its declaration to be involved every time user enters a new buffer.

function CommentIt ()
if &filetype == "vim"
	vmap +# :s/^/"/<CR>
	vmap -# :s/^"//<CR>
elseif &filetype == "tcl"
	vmap +# :s/^/#/<CR>
	vmap -# :s/^#//<CR>
elseif &filetype == "c"
	vmap +# I/*<Esc>gv<End><Esc>a*/<Esc>
	vmap -# I<Esc>2xgv$<Esc>h2x<Esc>
elseif &filetype == "cpp"
	vmap +# A<End><CR><Esc>gv:s/^/ *<CR>gvI<Esc>ko<Home>/*<Esc>gvA<Esc>ji */
	vmap -# :s/^..//<CR>gvI<Esc>ddgvA<Esc>dd
elseif &filetype == "dosbatch"
	vmap +# :s/^/rem /<CR>
	vmap -# :s/^rem //<CR>
endif	
endfunction
...
autocmd BufEnter * call CommentIt ()








VimTip	{{{1 661: LaTeX: Addition to latex-suite: folds the preamble


In /ftplugin/latex-suite/folding.vim I added the lines you see below, so that the latex-suite folding \rf also folds the preamble (the part between \documentclass and \begin{document}.

	" {{{ Preamble
	call AddSyntaxFoldItem (
		\ '^\s*\\documentclass',
		\ '^\s*\\begin{document}',
		\ 0,
		\ 0
		\ )
	" }}}

happy LaTeXing

chris






VimTip	{{{1 662: Quote unquoted HTML attributes


This is a simple regex that can be used to search an HTML file and replace all unquoted attributes with their quoted version.

map <F9> :%s/\([^&^?]\)\(\<[[:alnum:]-]\{-}\)=\([[:alnum:]-#%]\+\)/\1\2="\3"/g<Return>







VimTip	{{{1 663: Annoyed that some stuff is reset during GUI init?


I've always been. t_vb is one of those things that forced me to have a separate
.vimrc and .gvimrc or to fudge around with $GVIMINIT. And while not documented
as such, guioptions seems to get reset as well. Be annoyed no longer:

	if has("gui_running")
		autocmd GUIEnter * source ~/.vimrc
	endif

Make sure your .vimrc is safe for multiple sourcings. autocmds should be
cleared, in particular.

	autocmd!

There may also be more things to take into account I'm not aware of.

Now you can keep all your settings neatly in a single place.






VimTip	{{{1 664: Vim Easter Egg??


I could not successfully verify this on my 6.2 win32 Install. Maybe, I should not believe everything I read! Or does it work for you??

From   http://linuxgazette.net/issue89/vinayak.html
-------
 Easter Egg # 3 (Credit Listing in VIM)
This is a easter egg I recently discovered in the popular editor VIM. Follow the steps and you are in for a surprise.
   1. On the command line edit a file programmers.txt
   2. Get into insert mode by pressing i
   3. Press enter 11 times
   4. Now that you are on the 12th line, type the name Bram Moolenaar
   5. Open a new buffer using the key sequence CTRL+W followed by N
   6. In the new buffer you will see the names of all the people who have contributed to VIM







VimTip	{{{1 665: Hide & Toggle GUI widgets


If you like your GUI clean, but want the option to access all its power, then you might like this tip.

The variable "guioptions" determines what GUI widgets are visible (see :help guioptions).  I personally prefer to have as few widgets visible as possible, until I need them.  To that end, I have the following in my vimrc (thanks to Tim Chase):

"  Turn off useless toolbar
set guioptions-=T

"  Turn off menu bar (toggle with CTRL+F11)
set guioptions-=m

"  Turn off right-hand scroll-bar (toggle with CTRL+F7)
set guioptions-=r

" CTRL+F11 to toggle the menu bar
nmap <C-F11> :if &guioptions=~'m' \| set guioptions-=m \| else \| set guioptions+=m \| endif<cr>

"  CTRL+F7 to toggle the right-hand scroll bar
nmap <C-F7> :if &guioptions=~'r' \| set guioptions-=r \| else \| set guioptions+=r \| endif<cr>

Opera browser fans will find the bindings familiar.






VimTip	{{{1 666: switch between a *.cpp and matching .h file


For programmers, that want to switch from foo.cpp to foo.h (or vice versa)
on a single key stroke, this might help:

map <F4> :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>

it maps (on F4) the change of the current filename. The endings
".h" and ".cpp" are exchanged (via the magic ending ".X123X").
You could use ".hpp" or ".c" filename endings by changing
it in the replacement statemtents.

    comments are welcome
    Joerg (j.beyer@web.de)






VimTip	{{{1 667: Navigate large CSV files more easily


 
I often work with csv files that have dozens or hundreds of items on a line.  Scrolling around to find the 34th item is very hard, specially when the items are of varying lengths -- but this small script makes it a bit easier.

function! CSVH(x)
    execute 'match Keyword /^\([^,]*,\)\{'.a:x.'}\zs[^,]*/'
    execute 'normal ^'.a:x.'f,'
endfunction

command! -nargs=1 Csv :call CSVH(<args>)

Now you can do ':Csv 23' to hilite the 23rd entry in each line and go to the 23rd entry in the current line. 

There's also a great tip at http://www.rayninfo.co.uk/vimtips.html about how to make the columns in csv files line up.









VimTip	{{{1 668: Re-indenting sections : ={motion}


It's simple and documented, but I needed some time to find it: when the right indenting (:he indenting) is 
chosen, ={motion} re-indents the block. Maybe this could be mentioned in indenting.






VimTip	{{{1 669: nice window resizing


" Map F1 for gvim window resizing
" Put this snippet of code in you .vimrc for nice window resizing.
" Press F1 key to toggle between the three settings .

nmap <F1>    :call ResizeWindow()<CR>
imap <F1>    <ESC><F1>a   " for insert mode

function! ResizeWindow()
    if (has("gui"))
        if s:selectedsize == 1
            let s:selectedsize = 2
	    set number
            set columns=88  " 88 is exactly 80 with :set number
            set lines=35
        elseif s:selectedsize == 2
	    set number
            let s:selectedsize = 3
            set columns=98
            set lines=45
        else  " old school console goodness
            let s:selectedsize = 1
	    set nonumber
            set columns=80
            set lines=25
        endif
    endif
endfunction
let s:selectedsize=1
call ResizeWindow()







VimTip	{{{1 670: Filtering: deleting some lines with some exeptions


I have several hundred file path names in a buffer, each filling a line, e.g. created with vim tip # 659.
About half of them are help files, starting with './help/'  which I want to delete, but I want to keep 
the german ones, starting with './help/de/'. Here comes how I do it with VIM:

   :global:^./help/:if (match(getline(line(".")), '^./help/de/') == -1) | delete | endif







VimTip	{{{1 671: Add a newline after given pattern(s)


After having gone numb when trying to de parse HTML source code w/
very long lines, i created the following function, thus macro and
command.  It takes a list of one or more patterns/strings, and adds a
newline after each.  (Wrapping/Indentation is controlled by your own
settings.)

  <code>
  "  Intentionally left incomplete to be complete as needed
  nnoremap ,nl :NewLine

  "  Add line breaks in after given strings/regex
  com! -nargs=+ -range -bar NewLine <line1>,<line2>call AddNewLine(<f-args>)

  function! AddNewLine(...) range
    let str_no = 1

    while str_no <= a:0
      exec 'let var = a:' . str_no

        " ` (backquote) is used as delimiters for s///, which is hard
        "  to distinguish but also is much rarer than delimiters.
        "
        "  And, "No Match found" messages are suppressed (s///e)
        "
        "  (The "exec..." is one long line.)
        exec a:firstline . "," . a:lastline . 's`\(' . var . '\)\($\)\@!`\1\r`ge'

      let str_no = str_no +1
    endwhile

    unlet! var
    unlet str_no
  endfunction
  </code>








VimTip	{{{1 672: Buffer Bar


Hello,

GVim does not have a buffer bar (i.e. a toolbar with buffer names listed), but we can make a simple one
by using (GUI only)

:tearoff Buffers

this will float (:help tearoff) the Buffers menu, giving an easier access to switching buffers. The advantage of
using this floating menu is that we does not have to switch mode and giving commands
everytime we want to switch buffer also it gives the list of files currently being edited.

The problem is that when you switch buffer, the floating menu disappear. To make it always
appear, we can put this command in the .vimrc

autocmd VimEnter * tearoff Buffers

The floating menu will become quite lenghty if we open many buffers, to make it somehow smaller,
we can edit the file menu.vim in $VIMRUNTIME to make it (1) show only the filename, 
not with the path and (2) not showing
the delete, refresh, etc, since these command can easily done from command mode (:help buffer).

For the first one, we can set this variable to 0

:let g:bmenu_max_pathlen=0

in our .vimrc

and for the second one, we can use this command (assuming the commands are around lines 563-573,
in my menu.vim -> may differ to yours)

:563-573s/"/'/g
:563-573s/exe/"exe/

the order of these commands does matter. You should check if the command are really located
in those lines, the commands to be commented are

exe 'an <silent> ' . g:bmenu_priority . ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
exe 'an ' . g:bmenu_priority . ".4 &Buffers.&Delete :bd<CR>"
exe 'an ' . g:bmenu_priority . ".6 &Buffers.&Alternate :b #<CR>"
exe 'an ' . g:bmenu_priority . ".7 &Buffers.&Next :bnext<CR>"
exe 'an ' . g:bmenu_priority . ".8 &Buffers.&Previous :bprev<CR>"
exe 'an ' . g:bmenu_priority . ".9 &Buffers.-SEP- :"

After that, restart gVim.

Thanks.







VimTip	{{{1 673: dealing with typing ":wq" in insert-mode


\" I find myself typing \":wq\" in insert-mode many a time.
\" Add this to your .vimrc.

function WQHelper()
    let x = confirm(\"Current Mode ==  Insert-Mode!\\n Would you like \':wq\'?\",\" &Yes \\n &No\",1,1)
    if x == 1
    silent! :wq
    else
        \"???
    endif
endfunction
iab wq <bs><esc>:call WQHelper()<CR>






VimTip	{{{1 674: One-liner Replacement for ':sb(uffer) | e(dit) somefile'


I prefer to use buffers and split windows [unlike a coworker who shall remain nameless (Bob) who insists on having many, many gvim instances open ;) ].

While rather tedious and error-prone, I was satisfied with the built-in method of splitting the buffer and editing a file... Until today, that is.

Critical mass was achieved after I fat-fingered ':sb | e somefile' four times in a row, leading to these, my first user commands:

"Put this in your .vimrc
command! -nargs=1 -complete=file Sedit sbuffer | edit <args>
command! -nargs=1 -complete=file Vedit vsplit | edit <args>

---------------
Help References
---------------
"User Commands
:help user-commands

"Argument Handling
:help E175

"Command Completion
:help command-completion

Enjoy!







VimTip	{{{1 675: How to turn off all colors


     If you're like me, you don't want a colorful editor.  I spent hours looking for a "turn off all those colors right now!!" command and I couldn't find any help.  After some poking around for a while, I found the commands you need.  Just put these at the end of  your .vimrc file.

syntax off
set nohlsearch
set t_Co=0

     If you don't have a .vimrc file, simply create one in your home directory.
     The commands I have described will work for version 6.1.  If you have some other version, try them and see if they work.
     -mdmiller







VimTip	{{{1 676: Shortcut key for gvim in Windows XP


Purpose: I want to open gvim, in Windows XP, using a shortcut key.
HowTo: I made a shortcut to gvim, and I assigned a shortcut key in the "ProperTies" menu.


Issue: I can start the first instance of gvim, but the same combination will not allow me to start the second instance; it will just display the first one.
HowToFixIssue: I created a shortcut in the Start Menu. Now, I press and release the "WIN" key, and after that, I press "g" once. It can launch an unlimited number of instances of vim. Sometimes, I need to write a script in one instance and to see the output in another.






VimTip	{{{1 677: quick way to insert opening and closing braces for programmers


This insert-mode map is fairly easy.  I will save a lot of keystrokes for
opening and closing braces when programming.  It works best with cindent
on (:set cindent) since vim will automatically indent to the right tabstop.

I mapped it to insert-mode Ctrl-F. (The few unmapped left.)

Example:
<code>
int main() Ctrl-F

will produce:

int main() {
    |
}
</code>

insert the following in your .vimrc file
============================

" Opening and closing braces
imap <C-F> {<CR>}<C-O>O






VimTip	{{{1 678: Get Diff to Work with SFU 3.5 on Windows XP


I was having problems getting the diff utility to work running version 6.2 of VIM from within windows.  I loaded SFU 3.5, Services for Unix, onto Windows XP SP1, to try and take advantage of the included diff utility.  Basically what I have found is that it works out of the box, so long as you DO NOT specify the "icase" parameter with diffopt.

That is, if you have:

diffopt=filler,context:2,icase,iwhite

you will receive E97: Cannot create diffs.  However, if you simply remove the icase parameter and have:

diffopt=filler,context:2,iwhite

Diff will work just fine with SFU 3.5, no special functions or scripts required.  Unless, of cource, you want to ignore case.






VimTip	{{{1 679: Findlast occurrence of an item


Find the last occurrence of an item.

com! -nargs=1 Findlast :execute'normal G<cr>' | :execute':normal ?' . <arg> . '?<cr>'

Put that in your vimrc file.

Usage:
:Findlast item
e.g.
:Findlast 123


with a regular expression, put the regex  inside single quotes
e.g.

:Findlast '\d\d\d'


Explanation:
G   =  Goto line [count], default last line, on the first
			non-blank character (linewise)
? =  Search backward for the [count]'th previous
			occurrence of {pattern} (exclusive)
. = string concatenation






VimTip	{{{1 680: 'Verbose' vs. "File not found"


Problem
-------
I want to run vim with 'verbose' set, but then it gives out a lot of "file not found" messages at startup and at closedown. I'd like to avoid those messages, while still seeing where an option was set whenever I interrogate its value.

Solution
--------
Instead of setting 'verbose' in your vimrc, use autocommands, as follows (for instance)

if &cmdheight == 1
    set cmdheight=2
endif
if &verbose == 0
    augroup late-verbose
        autocmd    VimEnter    *    set verbose=1
        autocmd    VimLeave    *    set verbose=0
    augroup END
endif

Notes
-----
- The idea of the "if" statement is to avoid interfering with a -V argument which might be set in the command-line for debugging.
- The command-line is widened to at least two lines to avoid Hit-Enter prompts on ":set option?" ":edit existing/filename" etc.






VimTip	{{{1 681: Enhanced Command Window (ECW)


"
"Enhanced Command Window
"     Suresh Govindachar March 18, 2004
"
"If you are comfortable 
"
"  1) with Vim's modes and 
"  2) with using the <ESC> key (meaning 
"     you rarely hit <ESC> unnecessarily)
"
"and you
"
"  3) would prefer entering : commands in a modal 
"     command window rather than on the command line 
"
"Then this tip is for you. 

"_____________________________________________________
"Some key features of the command window (see ;help cmdwin)
"that would lead one to be interested in it are:
"
" - One can edit the buffer any way one wants
" - Hitting <CR> results in the line one was one being executed
" - (editing in the command window is much nicer than editing 
"   on the command line)

"_____________________________________________________
"Begin with some mappings:

   nmap <ESC> q:<C-W>_
   nmap q/    q/<C-W>_
   nmap q?    q?<C-W>_

   augroup ECW_au 
     au!
     au CmdwinEnter * nmap   <ESC> :q<CR>
     au CmdwinLeave * nmap   <ESC> q:<C-W>_

   augroup END

"Simple observation:  with these mappings, one can go 
"from normal-mode to cmdwin and back via escape (<ESC>)!

"_____________________________________________________
"Some nice things about the command line that are not present 
"in the usual command window are:
"
" - The <UP> and <DOWN> arrow find all the commands that match
"        the text entered to the left of the cursor 
" - Hitting <C-D> shows the ways in which the typed text can be
"        completed (see :help cmdline-completion)
"
"It is possible to have similar features in the command-window too.        

"For the <UP> <DOWN> feature, add the following au-command event 
"triggered maps:
   augroup ECW_au 
     " musn't do au! again 
      
     au CmdwinEnter : imap   <UP>    <C-O>y0<C-O>:let@/='^'.@0<CR><C-O>?<ESC><ESC>
     au CmdwinLeave : iunmap <UP>
     au CmdwinEnter : imap   <DOWN>  <C-O>y0<C-O>:let@/='^'.@0<CR><C-O>/<ESC><ESC>
     au CmdwinLeave : iunmap <DOWN>

     au CmdwinLeave : :let @/=""
   augroup END

"Now, while in the command window, going to insert mode and hitting 
"the <UP> arrow followed by the n key results in one visiting all 
"the commands that match the text to the left of the cursor when 
"the <UP> key was hit -- then hitting <CR> while on any line causes 
"it to be executed.  Likewise, for the <DOWN> arrow. 

"_____________________________________________________
"Next for the <C-D> feature.  This is slightly more complex.
"Begin by adding the following autocommand event triggered maps:

   augroup ECW_au 
     " musn't do au! again 
     au CmdwinEnter : imap   <C-D> <C-O>y0<C-O>:ECWCtrlD<CR><ESC>
     au CmdwinLeave : iunmap <C-D>
   augroup END

"Then provide this function:  function! s:ECWCtrlD() 
"With this function, hitting <C-D> while in insert mode in the 
"command window results in more information about the text to 
"the left of the cursor appearing on the lines below the cursor.  
"This information can left on the command window or removed 
"by typing u (undo).
"
"The nature of the information provided by <C-D> depends on what
"is to the left of the cursor: 
"  
"  If the stuff to the left of the cursor looks, essentially 
"  like "map " or "map  foo" then the information provided by 
"  <C-D> is the same as the information that appears when the
"  the same stuff is typed on the command line and return is hit. 
"
"  If the stuff to the left of the cursor begins, essentially 
"  like "sf " or like "find " then what is displayed on <C-D> is
"  the glob of the remaining stuff (after appending the remaining
"  stuff with a *)
"
"  If the stuff to the left of the cursor looks like neither of 
"  the above two cases then what is displayed is the glob of the 
"  very last non-space separated "word" (after appending that "word"
"  with a *) 
"
function! s:ECWCtrlD() 

   if (match(@", '^ *[a-z]\?map\s\s*\(\S\S*\)\?\s*$') >=0 )
   
       let s:foo = @"
       let save_more=&more 
       set nomore
       execute ':redir @" |'.s:foo.'|redir END'
       let &more = save_more
       put=@"

       "Keep this next command even though Vim comlains -- it is 
       "a work-around for some "unknown bad thing"
       silent normal 

       return  
   endif


   "sf and find can have space separated arguments
   if (match(@", '^ *\(\(sf\)\|\(find\)\)\ *') >=0 )
       let s:foo = substitute(@", '^ *\(\(sf\)\|\(find\)\)\ *', '', '') 
   else  "pick the trailing non-space separated stuff
       let s:foo = substitute(@", '\(.\{-}\)\(\S\S*\s*\)$', '\2', '')
   endif

   let s:foo = substitute(s:foo, '\s*$', '*', '') "OK if ending has two wild-cards 
   let @"=glob(s:foo)
   if(@" == "") | let @"='no match' | endif
   put=@"

endfunction
if !exists(":ECWCtrlD") 
  command  -nargs=0 ECWCtrlD call s:ECWCtrlD() 
endif

"If one wants to get even more fancy, one can start with the map
"
" nmap <S-ESC> :ECWtobedefined
" 
" wherein the function ECWtobedefined opens up a new buffer 
" in which one can do anything one likes.  Even if this new
" buffer merely mimics the command window, it will the feature
" of co-existing with other buffers -- which is a feature that
" the command window does not have! 
"
" That's all for now.
"
" --Suresh
"
finish







VimTip	{{{1 682: errorformat for Intel ifort 8.0


Intel changed the errorformat for their fortran compiler with version 8.0. An errorformat string that works with the new compiler is:

set efm=%E%.%#rror:\ %f\\,\ line\ %l:\ %m,\%-C%.%#,\%-Z\%p^






VimTip	{{{1 683: HOWTO - Integrate MS .NET and gvim.exe


HOWTO: Integrate MS Visual Studio .NET and gvim.exe

[Disclaimer: This is NOT a tip on how to get Vim to run inside of MS Visual Studio .NET. I have not yet found anyone who can make that work, so this is the next best thing. VisVim.dll seems to only work with VS6.]

If you are someone who prefers Vim and uses ( or must use ) MS Visual Studio .NET for development and you have been struggling with a less than perfect integration of the two, this tip may help you tighten that up. I've been working with the two together since .NET came out and this tip is a compilation of all the tricks and setup I use.

THE KEY: Before you do anything else, do this. goto Tools > External Tools > Add:
	Title: &Vim
	Command: C:\Vim\vim62\gvim.exe
	Arguments: +$(CurLine) -- $(ItemPath)
	Initial directory: $(TargetDir)
This will allow you to use the key combination Alt-t-v to open the current file at the current line in a new vim browser. The browser will start at the directory of that file, so ':e .' will edit the directory of that file.

THE SECOND KEY: In order to effectively use the two together and make sure .NET does not complain about it's files changing, goto Tools > Options > Environment > Documents and ensure these two options are checked:
	+ Detect when file is changed outside the environment
	+ Auto-load changes (if not currently modified inside the environment)

CTAGS: This is an obligatory statement, but a lot of MS developers do not know about ctags. Google for it and use it. This enables you to jump to tags, preview function declarations, use tab completion, and ton of things you can't live without. My personal mappings are:
	map <C-[> <C-T>        " use C-] to goto a tag and C-[ to come back up the tag stack
	noremap <C-P> <C-W>}   " use C-P to preview a tag in a small window
For tag completion, there are a TON of options, but i use vimtip #102 because it's simple and does the job:
	inoremap <tab>   <c-r>=InsertTabWrapper("forward")<CR>
	inoremap <s-tab> <c-r>=InsertTabWrapper("backward")<CR>
One snag for ctags on MS is that the tag pathnames require the old dos style pathnames. Use the appropriate DIR switches to figure yours out:
	set tags=./tags,tags,c:/projects/tags,c:/PROGRA~1/MIEEF7~1/tags

If you must use make at the command line ( I don't compile at command line for .NET but i've gotten it working. not sure where this tip was ), use:
	set autowrite
	setlocal errorformat=\ %#%f(%l)\ :\ %#%t%[A-z]%#\ %m
	setlocal makeprg=devenv\ c:/Projects/MySolution.sln\ -build\ release

Lastly, if you are afraid to leave the IDE because you like Visual Assist's file browser, I'm maintaining a script to emulate that behavior [ProjectBrowse.vim]. It requires the unix find command which can be easily obtained via the cygwin win-unix set of utils.
	map <A-o> :ProjectBrowse c:\Projects\<CR>

May the Vim be with you --heina






VimTip	{{{1 684: Preview Current HTML in Browser on Mac OS X


There are a few tips on previewing current HTML documents in a Windows browser, but none I could find for Mac OS X. By studying the others, though, I stumbled on a mapping that works. The <Enter> at the end anticipates the "Hit ENTER or type command to continue" message. 

:map <Leader>p :!open -a Safari %<CR><Enter>






VimTip	{{{1 685: Search without need to escape frontslashes


This comes in handy if you have the full path of a file in your clipboard, and want to find it in your current buffer.
Instead of using "/" to search, use "?" then paste.  You don't need to escape the frontslashes, so no need to edit the pattern.
If you wish to search forward, just hit "/" and Enter.

If you want to use it again, use the "?" history, not the "/".

If someone knows an easier way, please let me know!

:help /
:help ?






VimTip	{{{1 686: Easier Buffer Switching


The <C-^> command is very handy for fast buffer switching.  Used by itself, it switches you to the previous buffer you were editing.  With a number before it, it switches to that buffer number.  However, I find it's location on the keyboard inconvenient.

With a few extra mappings, buffer switching can be easy indeed.  Pick an unused, easy-to-type char - I picked \ :
   :nnoremap  \  <C-^>

Put that in your .vimrc.  Now to switch to buffer 13, type 13\.  You can also toggle between 2 buffers by simply pressing \.  This is also handy in insert mode: hit <C-o>13\ and you jump to buffer 13, still in insert mode.

Map it to whatever key you find easiest to press - or simply use <C-^>, it's still useful.






VimTip	{{{1 687: Mac OS X clipboard sharing


As of my knowledge there is no clipboard register for Mac OS X unlike Windows (vimtip #21). However you can use pbcopy/pbpaste command to achieve the same thing.

Example
:.!pbcopy                           "Copy current line clipboard
:4,8!pbcopy                      "Copy line 4 to 8
:!echo "%:p" | pbcopy     "Copy current filename to clipboard

:r !pbpaste                         "Paste clipboard content to current line


For more information, :help filter 








VimTip	{{{1 688: lid & cscope = custom grep


Sometimes you want to use quickfix for some other things than grep & make.
You can always replace one of them and then return to what it was.
So, I have in my  .vimrc:
===
fu! Mycscope(func)
    let tmp1=&grepprg
    let tmp2=&grepformat
    set grepformat=%f\ %*[a-zA-Z_0-9]\ %l\ %m
    set grepprg=cscope\ -R\ -L\ -3
    exe "grep ".a:func
    exe "set grepprg=".escape(tmp1,' ')
    exe "set grepformat=".escape(tmp2, ' ')
endf
command -nargs=* CScope :silent call Mycscope("<args>")
===
This will create the command CScope, that does a cscope's "find functions calling this function" with quickfix.
Another example: lid
===
fu! Mylid(arg)
    let tmp1=&grepprg
    set grepprg=lid\ -Rgrep\ -s\ $*
    exe "grep ".a:arg
    exe "set grepprg=".escape(tmp1," ")
endf
command -nargs=* Lid :silent call Mylid("<args>")
===
Bug: sometimes vim is unable to come back from the command, and you have to hit CTRL+C. I have no idea why.








VimTip	{{{1 689: Word Count


To count the words in a file: g<ctrl-g>
To count the words in a block, select the block and once again g<ctrl-g>

The output looks something like this: 
  Selected 6 of 358 Lines; 37 of 2281 Words; 186 of 13426 Bytes

For more information, :help 12.5 (http://vimdoc.sourceforge.net/htmldoc/usr_12.html#12.5)






VimTip	{{{1 690: Reloading a file using a different encoding


You can reload a file using a different encoding if vim wasn't able to detect the correct encoding:
    :e ++enc=<encoding>

For example, on Windows in western Europe, the default encoding is latin1. However I often use vim to edit batch files they must be encoded using the console codepage which is is usually cp850 or cp437. So I reload the file using this command:

    :e ++enc=cp850







VimTip	{{{1 691: gf for standard URL, like file:///C:/myfile.txt



To make gf worked for URL, say, file:///C:/myfile.txt
I copy the following to my _vimrc on Windows

au BufReadCmd file:///* exe "bd!|edit ".substitute(expand("<afile>"),"file:/*","","")

Thanks for Bram to offer me such a tip:
http://groups.yahoo.com/group/vim/message/49108






VimTip	{{{1 692: runtime syntax check for php


Ever wanted to just check your php script to see if it had any syntax errors ? Similar to perl -c ?.  You could always do it by doing php -l, with this little macro, you can do it in your buffer. 

Just add the following line in your .vimrc, and whenever you want to test, press ctrl b

voila. 


map <C-B> :!php -l %<CR>






VimTip	{{{1 693: One page summary of color schemes


With so many color schemes on vim.org to choose from, sometimes it's hard to decide which one(s) to use. I have created a page to show off all the color schemes that I have downloaded from here. Hopefully this page will be useful to the rest of the vim community.

http://www.cs.cmu.edu/~maverick/VimColorSchemeTest/

The page will be updated as I collect more color schemes.






VimTip	{{{1 694: Really *QUICK SAVE* and back to edit


You are about the modify an important file.   You want to save this original file
under a different name (and keep the file view).   Quick, think of a new name...
-- oh, time wasted, for you could have quickly typed in ";s" and got back 
to the modification at hand...
________________________

map ;s   :up \| saveas! %:p:r-<C-R>=strftime("%y%m%d")<CR>-bak.txt \| 3sleep \| e #<CR>
"    Dated-BAKUP                    date number format,                re-edit original
"               first update, else changes get lost on re-edit,
"               saves view (attn: write alone does not save view)
"               thus better than generic copy at OS level,
"               but be careful when split editing

_________________________

The above saves the original file with a date-stamp as part of the filename.
Note that it overwrites throughout a single day.   If you want a more
narrow period of time for overwrites, then supplement above map with hour,
min, or seconds. The 3sleep is there just to visually verify that the
save has taken place.

Happy Vimming...








VimTip	{{{1 695: Naviguer dans l'aide avec un clavier AZERTY


Pour naviguer dans l'aide en ligne de Vim, la touche documentée dans l'aide pour suivre les liens (tags) est Ctrl+].
Sur un clavier français, la combinaison de touches est Ctrl+$ (le même code de touche est envoyé à Vim).

PS: This tip is in french because it is only useful for AZERTY keyboard users, which are AFAIK french speaking people.






VimTip	{{{1 696: Make mouse drag not select text or go into visual mode


It drives me crazy that frequently when I click in a window, it goes into visual mode for a few characters and thus I can't type normal command mode commands.  I'm finding I always have to press "v" to exit visual mode before I can use vim again.

I finally figured out how to disable visual mode using the mouse:

noremap <LeftDrag> <LeftMouse>
noremap! <LeftDrag> <LeftMouse>







VimTip	{{{1 697: FRENCH character maps (not phrenology!)


This illustrates the Power of the Pinkie finger...
(ie. the semi-colon for QWERTY keyboards).

I wanted a scheme which was easy to 
memorize for French characters.

Take a couple of minutes to study the
pattern below, and its "logical" ordering
alphabetically...  once understood, I
hope it will serve you a lifetime of
writing « les belles lettres  ».

Happy Vimming!
______________


"                   FRENCH Mappings
"  scheme in alphabetic order 
"  where _ denotes primary letter 
"
"        à _â  ä 
"          _ç
"        è _ê  ë  é
"          _î  ï
"          _ô  ö
"        ù _û  ü
" 
"         For capital letters, use the ~ or U operator.
"  Note:  French usage does not require putting accents 
"  on capital letters, with the exception of Ç, unless 
"  you're typing all caps, e.g., Ecoutez ! vs. ÉCOUTEZ !
"
"  Note:  map! for Insert and Command-line, i.e. imap & cmap
"
map! ;z à
map! ;a â
map! ;b ä
map! ;c ç
map! ;d è
map! ;e ê
map! ;f ë
map! ;g é
map! ;i î
map! ;j ï
map! ;o ô
map! ;p ö
imap ;q «  »<Esc>hi
"         ^inserts within Quotations
map! ;t ù
map! ;u û
map! ;v ü







VimTip	{{{1 698: mbox archive emails


1. First see:

http://www.vim.org/maillist.php#help

Follow the instructions to get hold of the archive messages you need. For example, I sent an email to the following address to retrieve mails 43413 to 43512:

vim-get.43413_43512@vim.org

They will be returned as individual attachments to a single mail, one reply per request. 

2. Save all the attachments in a new temporary directory, say /tmp/temp. 

3. Download the following script:

http://kmail.kde.org/unsupported/xfmail2mbox.sh

4. Run the script, passing the aforementioned directory as an argument:

$ xfmail2mbox /tmp/temp

(where $ indicates a shell command).

This will create a file called /tmp/temp.mbox, an mbox format file of emails found in /tmp/temp






VimTip	{{{1 699: enable servername capability in vim/xterm


This tip applies only to non-GUI vim running in xterm under X11/XWindows (linux, unix or cygwin).

1. When you want to use vim's 'clientserver' features, you have this problem with non-GUI vim under xterm: 
  - in vim under xterm, 'servername' is disabled by default even when 'clientserver' feature is compiled into vim.
This is different from GUI gvim, where 'servername' is enabled by default.

2. If you want to enable 'servername' for vim/xterm, the first thing to check is whether vim has
'clientserver' feature compiled-in: do ':version' and check for +clientserver; or do 
'vim -h| grep servername' in shell.  If 'clientserver' is compiled in, proceed to step 3.

  If 'clientserver' is not compiled in, you have several choices:
  - symlink vim to gvim (if you have gvim installed).
  - install vim with 'clientserver' support from binaries
  - build vim from sources with clientserver support and install it

3. After you checked that vim has 'clientserver' compiled in, there are several methods to 
enable 'servername' for vim/xterm. Methods are listed below:

Method (A) If you the want simplest solution, just define shell aliases:

For csh/tcsh:       alias vim 'vim --servername vim'
For bash/ksh:         alias vim='vim --servername vim'

The drawback of this method is that when vim will not have
servername enabled when started from a script.


Method (B) When you're non-root user and vim is installed system-wide by sysadmin:

- create directory $HOME/myvim: mkdir $HOME/myvim
- add directory $HOME/myvim to your $PATH, but make sure it appears in
the PATH the first, before all other directories, or at least before the directory
where vim is installed (command 'which vim' tells you where)
- do 'which vim'. Remember directory where system-wide vim is installed.
You'll use name of this directory in the next step, in the 2nd line of the script.
- create script called 'vim' in directory $HOME/myvim, with these 2 lines:
#!/bin/sh
exec /usr/local/bin/vim --servername vim "$@"
- nb: you *must* use full pathname in the 2nd line of the script
- chmod a+x $HOME/myvim/vim
- if your shell is tcsh/csh, do 'unhash'


Method (C) When you are root user and you want to enable 'server' for all users;
or when you are non-root user and you installed vim yourself under your $HOME:

- find out where vim is installed: % which vim
- cd to the directory where vim is installed
- remember name of this directory, you'll use in the nest step
in the 2nd line of the script:
- in same directory, create script called 'vim.s' with this contents:
#!/bin/sh
exec /usr/local/bin/vim.bin --servername vim "$@"
- nb: you *must* use full pathname in the 2nd line of the script
- chmod a+x vim.s
- mv vim vim.bin
- mv vim.s vim
Done.
The drawback of this method is that when you reinstall vim, you need to repeat
the renaming and 








VimTip	{{{1 700: indenting for Java


I needed to do a few tweaks to .vimrc get Java code looking smooth in vim and I'm passing the joy.  This is probably good for at least 80% of Java programmers.  Hope this helps my fellow Java/Vim peeps.

Randy Solomonson

My .vimrc file:
"Take care of indents for Java.
set autoindent
set si
set shiftwidth=4

"Java annonymous classes.  Sometimes, you have to use them.
set cinoptions+=j1






VimTip	{{{1 701: Simple code beautifier


Occasionally, I get code from other people who, for instance, don't like to put spaces in the for-loops or assignments.
For example, what I get looks like
     for(int j=0;j<size;j++)
            if(vector[j]>d)
and what I would like to see is
     for ( int j = 0; j < size; j ++ )
            if ( vector[j] > d )

Here are a few vimrc lines, that can help. Put them in your .vimrc, or .vim/after/ftplugin/cpp.vim (or whatever language you are using),
then you can beautify at least single lines using one mouse click.

nmenu Misc.Beautify.For          :s/for\s*(\s*/for ( /<CR>:s/\s*)\s*$/ )/<CR>:s/\(\i\+\)\s*=\s*/\1 = /<CR>:s/\s*\([=<>!]=\\|[<>]\)\s*/ \1 /<CR>:s/\s*\(--\\|++\)/\1/<CR>:s/\s*;\s*/; /g<CR>
nmenu Misc.Beautify.Func        :s/\s*)/ )/g<CR>:s/\s*\([(,]\)\s*/\1 /g<CR>:s/(\s\+)/()/g<CR>
nmenu Misc.Beautify.If              :s/if\s*(\s*/if ( /<CR>:s/\s*)\s*$/ )/<CR>:silent s/\s*\([=<>!]=\\|[<>]\)\s*/ \1 /<CR>
nmenu Misc.Beautify.Assign      :s/\s*\([-+*\/&\|]\?\)\s*=\s*/ \1= /g<CR>

(Each nmenu-line must be one single line!)

Tip: if you need to beautify several lines, tear of the menu.

Of course, being simple regexp's, these little helpers can be fooled pretty easily by complicated code, but they should work for 90% of your code.

HTH,
Gabriel.







VimTip	{{{1 702: Make html auto-readable in vim


Oft times, I get html files full of &nbsp,&amp,&junk.
To make .htm files readable in vim (don't edit/save the htm file), 
add this to ~/_vimrc

function! Mosh_html2text()
    :silent! %s/&lt;/</g
    :silent! %s/&gt;/>/g
    :silent! %s/&amp;/&/g
    :silent! %s/&quot;/"/g
    :silent! %s/&nbsp;/ /g
    :silent! %s/&ntilde;/\~/g
    :silent! %s/<P>//g
    :silent! %s/<BR>/ /g
    :silent! %s/</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text()  

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh       







VimTip	{{{1 703: Make html auto-readable in vim


REPOSTING, all the HTML on LHS of regexp got converted by the WEB server:

function! Mosh_html2text()
    :silent! %s/\&lt;/</g
    :silent! %s/\&gt;/>/g
    :silent! %s/\&amp;/&/g
    :silent! %s/\&quot;/"/g
    :silent! %s/\&nbsp;/ /g
    :silent! %s/\&ntilde;/\~/g
    :silent! %s/\<P>//g
    :silent! %s/\<BR>/ /g
    :silent! %s/\</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text()  

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh       







VimTip	{{{1 704: Make html auto-readable in vim


REPOSTING, all the HTML on LHS of regexp got converted by the WEB server:

function! Mosh_html2text()
    :silent! %s/&lt;/</g
    :silent! %s/&gt;/>/g
    :silent! %s/&amp;/&/g
    :silent! %s/&quot;/"/g
    :silent! %s/&nbsp;/ /g
    :silent! %s/&ntilde;/\~/g
    :silent! %s/<P>//g
    :silent! %s/<BR>/ /g
    :silent! %s/</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text() 

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh       







VimTip	{{{1 705: Make html auto-readable in vim


Make html readable in gvim:

function! Mosh_html2text()
    :silent! %s/&amp;lt;/</g
    :silent! %s/&amp;gt;/>/g
    :silent! %s/&amp;amp;/&/g
    :silent! %s/&amp;quot;/"/g
    :silent! %s/&amp;nbsp;/ /g
    :silent! %s/&amp;ntilde;/\~/g
    :silent! %s/<P>//g
    :silent! %s/<BR>/ /g
    :silent! %s/</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text() 

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh       







VimTip	{{{1 706: Make html auto-readable in vim


Make html readable in gvim, add this to your ~/_vimrc

function! Mosh_html2text()
    :silent! %s/&amp;lt;/</g
    :silent! %s/&amp;gt;/>/g
    :silent! %s/&amp;amp;/&/g
    :silent! %s/&amp;quot;/"/g
    :silent! %s/&amp;nbsp;/ /g
    :silent! %s/&amp;ntilde;/\~/g
    :silent! %s/<P>//g
    :silent! %s/<BR>/^M/g
    :silent! %s/</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text() 

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh     







VimTip	{{{1 707: Map xmmsctrl commandos in you vimrc file


In case you haven't installed xmmsctrl, you can get it by clicking download on this page:

http://user.it.uu.se/~adavid/utils

Add the following to your vimrc file:

"XMMS mappings
map <silent> <F8> :echo substitute(system('xmmsctrl title'), "\n", "", "")<cr>
map <silent> <F9> :call system("xmmsctrl launch")<cr>
map <silent> <S-F9> :call system("xmmsctrl quit")<cr>
map <silent> <F10> :call system("xmmsctrl play")<cr>
map <silent> <S-F10> :call system("xmmsctrl stop")<cr>
map <silent> <F11> :call system("xmmsctrl pause")<cr>
map <silent> <S-F11> :call system("xmmsctrl shuffle")<cr>
map <silent> <F12> :call system("xmmsctrl next")<cr>
map <silent> <S-F12> :call system("xmmsctrl previous")<cr>






VimTip	{{{1 708: Converting LANG to UTF-8


On my system I converted from a single byte character set (any of ISO-8859-15 type sets) to use a variable multi-byte UTF-8 encoding.  When I did so my mappings that used to work that were set in my ~/.vimrc were wrong because my ~/.vimrc was written to assume ISO-8859-1/latin1.  The LANG environment variable set during user login tells GNU libc6 and most programs written for Unix to use a different character encoding by default.  My new setting of LANG=en_US.UTF-8 incorrectly made vim assume that my ~/.vimrc was also written in UTF-8 and stored as if fileencoding=utf-8.  This was a problem for <M-k> meta key bindings.  Also any character code above 127 in UTF-8 is represented by two bytes instead of only one, so any characters above 127 will be misinterpreted after converting.  A quick solution to make your old file work exactly as intended is to wrap your ~/.vimrc at the top and bottom with 'encoding' commands like this:

set encoding=iso-8859-1

[ bulk of ~/.vimrc file]

set encoding=utf-8

This allows the keys to be correctly assigned as intended when the .vimrc was created.  In my case this was before I changed my LANG setting.

In addition to using a new LANG environment variable set in ~/.bashrc (vim correctly reads it and changes to :set encoding=utf-8) I have also set fileencodings=iso-8859-1 in ~/.vimrc so that it matches the system-default locale setting of libc6.  This is so that all old (and new) files on my disk match up with what is expected by the rest of my system.  Vim will automatically do a file conversion upon reading and writing each file.  This seems safe but more testing is required.  The best reference I found for these issues is:

http://www.cl.cam.ac.uk/~mgk25/unicode.html

related vimtips include vimtip #246 vimtip #546 and vimtip #576







VimTip	{{{1 709: if you create lots of shell scripts


If you create lot of shell scripts, then you'll find this useful:

" automatically give executable permissions if filename is *.sh
au BufWritePost *.sh :!chmod a+x <afile>
" automatically insert "#!/bin/sh" line for *.sh files
au BufEnter *.sh if getline(1) == "" | :call setline(1, "#!/bin/sh") | endif
" automatically give executable permissions if file begins with #!/bin/sh
au BufWritePost * if getline(1) =~ "^#!/bin/[a-z]*sh" | silent !chmod a+x <afile> | endif

Yakov Lerner







VimTip	{{{1 710: Save time by typing and running templates instead of routine code.


The idea is pretty simple.
1.There's template script written in perl (see sources below.)
2. and  mapping in visual mode:
vnoremap <F6> :!perl E:\\Devtools\\vim\\vimfiles\\template\truler.pl<CR>

The template markers are:
TS:<Single string template here>
TB:
<multistring template here>
TE:
TF: <template file name >

So now we are typing following templates and get them transformed :-).

Typing this :
TS:public final static int PROXY_TYPE_{$p2}={$p1};  
1;HTTP
2;SOCKS
3;SSH
4;HTTPS
5;NOPROXY

Now select this template with values below,  press magic button and 'ta-da',
we have this code :

public final static int PROXY_TYPE_HTTP=1;  
public final static int PROXY_TYPE_SOCKS=2;  
public final static int PROXY_TYPE_SSH=3;  
public final static int PROXY_TYPE_HTTPS=4;  
public final static int PROXY_TYPE_NOPROXY=5;  

Here's the same with multiline template, type following: 
TB:
public {$p1} is{$p2}Established() \{ 
    return m{$p2}; 
\}
TE:
boolean;DirectConnection
boolean;SockConnection
boolean;HTTPConnection

and after transforming we'll got this :
protected boolean isDirectConnectionEstablished() { 
    return m_DirectConnection; 
}

protected boolean isSockConnectionEstablished() { 
    return m_SockConnection; 
}

protected boolean isHTTPConnectionEstablished() { 
    return m_HTTPConnection; 
}

I know it's stupid 'copy-paste' and I don't like it, but sometimes  It's required 
and that simple script saving my time. Everthing working under Windoze.
Text::Template you can download it from http://search.cpan.org.

Source below:
---truler.pl-------
use Text::Template;
$tb=0; $te=0;$template_str="";
$template_dir="E:\\Devtools\\vim\\vimfiles\\template\\";
while (<STDIN>){

	if (/^TF:.*/){#file
		
		$_=~/^TF:(.*?)$/;
		$template_file=$1;
		$template = Text::Template->new(SOURCE => $template_dir.$template_file)
		or die "Couldn't construct template: $Text::Template::ERROR";

	}elsif (/^TS:.*/){#line
		$_=~/^TS:(.*?)$/;
		$template_str=$1;
		$template = Text::Template->new(TYPE=> STRING ,SOURCE => "$template_str\n")
		or die "Couldn't construct template: $Text::Template::ERROR";

	}elsif (/^TB:.*/){#line
		$tb=1;
	}elsif (/^TE:.*/){#line
		$te=1;
		$template = Text::Template->new(TYPE=> STRING ,SOURCE => "$template_str\n")
		or die "Couldn't construct template: $Text::Template::ERROR";
	}elsif ($tb==1 && $te==0 ) {
		$template_str.="$_";
	}else {
		
		if (defined $template) {
			chomp($_);
			@p=split /;/;	
			#if ($p > 0) { print "$_\n";
							
				my %vars = (
					p1 => $p[0],
					p2 => $p[1], 
					p3 => $p[2], 
					p4 => $p[3], 
					p5 => $p[4], 
					p6 => $p[5], 
					p7 => $p[6], 
					p8 => $p[7], 
					p9 => $p[8] 	
				   );
				my $result = $template->fill_in(HASH => \%vars);
				if (defined $result) { print $result }
			#}
	 	} #template_file defined
	}#else of TF
}#end while 
--- truler.pl-------








VimTip	{{{1 711: dynamic tag generation for currect file


Ctags will allow to search for a tag associated with identifier(under cursor and/or named).

This script  allows to search for an identifier in current open file without using an identifier, that is 
displays the tags file for current opened file.

Shell script:

cat /usr/local/bin/vimlocal.sh 
echo | /usr/bin/ctags --extra=+fq --if0=yes --file-scope=yes --fields=+afmikKlnsz --c-types=+cdefgmnpstuvx --c++-types=+cdefgmnpstuvx -x -n --filter "$@"   |  tr -s '[ \t]' '@' |sed -e "s,^\([_-~:A-Za-z]\+\)@\([_-~:A-Za-z]\+\)@\([0-9]\+\).*, \3  \1," | sed -e "s,[_-~A-Za-z]\+::,,"|sort -k1 -n  |uniq 

Vim mapping :
map <M-l> <ESC>:!/usr/local/bin/vimlocals.sh % <CR>:

Note :
1. ctags options probably don't have to be so many ... :-) 

2. There are more complex alternatives like excellent taglist.vim which will open and IDE type 
environment but I prefer simple solutions based on unix command-lines. 







VimTip	{{{1 712: Invert a selection (reverse the letters)


The subsitute command is courtesy of Preben 'Peppe' Guldberg

I wrapped the visual mapping around it, to make it simple to use.
Simply enable visual mode (v), highlight the characters you want inverted, and his \is.

For a single workd you can use vw (or viw):
viw\is

vnoremap <silent> <Leader>is :<C-U>let old_reg_a=@a<cr>
                  \\:let old_reg=@"<cr>
                  \\gv"ay
                  \\:let @a=substitute(@a, '.\\(.*\\)\\@=',
                  \\        '\\=@a[strlen(submatch(1))]', 'g')<cr>
                  \\gvc<C-R>a<ESC>
                  \\:let @a=old_reg_a<cr>
                  \\:let @"=old_reg<cr>

For the tip I doubled up all backslashes in the hope this will post correctly.
All backslashes should be single backslashes (depending on how it is displayed).








VimTip	{{{1 713: Console vs. GUI mappings


This is a way to set mappings based on whether GUI or console Vim is running:

function! ModeMapping( guiLhs, termLhs, rhs, ... )
  let mapCommand='map'

  if ( a:0 > 0 )
    let mapCommand=a:1
  endif

  if ( has( "gui_running" ) )
    echo mapCommand . " " . a:guiLhs . " " . a:rhs
  else
    echo mapCommand . " " . a:termLhs . " " . a:rhs
  endif
endfunction

Sample use 1:
	call ModeMapping( "<leader>b", "<leader>c", ":echo 'Salman'<cr>" )

This means that if GUI is running, <leader>b becomes the lhs and the :echo bit becomes the rhs; if no GUI is running, you get <leader>c as the lhs instead.

Sample use 2:
	call ModeMapping( "<leader>a", "<leader>d", "<esc>:echo 'Halim'<cr>gv", 'vmap <buffer>' )

If the GUI is running, <leader>a is the lhs, <esc>:echo etc. is the rhs and the mapp command used is 'vmap <buffer>' (a buffer-specific visual mode mapping).  Note that the last argument is optional (and wasn't there in the last example).







VimTip	{{{1 714: Version independent installation of (g)vim on MS-Windows


Version independent installation of (g)vim on MS-Windows

The installer and the zip versions of the (g)vim distributions for
MS-Windows install (g)vim in a directory hierarchy rooted at vim\vimxy\
where xy in the directory name is the version number. For example, vimxy
would be vim62 for version 6.2. This setup means that the location of
(g)vim.exe is different for every version. This setup makes good sense
if you maintain several versions of vim on your computer. However, if
you only keep one version of (g)vim at a time, it can be convenient to
always have it in the same location. The following shows you one way to
achieve this.

Set up a directory hierarchy as follows
vim\
vim\runtime\
vim\runtime\syntax\
vim\runtime\plugin\
vim\runtime\ftplugin\
vim\runtime\indent\
vim\runtime\doc\
vim\runtime\colors\
vim\runtime\compiler\
vim\runtime\macros\
vim\runtime\tools\
vim\runtime\tutor\
vim\vimfiles\
vim\vimfiles\syntax\
vim\vimfiles\plugin\
vim\vimfiles\ftplugin\
vim\vimfiles\indent\
vim\vimfiles\doc\
vim\vimfiles\colors\
vim\vimfiles\compiler\

1. Put gvim.exe and/or vim.exe, vimrun.exe, xxd.exe, gvimext.dll into vim\

2. Put all the remaining .vim, .txt, and other non-executable files that
are distributed under vim\vimxy\ in to vim\runtime\

3. Put the contents of the distributed vim\vimxy\plugin\ in to
vim\runtime\plugin\ and so on for all the other subdirectories of
vim\vimxy\ including syntax, ftplugin, indent, doc, colors, compiler,
macros, tools, tutor.

4. Put your _vimrc and _gvimrc files in vim\ with the executables.

5. Either ensure that vim\ is in your path, or create shortcuts and/or
batch (bat or cmd) files that can start vim\(g)vim.exe for you.

6. If you have downloaded any scripts from vim.sf.net or elsewhere, put
them in the appropriate spot in the vim\vimfiles\ hierarchy where they
stay separate from the official distribution files in vim\runtime\. In
this way, when you upgrade (g)vim to a newer version, you will not have
to copy, move or do anything with these extra files. For example,
plugins from vim.sf.net go into vim\vimfiles\plugin\ and color scheme
files go into vim\vimfiles\colors\ etc.

7. You are all done. $VIM and $VIMRUNTIME will be set automatically for
you. They will point to vim\ and vim\runtime\ respectively.






VimTip	{{{1 715: Ignore whitespace in diff operations


Because I'm kinda anal about readability in my source files, I end up changing the whitespace in them quite a bit.  For example, I like var declarations to line up, so I have things like:

private static final String      SOME_VAR1   = "This is a var";
private static final String[]    SOME_VAR2   = { "This is a var", "This is a var", "This is a var" };

If I add something that pushes the tab over one, then all these lines get an extra tab stuck in there, meaning that the lines show up as changed in the default VIM set up.

To make this not so, add the "w" command-line option to the MyDiff() function in your _vimrc file.  This file is like in either C:\Vim\Vim62 or C:\Program Files\Vim\Vim62 (if it's not, you should be clever enough to figure out where it is :^).  The default diff call in that function looks like this:

silent execute '!C:\Vim\vim62\diff -a ' . opt . '"' . v:fname_in . '" "' . v:fname_new . '" > "' . v:fname_out . '"'

Just change this to look like this:

silent execute '!C:\Vim\vim62\diff -aw ' . opt . '"' . v:fname_in . '" "' . v:fname_new . '" > "' . v:fname_out . '"'

Just that one option change can make a world of difference!






VimTip	{{{1 716: calling gvim from vc++ for windows.


To bring up gvim from vc++ conviniently (which I do all day,
so I ended up mapping these to function keys with gvim62):

In vc++ do menu->tools->customize->tools:

This allows single gvim window to open any file from msdev:
Name=sendtovim
Command=sendtovim.exe
Argument=<c-z>:cd $(FileDir)<CR>:e $(FilePath)<CR>:$(CurLine)<CR>
Initial Dir=$(FileDir)

If you dont like to use sendtovim.exe, try the --remote option below.

Note: <c-z> brings gvim to foreground - on win2k, gvim gets focus
but won't bring itself to foreground otherwise. You can remove it
if you dont have this bring-to-foreground problem.

Other possible commands you may like are:

To open a new gvim for each file:
Command=gvim.exe
Arguments=+$(CurLine) "$(FilePath)"

Notes: use quotes, when your path/files have spaces in them.

Arguments=:cd $(FileDir)<CR>:e $(FilePath)<CR>:$(CurLine)<CR>/\<$(CurText)\><CR>$(CurCol)|:

This will open vim on the definition of the word under text,
for this you need to have tags file in your source tree:

Arguments=":cd $(FileDir)<CR>:ta $(CurText)<CR>/$(CurText)"

This is the client-server way:

Arguments=--remote +/"\%$(CurLine)l\%$(CurCol)v"  $(FilePath)"

This lets you launch vim with a single key:

In vc++ do menu->tools->customize->keyboard->Tools->UserTool1
Current-key=<Press Pause> 

To keep files in sync:
msdev->tools->options->editor select
   1. save files before running tools
   2. Automatically load externally modified files.
   3. Unselect prompt before saving file.

In ~/_vimrc to update externally modified files:
  :set autoread

- Mohsin 
http://www.cs.albany.edu/~mosh








VimTip	{{{1 717: Executing shell command in Explorer's current viewing directory


Even thought I can press "c" to switch directory if I want to execute a command in the directory that I am viewing with the explorer.vim plugin, but sometimes I don't want to actually change to that directory to execute it because I want to remain in whatever directory I am in such as a root directory of source files.  So I opened up explorer.vim to see if I can add it directly to the plugin, but I found out that it can call a variable g:explFileHandler that stores the user defined function whenever the key 'x' is pressed on a file or directory.  So I used that to implement executing a command in the viewing directory in my .vimrc as follows:

function! MyFileHandler(filename)
  let oldpath = getcwd()
  let currentdirectory = ""
  if(isdirectory(a:filename))
    let currentdirectory = strpart(a:filename, 0, strlen(a:filename) - 1)
  else
    let currentdirectory = a:filename
  endif
  let lastslash = strridx(currentdirectory, "/")
  let currentdirectory = strpart(currentdirectory, 0, lastslash)
  let usercommand = input(currentdirectory . "# ")
  if(strlen(usercommand) > 0)
    execute "cd " . currentdirectory
    execute "!" . usercommand
    execute "cd " . oldpath
  endif
endfunction

let g:explFileHandler = "MyFileHandler"

It will prompt the user with the directory mimicking a shell prompt where the user can enter the command.








VimTip	{{{1 718: Use useful title on exit instead of "Thanks for Flying"


If you're like me, you go to all the trouble of setting up your shell to put useful information
in your xterm title.  But on quitting VIM, there is no longer ANY useful information in the
xterm title-- only "Thanks for Flying VIM"

Adding this line to your .vimrc will make VIM put the current working directory in the
xterm title on exit.  

let &titleold=getcwd()

Should be simple to extend to include other information as well.






VimTip	{{{1 719: vc6 with python


Hi, 

== tip 1 ==
This tip has some similarities with http://vim.sourceforge.net/scripts/script.php?script_id=864

If you want to rebuild the entire project in Visual Studio 6++:

function! RebuildAllVC()
python << EOF
   import win32com.client
   obj = win32com.client.GetActiveObject('MSDev.Application')
   obj.RebuildAll()
EOF
endfunction

There are alot more things you can do, check out: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcug98/html/_asug_application_object.asp
the application in that link is the "obj" in the code.

== tip 2 == 
using VisVim and the new VIM6.3 *-P* option you can get vim to be your default editor inside VS6. 

example:
"gvim -P Microsoft Visual C++"

Note: If VS6 hangs VIM won't close, as a consequence there will still be an instance in the taskbar. Kill it if you wan't to restart VS6 and use VIM!







VimTip	{{{1 720: delete word in FRONT of cursor


I usually use the windows shortcut CTRL-DEL which I couldn't find i VIM. I created this 

imap <something> <esc>ldei

which will _almost_ do the trick.
The problem occur when the cursor is on column=1. The problem is due to when pressing esc from insert mode the cursor will appear to jump back (try iterating esc->i->esc->i). But when at col=1 the "jump back" will not occur.








VimTip	{{{1 721: Auto remove white space when saving


I think it would be convenient to have Vim automatically remove the white spaces before saving to a file.

Just put the following line in your vimrc file. Everytime you issue a :w command, Vim will automatically have white spaces removed before saving.

autocmd BufWritePre * :%s/\s\+$//

I've tried using FileWritePre, but didn't work. Anybody know why?






VimTip	{{{1 722: useful mapping for <space> in normal mode: :nnoremap <space> i<space><esc>


:nnoremap <space> i<space><esc>

If you manually align things vertically (declarations, ascii tables,
trailing comments), you'll find this simple mapping useful and
keypress-saving.

It makes space in normal mode to push rest of the line to the right.
It inserts space,  leaving cursor in same position.

Example. 

We want to align m_foo to be aligned with m_bar:

                 int     m_foo; //  ...
                 mytype_t    m_bar;   // ...

Set cursor right after 'int'. Press space until 'm_foo'
is aligned with 'm_bar'. I like it.







VimTip	{{{1 723: Sasser security & VIEWFILE names


The Microsoft "Security Update" for the Sasser worm has caused the 
naming convention of vim VIEW FILES to change.   
(Yeah, it is very annoying.  Any good explanations?)

The most obvious shock will be the absence of manually set FOLDS.

Tip:  goto C:\Program Files\Vim\vimfiles\view
and replace the "~" at the start of view file names with
"C=-=+Documents and Settings=+USERNAME"
where USERNAME is set to your username.

For example, for Mr. Molar:

                                 "~=+My Documents=+project.txt=1.vim"
          was renamed to

"C=-=+Documents and Settings=+molar=+My Documents=+project.txt=1.vim"

The naming convention of view files 
changed just after the installation of the 
following on a PC running XP. 
Check your timestamps carefully.
See also
:h mkview
:h loadview

Microsoft Security Bulletin MS04-011
Security Update for Microsoft Windows (835732)
Issued: April 13, 2004
Updated: May 4, 2004
Version: 1.3

File Name: WindowsXP-KB835732-x86-ENU.EXE
Download Size: 2647 KB
Date Published: 4/12/2004
Version: 835732

     Sasser worm (W32.Sasser.A and its variants) is currently circulating on the
     Internet. Microsoft has verified that the worm exploits the Local Security
     Authority Subsystem Service (LSASS).   Be sure to use a FIREWALL to protect
     port 445.








VimTip	{{{1 724: Add a dashed line under a title in text documents


This little map that you can put in your vimrc will format sub-titles in text documents easy.

For example if you type:

This Is A Title
This is not

Using this tip place the curser on the title line and hit \H will produce:

This Is A Title
---------------

This is not

Mapping:

" For convinent headers in text files
nnoremap <Leader>H yypVr-o<Esc>






VimTip	{{{1 725: Quick mapping for backing up the file


Add this simple mapping into your vimrc to make a quick way to backup your document.

" For safe measures lets make a quick backup mapping.
noremap <Leader>b :let x=&backup<Bar>set backup<Bar>write<Bar>let &backup=x<Bar>unlet x<Cr>







VimTip	{{{1 726: A simple "boss key" mapping or panic button


" A panic button! So no one accidentally sees words they arn't supposed to.
noremap <Leader>r ggg?G``

with this in your vimrc you can hit \r in a panic and all the text goes to gibberish. So in case you can't type :wqa! fast enough or :mksession

running this again reverses it. Basically it uses VIM's rot13 command on the whole file. quick simple and easy.






VimTip	{{{1 727: Helpfiles and avoiding E21: error with fileencoding for *.txt


In 1:6.2-532+1 helpfiles was changed back to not beeing compressed anymore since that broke :helpg[rep]. That ment that instead of having the suffix .txt.gz they where back to just .txt. Naturally the helpfiles (opened by :help with friends) opens with 'nomodifiable' set since you are supposed to read them and not edit them. For me that made a problem since i had an :au (auto command) in my .vimrc setting *.txt to have the iso-8859-1 (latin-1) fileencoding. Now I got an error everytime I wanted to use the help system. To overcome this I changed my .vimrc from this:

au BufNewFile,BufRead mutt*,*.txt,*/.followup set tw=77 ai nocindent fileencoding=iso-8859-1

to this:

" 'nomodifiable' disallows changes to 'fileformat' and 'fileencoding' so remove those entries in the else clause
function! Noma_workaround()
  if exists("modifiable")
    set tw=77 ai nocindent fileencoding=iso-8859-1
  else
    set tw=77 ai nocindent
  endif
endfunction

au BufNewFile,BufRead mutt*,*.txt,*/.followup call Noma_workaround()

In short this just mean that I call the Noma_workaround() function to determine if I can set the fileencoding or if that will give an error. In that case I jsut set the other options.






VimTip	{{{1 728: Objective C and ctags (for tagexplorer or the like)


All explanations and regex formats are here : http://localhost/teti/share/cocovim.php
On the same page you will find a cocoa syntax file.






VimTip	{{{1 729: Objective C and ctags (for tagexplorer or the like)


I have put some explanations on how to create exuberant ctags for Objective C files here : http://teti.ch/share/cocovim.php
(ctags are used to get a list of methods, classes, etc for fast navigation through files)

On the same page you will find a Cocoa (Mac OS X OpenStep) syntax file.






VimTip	{{{1 730: Objective C in vim (create ctags and use Cocoa syntax file)


I have put some explanations on how to create exuberant ctags for Objective C files here : http://teti.ch/share/cocovim.php
(ctags are used to get a list of methods, classes, etc for fast navigation through files)

On the same page you will find a Cocoa (Mac OS X OpenStep) syntax file.






VimTip	{{{1 731: ObjectiveC in vim (create ctags and use Cocoa syntax file)


I have put some explanations on how to create exuberant ctags for ObjectiveC files (".m") here : http://teti.ch/share/cocovim.php
(ctags are used to get a list of methods, classes, etc for fast navigation through files)

On the same page you will find a Cocoa (Mac OS X OpenStep) syntax file.






VimTip	{{{1 732: On Windows, Quick Launch html and other Microsoft files(Excel,Word) from Vim


First, try the following command in your vim.
  :!start explorer http://www.vim.org/
You wll see the vim home page in the brouser. That's OK.

Then, it'll be much quicker if menu icon is defined like ...
Triple crick on url and crick icon then you'll get the url in your brouser.
But inserting new icon is not easy work so replace existing one. 

Following is the part of "$VIM_HOME\vim\vim61\menu.vim" that shows
"Open New" icon replaced with "Start Explore" definition.

if 1    " disabled; These are in the Windows menu               " Repaced 0 to 1.
  an 1.135 ToolBar.-sep4-               <Nop>
  "an 1.140 ToolBar.New                 <C-W>n                  " Commented.
  vnoremenu 1.140 ToolBar.New   "wy:!start explorer <C-R>w<CR>  " Added.
  tmenu ToolBar.New             Start Exploler                  " Tool tip added.                  
  an 1.150 ToolBar.WinSplit             <C-W>s
  ...
  ...
endif

Note:
The named buffer "w" is used for not disturbing clip board.
Remove comment on Tool tip line.

Enjoy vimming on Windows...








VimTip	{{{1 733: Python the SciTe way...


I just discovered vim, I really liked 'split' capability, I'm so used to edit Python source code on SciTe editor, I really missed the default CTRL-1 to check the sintax and F5 to run the script...

So, this is my suggestion, add these lines to your _vimrc file:

autocmd BufRead *.py set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\"
autocmd BufRead *.py set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
autocmd BufRead *.py nmap <F5> :!python %<cr>

Make your that python is in your path, now when you open any python file just type ":make" to get the syntax errors, use ":cnext", to move to next error, check the help on make (":help make") for more info on how to navigate errors.

As you are checking now, <F5> is mapped to execute the current script. Also I suggest you to use add the following lines to _vimrc:

autocmd BufRead *.py set tabstop=4
autocmd BufRead *.py set nowrap
autocmd BufRead *.py set go+=b

That will make to use a 4 spaces for you tabstop (only visually), it avoids wrapping your code and will add a bottom scrollbar. Now I like vim a litle bit more.







VimTip	{{{1 734: fix 'x' command in virtualedit mode (past end-of-file)


This tip is useful only for those who use virtualedit mode (set virtualedit=all, or set ve=all).

I like virtualedit mode except for behaviour of 'x' (delete character).
When 'x' is used past end-of-line, it does nothing. I wanted it to jump left
to the actual end-of-line so as to start deleting characters there. Below is
'x' redefinition that does exactly this; and it does not break 'x' in non-virtualedit mode:

" redefine x for virtualEdit so that past end of line, it jumps left to end-of-line     
function! Redefine_x_ForVirtualEdit()
    if &ve != "" && col('.') >= col('$')
	 normal $
    endif
endfu!
silent! unmap x
:nnoremap <silent>x x:call Redefine_x_ForVirtualEdit()<cr>








VimTip	{{{1 735: Mentioning 'fileencoding' and 'bomb' values on the status line


This stems with a discussion on the vim-list yesterday and today (27/28 May 2004). It is a modification on one of the examples given under ":help 'statusline'", which is where its workings are explained. (See also ":help expr1" for the if?then:else expression construct).

The (long) line below comes from my vimrc. I recommend copy-paste if you want to use it. It adds, at the left of the right-hand part of the status line, a pair of square brackets containing the value of 'fileencoding' for the file you are editing (or that of 'encoding' if 'fileencoding' is empty). The file's encoding is followed by a comma and B if 'bomb' is functional and has the value 1 (TRUE). Examples are [latin1], [iso-8859-15], [utf-8,B], etc.

The complexity of the value is due in large part to the necessity of (a) specifying explicitly the fields used implicitly when 'statusline' is empty (I hope I didn't forget any of them), and (b) backslash-escaping all spaces and quotation marks.

Now here it is:

if has("statusline")
	set statusline=%<%f\ %h%m%r%=%{\"[\".(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\").\"]\ \"}%k\ %-14.(%l,%c%V%)\ %P
endif

N.B.
1. The command from "set" to "%P" should be all on one line.
2. This tip is rated as "of Vim 5.7" because I think it uses nothing that is new in version 6. But I've never had any version of Vim earlier than 6.1, which means that I cannot be 100% sure of what works, or not, on version 5. (IMHO, if you still have a version 5 Vim, you should upgrade to a more recent version anyway if it is at all possible.)

Happy Vimming !
Tony.






VimTip	{{{1 736: non-native fileformat for your statusline


I like knowing when a file I open is detected as having a non-native file format.
The way to provide this is a function called from within your statusline.  Add the
following lines to your .vimrc and modify as you prefer.  I run unix, but this can
be slightly altered for other platforms too.  If you are on the mac or dos platforms,
simply substitute unix for your platform name in the fuction.

function ShowFileFormatFlag(var)
        if ( a:var == 'dos' )
                return '[dos]'
        elseif ( a:var == 'mac' )
                return '[mac]'
        else
                return ''
        endif
endfunction
hi  User1 term=bold cterm=bold ctermfg=red ctermbg=darkblue

I call it and color the output of this function red with a blue background. Add
the following string to your :set statusline= line in your .vimrc.

        %1*%{ShowFileFormatFlag(&fileformat)}%*

The %* returns the highlighting to normal,  whatever happens to be set at the time.
This is a function that is called each time the statusline is drawn.  It passes in the
value of the variable fileformat, used locally in the function above via the a:var
variable.

Related tips include #145 and #735.  related help items include :help statusline
:help *hl-User1..9* and :help user-functions.  A wiki page that speaks to vim's
auto-detection of fileformat is located at
http://www.vi-improved.org/wiki/index.php/FileFormat







VimTip	{{{1 737: Fine tuning syntax colors


If you want to change just one or two colors in your syntax highlighting, there is a simpler way other than editing color files (or creating new ones).  For example, I wanted to tweak the default colors a bit, so I added the following lines to my vimrc file:

highlight comment ctermfg=lightblue
highlight constant ctermfg=red

This made the comments and constants easier to read on my screen.  Replace "comment" or "constant" with whatever text type you want to change the color of.  Try experimenting with different colors to see what looks best to you.  (This was NOT gone in the gui vim, as I don't use it/have it installed).

For more info see
/usr/share/vim/doc/usr_06.txt






VimTip	{{{1 738: fix META-keys when META-keys break out of Insert mode


Q: My META-keys don't work. When I press META-key in insert mode,
they break me out out of insert mode and execute some normal-mode 
commands.

A: This happens with non-GUI vim under some terminal
emulators -- those which generate escape-sequences for META-characters.
The actually generated escape-sequences are <ESC>a .. <ESC>z.
You must manually configure vim to recognize these escape-sequences
as META-characters, see below. Terminal emulators which are known to
generate these sequences for META-keys are: rxvt (unix), putty (PC), 
teraterm (PC). Vim expects characters 225-250 for META-keys.

Here's how to fix META-keys on vim side:
--
- check what your META-keys generate:
  i<press Ctrl-V><press Meta-A>

if you see ^[a (that is, escape character followed by something),
then add this snippet to your vimrc:

--
" fix meta-keys which generate <esc>a .. <esc>z
let c='a'
while c != 'z'
    exec "set <M-".toupper(c).">=\e".c
    exec "imap \e".c." <M-".toupper(c).">"
    let c = nr2char(1+char2nr(c))
endw 
--

To fix META-keys definitions manually key-by-key:
   set <M-A>=<press Ctrl-V><press Meta-A>
   :imap <press ctrl-v><press Esc>a <M-A>
; repeat each META-key.








VimTip	{{{1 739: Writing a valid statusline


I wanted to write a good looking statusline, grouping all the informations I need about a file and the environment. The needed things were the filename, the format of this file, its type, the position (line, column) of the cursor, the relative position in the file (%) and the date (day/month/year - hours:minutes).

There is *one* thing to always remember when you write a statusline. You have to escape all the blank characters and the " characters. To escape a character you have to use \, so if you want a whitespace you have to do "\ ". 

Now here is the statusline:
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}









VimTip	{{{1 740: vim-vfs wrapper for using vim to edit SFTP and FTP nautilus/gnome-vfs mounts



As of at least GNOME 2.6, you can now create a vitural filesystem mount on your nautilus desktop for SFTP and FTP URI's.  Unfortunately,  you can only use applications that support gnome-vfs extensions (namely gedit).   I have created a wrapper script that
will convert the gnome-vfs URI's into pi_netrw compatible ones so that vim can be used
to edit files on these remote mounts.

See http://tjw.org/vim-vfs/








VimTip	{{{1 741: Outline editing of Python programmes


With the folding function of Vim6 (+folding), we can edit the Python programmes similar to outline program editors such as SciTE.

Add follow lines to .vimrc:

 augroup python_prog
  au!
  fun! Python_fold()
    execute 'syntax clear pythonStatement'
    execute 'syntax keyword pythonStatement break continue del'
    execute 'syntax keyword pythonStatement except exec finally'
    execute 'syntax keyword pythonStatement pass print raise'
    execute 'syntax keyword pythonStatement return try'
    execute 'syntax keyword pythonStatement global assert'
    execute 'syntax keyword pythonStatement lambda yield'
    execute 'syntax match pythonStatement /\<def\>/ nextgroup=pythonFunction skipwhite'
    execute 'syntax match pythonStatement /\<class\>/ nextgroup=pythonFunction skipwhite'
    execute 'syntax region pythonFold start="^\z(\s*\)\%(class\|def\)" end="^\%(\n*\z1\s\)\@!" transparent fold'
    execute 'syntax sync minlines=2000 maxlines=4000'
    set autoindent
    set foldmethod=syntax
    " set foldopen=all foldclose=all
    set foldtext=substitute(getline(v:foldstart),'\\t','\ \ \ \ ','g')
    set fillchars=vert:\|,fold:\ 
    set tabstop=4 shiftwidth=4 nowrap guioptions+=b
  endfun
  autocmd FileType python call Python_fold()
 augroup END

You can use the folding functions (zm, zM, zr, zR, xa, zo, zc, zx...) in editing Python program.







VimTip	{{{1 742: Change filetype based on directory path


I recently installed pyblosxom to do blogging, and I use vim to edit my blog posts.  pyblosxom automatically transforms your .txt files under a certain path into HTML, RSS, or whatever else is appropriate.  Obviously, your .txt files will probably contain HTML, so if you would like to tell vim to use a different syntax highlighting style for files under a directory path, try adding this to your .vimrc:

function SetPathSyntax()
·   if bufname("") =~ "^/path/to/pyblosxom/datadir"
·   ·   set syntax=html
·   endif
endfunction

autocmd BufReadPost * call SetPathSyntax()






VimTip	{{{1 743: Use Alt+Mouse to select blockwise (MS Word like)


If you use mouse to make visual selections, you might have observed that making
blockwise selections is cumbersome (you need to click <LeftMouse> precisely four times). To
make it easier, you can make Vim behave like MS Word using the Alt modifier.

Place the following lines in your vimrc:

  noremap <M-LeftMouse> <LeftMouse><Esc><C-V>
  noremap <M-LeftDrag> <LeftDrag>

You can also change the modifiers and the mousekey to anything else that is valid, e.g:

  noremap <S-RightMouse> <LeftMouse><Esc><C-V>
  noremap <S-RightDrag> <LeftDrag>







VimTip	{{{1 744: Getting the official distribution's latest: syntax highlighting, runtime, docs, plugins, etc


Do you want the latest, official syntax highlighting files, runtime scripts, documents, macros, language support, plugins, etc?  See

	ftp://ftp.home.vim.org/pub/vim/runtime
	ftp://ftp.home.vim.org/pub/vim/runtime/colors
	ftp://ftp.home.vim.org/pub/vim/runtime/compiler
	ftp://ftp.home.vim.org/pub/vim/runtime/doc
	ftp://ftp.home.vim.org/pub/vim/runtime/lang
	ftp://ftp.home.vim.org/pub/vim/runtime/macros
	ftp://ftp.home.vim.org/pub/vim/runtime/syntax
	ftp://ftp.home.vim.org/pub/vim/runtime/tools

Patches and whatnot are distributed on vim-dev, but typically don't contain the updates to files in the directories above.  If you're having a problm with syntax highlighting, for instance, check the syntax repository above just in case its been fixed already.

In my own case, I put experimental versions of syntax highlighting files and plugins that I maintain on http://www.erols.com/astronaut/vim, such as netrw.vim (netrw v46a now supports remote directory listing for example).







VimTip	{{{1 745: Find $VIMRUNTIME in a bash script



I recently needed the value of $VIMRUNTIME in a bash shell script and was forwarded these two terrific solutions I wanted to post publically:

1. by Luc St-Louis

vim --cmd 'echo $VIMRUNTIME' --cmd 'quit' 2> /tmp/VIMRUNTIME.txt
VIMRUNTIME=`perl -pe 's/\r\n//g' /tmp/VIMRUNTIME.txt`
rm -f /tmp/VIMRUNTIME.txt

2. by Jacob Lerner

VIMRUNTIME=`vim -e -T dumb --cmd 'exe "set t_cm=\<C-M>"|echo $VIMRUNTIME|quit' | tr -d '\015' `


Both properly capture Vim's output and handle the trailing line feed, although in remarkable different ways. Feel free to post additional solutions below.







VimTip	{{{1 746: change cursor color in different modes


Sometimes I think I am in insert mode and start writing, then I realize I was in some
other mode when weird thing happen. So I've set a different color and blinking rate for
insert mode and other modes to see at a glance in what mode I am (works only with GUI):

 highlight Cursor   guifg=white  guibg=black
 highlight iCursor  guifg=white  guibg=steelblue
 set guicursor=n-v-c:block-Cursor
 set guicursor+=i:ver100-iCursor
 set guicursor+=n-v-c:blinkon0-Cursor
 set guicursor+=i:blinkwait20-iCursor

see :h guicursor for more options.







VimTip	{{{1 747: Easily keep runtime files up to date


I try to always keep up to date on the latest and greatest patches and runtime files.  It's pretty easy to install the patches against the source code, but there are no patches for the runtime files.

What I do is use an FTP mirroring tool (with a shell script wrapper) that keeps the runtime directory in my source code up-to-date.  I personally use the fmirror tool (from ftp://ftp.sunet.se/pub/nir/ftp/utilities/fmirror/) but I would think any decent tool would work.  Every so often, usually when applying a source patch, I run this script, and watch the output to see if any of the runtime files have been updated.  If so, I change into the vim63/src directory (or whatever version we're at) and do a "make installruntime".

Here's the command I use for fmirror:

/usr/bin/fmirror -k \
    -l $HOME/src/vim63/runtime \
    -p user@domain.com \
    -r /pub/vim/runtime \
    -s ftp.vim.org \
    -S -V3

If there are no changes, I see something like this:

07:36:06 /pub/vim/runtime @ ftp.vim.org -> /home/michael/src/vim63/runtime
07:36:06 Connecting to ftp.vim.org...
07:36:06 Connected.
07:36:08 Remote timezone: -119 minutes from GMT
07:36:11 Mirror finished.

If there are changes, I see the files being downloaded.

Then it's as simple as "cd vim63/src && make installruntime".

Pretty simple and it works for me!  :-)







VimTip	{{{1 748: Get bright background colors in linux console (framebuffer)


To get 16 background colors in a linux framebuffer console to achieve an appearance like in a 16 color xterm, place the following in your .vimrc (you have to use a real escape character instead of <ESC>, try something like <Ctrl-V><ESC>):

if &term =~ "linux"
    if has("terminfo")
        set t_Co=16
        " We use the blink attribute for bright background (console_codes(4)) and the 
        " bold attribute for bright foreground. The redefinition of t_AF is necessary 
        " for bright "Normal" highlighting to not influence the rest.
	set t_AB=<ESC>[%?%p1%{7}%>%t5%p1%{8}%-%e25%p1%;m<ESC>[4%dm
	set t_AF=<ESC>[%?%p1%{7}%>%t1%p1%{8}%-%e22%p1%;m<ESC>[3%dm
    endif
endif

Pseudo code for the terminfo entry:
    if bgcol > 7
        blink = on (<ESC>[5m)
        bgcolor = bgcol - 8 (<ESC>[4...m)
    else
        blink = off (<ESC>[25m)
        bgcolor = bgcol
    end

    if fgcol > 7
        bold = on (<ESC>[1m)
        fgcolor = fgcol - 8 (<ESC>[3...m)
    else
        bold = off (<ESC>[22m)
        fgcolor = fgcol
    end






VimTip	{{{1 749: uuencode and uudecode text in Vim


Hello, this is a tip for beginners.

When you want to attach something in your email, the uuencode is extremly useful.

This is mapping to uuencode and uudecode in BASE64:
supports normal mode and visual mode.

nnoremap <silent> <Leader>ue :%!uuencode -m /dev/stdout<CR>
nnoremap <silent> <Leader>ud :%!uudecode -o /dev/stdout<CR>
vnoremap <silent> <Leader>ue !uuencode -m /dev/stdout<CR>
vnoremap <silent> <Leader>ud !uudecode -o /dev/stdout<CR>

Assumption: you have uuencode installed in your PATH. (for cygwin it is included in the sharutils package, for unix it should be similar)

Similar mapping can be used to any type of filter, such as the C indenter and C preprosessor.



Hope that helps.







VimTip	{{{1 750: Underline Using Dashes Automatically


I have been using this trick for years but only recently figured out how to add the finishing touch. Basically this technique (best executed as a macro) will take a line of text like this:

A Very Important Tip!!!

and change it to two lines like this

A Very Important Tip!!!
-----------------------

Of course in a constant width editor font, this looks a lot more worthwhile. I use this all the time to highlight headings, etc.

Add this to your .vimrc file: 
"cxe- Underline the current line with dashes
map <F5> Yp:s/./-/g^M:let @/=""^M

(Note that ^M's are really returns that you can achieve in Vim with <ctrl-V><ctrl-M>.
The strategy is basically to yank the line you're on with Y, then put it (and your cursor) with p onto the next line. Then comes a single line range substitution that searches for any character and replaces it with a -. The part after the return is only needed by those of us who have hlsearch turned on. I f you don't set the search register to nothing (""), then your whole document will light up and you will need to invest in a seeing eye dog. Note that you can use anything you want instead of - (= and _ spring to mind). Also, I put this under F5, but that's 100% arbitrary and the nice thing about Vim is that you can put it where you want it. And a tip for the tip is that if you use this, you can also easily get a line above AND below the target text. Just do this:
<F5>YkP
Hope someone can find this helpful. (P.S. typing in this form box is torture! The worst thing about Vim is how useless you feel without it!)






VimTip	{{{1 751: Go to line


I do not know if this tips has been given before (not found by searching :-)

A "go to line" mapping, nice if you compile your source code in command prompt and need to go to some specific line quickly while in insert mode

function! GoToLine()
     let ln = inputdialog("Go to line")
     exe ":" . ln
endfunction

imap <C-g> <C-o>:call GoToLine()<CR>
nmap <C-g> :call GoToLine()<CR>

Thanks.






VimTip	{{{1 752: Make <C-Left> <C-Right> behave like in windows


For quite a long time I was annoyed to not be able to use <C-Left> <C-Right> when selecting text in vim. Actually thoses mappings were working but like the W and B keys instead of w and b. The following mappings correct this problem and make those bindings work like in windows.

You may have to enable select-mode for this to work . I personnally source the $VIMRUNTIME/mswin.vim script in my vimrc which make select mode behave like windows. This script is available in the windows distribution of vim. On linux, you may simply put the following command in your vimrc: "behave mswin".
This will make selection work like in windows.

related help topics:
:h select-mode
:h :behave

"editing mapping (make cursor keys work like in windows. ie: <C-Left><C-Right>
"move to next word.
nnoremap <C-Left> b
vnoremap  <C-S-Left> b
nnoremap <C-S-Left> gh<C-O>b
inoremap <C-S-Left> <C-O>gh<C-O>b

nnoremap <C-Right> w
vnoremap  <C-S-Right> w
nnoremap <C-S-Right> gh<C-O>w
inoremap <C-S-Right> <C-O>gh<C-O>w






VimTip	{{{1 753: Make File|Open dialog track the current file's directory


To get the FIle | Open dialog box to default to the current file's directory add:

set browsedir=buffer 

to your vimrc file.






VimTip	{{{1 754: highlighting source between matching curly braces


I was getting far too many errors creating ruby cgi-scripts due to missplaced curly braces, so here's my solution. 
The following ruby script generates a pattern (see below) used for highlighting a codesection from the curly brace under the cursor to the matching brace. It currently finds 12 recursions, you can generate larger patterns reaching deeper by changing the parameter (n=12) in method "generate".

=== ruby script ===============
def next_iteration(text)
  text.gsub( /#{Regexp.quote("a%(x)*b")}/, "a%(%(a%(x)*b)|%(x))*b" )
end

def generate( text, n )
  1.upto(n){ |i| text = next_iteration( text ) }
  text
end

def to_pattern(text)
  text.gsub(/x/,"\\n|[^ab]").gsub(/a/,"\\{").gsub(/b/,"\\}")
end

ax = generate("a%(x)*b", 12).sub(/b$/,"")
# a = starting brace, b = ending brace, x = characters in between
puts to_pattern( "/\\v%(%##{ax}b)|%(#{ax}%#b)/" )
=== ruby script end ===============
"a" and "b" are synonyms for the starting/ending brace, "x" holds the characters in between, if any. Using recursion, the original pattern "a(x)*b" is expanded to the monstrous pattern seen below.
Btw. - have to use %() for grouping in the pattern, as the normal (captivating) variant cannot be used that often in one pattern...

Append the following to your .vimrc (_vimrc on windows):
highlight ShowMatches guibg=darkgrey guifg=white
au! Cursorhold * exe 'match ShowMatches /\v%(%#\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(\n|[^\{\}])*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(\n|[^\{\}])*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*%#\})/'
set ut=30
vimtip #396, vimtip #177
Up to now, creating a pattern for mixing curly braces and brackets haven't been very successful. The resulting patterns grow far too fast.






VimTip	{{{1 755: Using an expression in substitute command


Hardly a day passes by without teaching me some new trick in vim! Here
is something I stumbled upon recently.

You can use an expression as the replacement string in the substitute
command (:s). When the replacement string starts with "\=" it is
evaluated as an expression. This opens whole new avenue of interesting
possiblities. Here are a few examples:

1. Number all the lines in a file:
:%s/^/\=line('.').'^I'/

2. Number a range of lines (from line 10 to line 20):
:10,20s/^/\=line('.').'^I'/

3. Number a range of lines sequentially starting from 1:
:let counter=0|10,20g//let counter=counter+1|s/^/\=counter.'^I'

4. To number all the paragraphs in range starting from 1:
(assuming the paragraphs are separated by one or more blank lines)
:let counter=0|1,20g/^$\n^\s*[^\s]/let counter=counter+1|+1s/^/\=counter.'^I'

Note: The above command does not work for the first paragraph in the file if
there is no blank line above it.

see also:
:help sub-replace-special
:help sub-replace-expression
Happy vimming :)
:wq






VimTip	{{{1 756: Windows key as <Esc> in console (FreeBSD)


I accidentally found that pressing the Windows key or the right mouse key (present on most modern keyboards for PC's) function as <Esc> in FreeBSD 5.1 in the console version of Vim 6.2 (not tested on other versions or *nixes). 






VimTip	{{{1 757: sample switch between number/nonumber


just create 2 functions..
function! NumberNo()
    :set nonumber
    :map <F12> :call NumberYes()<CR>
endfunction

function! NumberYes()
    :set number
    :map <F12> :call NumberNo()<CR>
endfunction
map <F12> :call NumberNo()<CR>







VimTip	{{{1 758: search and sort by selection


Recently I discovered the potential uses of vmap ...

I need to sort log file by some substring (that cannot
be precomputed, because it depends on data).

I would select substring with mouse, then press :g/<S-Insert>/m0
to move matching lines out of the way, it gets tedious, 
so here's the automation using vmap:

With tip, 
1. you select the any part of the string with 
   v<move>
2. then press 0, to move all matching lines to top of the file,
3. or press p, to see other matches.
4. or press $, to move junk to end of file.
5. You figure out more uses.

    " Sort by selection.
    :vmap 0 :<BS><BS><BS><BS><BS>g<M-x>\M<S-Insert><M-x>m0<CR>
    :vmap $ :<BS><BS><BS><BS><BS>g<M-x>\M<S-Insert><M-x>m$<CR>
    :vmap p :<BS><BS><BS><BS><BS>g<M-x>\M<S-Insert><M-x>p<CR> 

I used M-x as a delimiter and very non magic \M modifier
to avoid errors on subtrings like 'c:/xyz/*.*'

Mosh








VimTip	{{{1 759: Selecting your pasted text


In my line of work, I often am pasting HTML into a HTML template file. Usually, I'll want to run certain commands on the pasted text to get it indented, formatted and substituted as I like it. 

For a while, I would note the line number I was on, pasting the text, entering visual line mode and pressing 18G, or whatever line I wanted to go up to.

But using the special mark, '.  , that you may be familiar with, I was able to select my pasted text much more efficiently. Now I can paste, enter visual mode and press '. . The selection goes back into the document to where the paste began, the place where the last edit took place.

Simple but helpful. 






VimTip	{{{1 760: quickly change to a larger or smaller font (gtk2 gvim)


If you regularly switch to a larger or smaller font, for example because someone else looking at your code thinks the letters are too small, or because you want to lay back in your chair while reading a text, this tip is for you.

The following script defines two commands, :LargerFont and :SmallerFont, to allow quick enlargerment of the font used in the gtk2 gui. Adjust the minfontsize and maxfontsize to your needs.

To use this script, put the following code into ~/.vim/plugin/gtk2fontsize.vim or in your ~/.vimrc.

let s:pattern = '^\(.* \)\([1-9][0-9]*\)$'
let s:minfontsize = 6
let s:maxfontsize = 16

function! AdjustFontSize(amount)
	if has("gui_gtk2") && has("gui_running")
		let fontname = substitute(&guifont, s:pattern, '\1', '')
		let cursize = substitute(&guifont, s:pattern, '\2', '')
		let newsize = cursize + a:amount
		if (newsize >= s:minfontsize) && (newsize <= s:maxfontsize)
			let newfont = fontname . newsize
			let &guifont = newfont
		endif
	else
		echoerr "You need to run the GTK2 version of Vim to use this function."
	endif
endfunction

function! LargerFont()
	call AdjustFontSize(1)
endfunction
command! LargerFont call LargerFont()

function! SmallerFont()
	call AdjustFontSize(-1)
endfunction
command! SmallerFont call SmallerFont()







VimTip	{{{1 761: Reviewing code effectively (using quickfix)


Hi,

If you do code reviews on a regular basis, this tip could be of help to you. This tip is about -
1. Helping the reviewer review code
2. Helping the author in collating reviews from various peers
3. Helping the author in fixing the review comments

First learn about quickfix if you don't know about it already (:help quickfix)

If you type your comments in a file in the format as shown below, then the author can use the quickfix mode for zeroing on the exact file/line.
<file_name>:<line_number>: <your comment in a single line>

For filling in the file name/line number automatically, put the following code in your .vimrc/_vimrc/vimrc:
" Code starts
function SavePosition()
   let g:file_name=expand("%:t")
   let g:line_number=line(".")
   let g:reviewer_initials="KG" " Your initials
endfunction
function InsertComment()
   execute "normal i". g:file_name . ":" . g:line_number . ": " . g:reviewer_initials . " - "
   startinsert
endfunction
nmap ,sp :call SavePosition()<CR>
nmap ,ic :call InsertComment()<CR>
" Code ends

Typical review session:
1. A reviewer open the code to review, positions the cursor on the line he wants to comment on and types ",sp"
2. He/She then opens a text file in the same vim session (say my_comment.txt) and types ",ic" - this puts the file name and the line number
3. The comment is typed next to the line number, all in a single line. This makes it possible for the file to be sorted later
4. Send the comments to the author of the code
5. The author collates the inputs from various reviewers into one file (by simply concatenating them) and sorts it. Now the comments are arranged per file, in the order of line numbers (in a file called say, all_comments.txt)
6. Using the :cfile all_comments.txt the author can now navigate through all the comments.

Cheers,
Karthick






VimTip	{{{1 762: Power FTP coming to Mac!


I was really pissed by the lack of VIM support by the FTP applications found on Mac OS X. None of them support VIM as an external editor.

But it's all over!

First off. Download FTPeel (http://freshlysqueezedsoftware.com/products/ftpeel/). It's a great FTP app that has a feature called MagicMirror.
Here is it how it works:
1. Define a local folder as a site root.
2. Define a remote server as the mirror.
3. Drag any files you want mirrored to FTPeel's dock icon!

Well - This features also works from VIM . .! I.e. you open a local file, edit it and press some shortcuts to paste the file to FTPeel - - And FTPeel does it work!

Well, FTPeel had a bug, but I have manually fixed it.

Anyway, to come to the point - Here is what you need to add to your .vimrc:

" FTPeel MagicMirror support
fun! MagicMirrorIt()
    let path = substitute(expand("%:p"), '/', ":", "g")
    let nice_path = substitute(path, "^:", "", "")
    execute('!osascript -e "tell application \"FTPeel\" to open \"' . nice_path . '\""')
endfun

map <C-S> :call MagicMirrorIt()<CR>

Now. First set up FTPeel. Then open your local file and when you want to upload it on the big world wide web - - just hit Control and s!

I think it's pretty smart :-)!

Also as you see it works by doing some Applescript. This is actually a pretty damn smart way of using AppleScript. Maybe there can be made more ways of using Applescript.

Ok, I hope you like my tip!

Kind regards,
Amir
http://amix.dk






VimTip	{{{1 763: Drag Words with C-left/right.


Select a block of chars with C-v <move>, then
press C-l or C-r to drag the selection around.

    :vmap <C-Right> xpgvlolo
    :vmap <C-left>  xhPgvhoho  

Just a though, maybe there is already a builtin
way of doing it in vim?                        
 






VimTip	{{{1 764: Unhighlighting searched-for text


If you have hlsearch on, you might find it bothersome that a string you've searched for stays highlighted until you make another search or type something like "/asothuse," searching for a random string of characters, as the FAQ recommends.

With a simple mapping, this is a breeze. Add this line to your .vimrc:

:map <F3> :let @/ = "" <CR>

This unsets the "last search pattern" register.

This should be a simpler solution to a common gripe.






VimTip	{{{1 765: Complete from filetype syntax file


I discover nice way to handle completetion from syntax file:

autocmd FileType *  execute "setlocal complete+="."k/usr/share/vim/vim62/syntax/".getbufvar("%","current_syntax").".vim"

Of course substitute "/usr/share/vim/vim62/syntax/" with out path...
Bad of this trick is no ability to handle "-" chars (eg. in XSL) in completetion and 
of course complete Vim commands from Syntax file too :(








VimTip	{{{1 766: Yank last line's content, and trim it to the cursor


I often come across these lines below:
                p_ST->localconnectionOption->typeofService = 0;
                p_ST->localconnectionOption->gain = 0;
                p_ST->localconnectionOption->r_reservation = 0
                p_ST->localconnectionOption->r_re

Though Vim has complete mode, it's a wasting time of  repeately typing 'p_ST->local<C-N>->...'. So I write this mapping:

:inoremap <c-f> <ESC>:let g:saved_col=virtcol(".")<CR>ddkYp:exe "normal ".(g:saved_col+1)."\|"<CR>C

Take above lines for example. First, I type one line(with autoindent turn on, the cursor position is shown as "|" after finishing the line with Return):

                p_ST->localconnectionOption->typeofService = 0;
                |


then I use <Tab> and <Space> to move the cursor to the right place:
                p_ST->localconnectionOption->typeofService = 0;
                                                             |

and press <Ctrl>-f, can you see the magic ? It turns out to be:
                p_ST->localconnectionOption->typeofService = 0;
                p_ST->localconnectionOption->|

Fantacy! It saves me lots of time. Hope you like it.

Also, I have something not work out yet. I'd like to position the cursor at the new line according to last line, e.g., use f command to position quickly.







VimTip	{{{1 767: multiple commands at once


you can easily execute more then one command by placing a | between two commands. 

e.g. argdo %s/foo/bar/gc | w 

by adding | w in tyhe above example the multiple find and replace command doesn't get interupted because the last edited file isn't saved.






VimTip	{{{1 768: add/change file extension in current buffer


-----Original Message-----
From: news [mailto:news@sea.gmane.org]On Behalf Of DogWalker
Sent: Friday, August 13, 2004 7:28 PM
To: vim@vim.org
Subject: saveas copying file path to command line

Say I have a file I have loaded by doing
  :view ~/thud/foo/bar.c
I now want to save it as, say ~/thud/foo/bar.c.txt
Is there some way to copy to the command line
the directory or the full path to bar.c file so I can
save the file with a different name in the same
directory (which is not the working directory)
without having to type in the directory manually?

-----Original Message-----
From: DogWalker [mailto:forestiero@qwest.net]
Sent: Friday, August 13, 2004 10:31 PM
To: Dave Silvia
Subject: Re: saveas copying file path to command line

On Friday 13 August 2004 19:12, you wrote:
> How about:
>
> command! -nargs=1 AddExt execute "saveas ".expand("%:p").<q-args>
> command! -nargs=1 ChgExt execute "saveas ".expand("%:p:r").<q-args>
>
> :AddExt .c
>
> Saves the current buffer's file as the current buffer's filename with '.c'
> appended
>
> :ChgExt .txt
>
> Saves the current buffer's file as the current buffer's filename with the
> extension changed to '.txt'
>
> HTH,
> Dave S.

Thanks a lot for the very helpful response. 



-----------------------------------------------------------

see:
:h command
:h <q-args>
:h expand()







VimTip	{{{1 769: Highlighting Current Line


There is another tip vimtip#421 and a script vimscript#555 on how to highlight the current line. But I think that this is much simpler than those.

\%# matches to the current cursor position. Using this one can highlight the whole line

syntax match CurrentLine  /.*\%#.*/
hi link CurrentLine Visual 

or

hi CurrentLine guifg=white guibg=lightblue

to switch off the highlightline, simply do

syntax match CurrentLine "NONE"


I have tested this in (g)vim 6.3 on windows XP 








VimTip	{{{1 770: Alternative to the long reach to the <Esc> or the 2 handed <C-]> for insert mode


You can use this to toggle between normal and insert mode using the same keystrokes for either.

map <silent> ti :let &insertmode=1-&insertmode<CR>
imap <silent> ti <Esc>:let &insertmode=1-&insertmode<CR>

map <silent> ta :let &insertmode=1-&insertmode ^V| if &insertmode ^V| :startinsert! ^V| endif<CR>
imap <silent> ta <Esc>:let &insertmode=1-&insertmode ^V| if &insertmode ^V| :startinsert! ^V| endif<CR>

The difference between ti and ta is the former toggles inserting at the cursor position while the latter toggles inserting at the end of the line.

Note:  You have to use one pardigm or the other at one time.  Combinations of 'i' and <Esc> work fine.  Combinations of ti and ta also work fine, they just don't mix!

That is, if you ti into insert, you must ti or ta out, <Esc> won't do it.  On the other hand, if you 'i' into insert, ti or ta will take you out and back in again.

See:
  :h map.txt
  :h map-<silent>
  :h map_bar
  :h insertmode
  :h startinsert






VimTip	{{{1 771: Paste from the clipboard into a new vim


Bind a keystroke to "xclip -o | gvim -" ( or "xcb -p 0 | gvim -" or "any command which prints the contents of the clipboard | gvim -")

Pressing that key now captures the contents of the clipboard in a new vim window.

I like to use the key described in sawfish as S-Menu.






VimTip	{{{1 772: convert numbers, hex to decimal and vice versa via menu


A quick way to transform hex numbers to decimal or vice versa.
Visual select the number (no leading '0x' allowed, sorry) and select the menu to transform the number.
You need the calculator 'bc' (standard unix, or cygwin).

UNIX:
vmenu 1.220 PopUp.&nr2hex	<ESC>:exec("!echo \\"obase=16;".@*."\\" \| bc -l -q ")<CR>
vmenu 1.220 PopUp.hex&2nr	<ESC>:exec("!echo \\"ibase=16;".toupper(@*)."\\" \| bc -l -q ")<CR>

Windows:
you have to do somthing like
 <ESC>:!bash -c " <see exec(...) above plus extra escaping> "<CR>








VimTip	{{{1 773: Make vim and gvim have the same colors


" Vim color file
" Maintainer:   Marco Peereboom <slash@peereboom.us>
" Last Change:  August 19, 2004
" Licence:      Public Domain

" Try to emulate standard colors so that gvim == vim

set background=dark
hi clear
if exists("syntax_on")
   syntax reset
endif

let colors_name = "putty2"

hi Normal guifg=White guibg=Black
hi ErrorMsg guibg=Red guifg=White
hi IncSearch gui=reverse
"hi ModeMsg
hi StatusLine gui=reverse
hi StatusLineNC gui=reverse
hi VertSplit gui=reverse
"hi Visual gui=reverse guifg=Red guibg=fg
hi Visual gui=reverse guifg=White guibg=Black
hi VisualNOS gui=underline
hi DiffText guibg=Red
hi Cursor guibg=#004080 guifg=NONE
hi lCursor guibg=Cyan guifg=NONE
hi Directory guifg=Blue
hi LineNr guifg=#BBBB00
hi MoreMsg guifg=SeaGreen
hi NonText guifg=Blue guibg=Black
hi Question guifg=SeaGreen
"hi Search guibg=#BBBB00 guifg=NONE
hi Search guibg=#DDDD00 guifg=NONE
hi SpecialKey guifg=Blue
hi Title guifg=Magenta
hi WarningMsg guifg=Red
hi WildMenu guibg=Cyan guifg=Black
hi Folded guibg=White guifg=DarkBlue
hi FoldColumn guibg=Grey guifg=DarkBlue
hi DiffAdd guibg=LightBlue
hi DiffChange guibg=LightMagenta
hi DiffDelete guifg=Blue guibg=LightCyan
hi Comment guifg=Blue guibg=Black
hi Constant guifg=#BB0000 guibg=Black
hi PreProc guifg=#BB00BB guibg=Black
hi Statement gui=NONE guifg=#BBBB00 guibg=Black
hi Special guifg=#BB00BB guibg=Black
hi Ignore guifg=Grey
hi Identifier guifg=#00BBBB guibg=Black
hi Type guifg=#00BB00 guibg=Black

hi link IncSearch               Visual
hi link String                  Constant
hi link Character               Constant
hi link Number                  Constant
hi link Boolean                 Constant
hi link Float                   Number
hi link Function                Identifier
hi link Conditional             Statement
hi link Repeat                  Statement
hi link Label                   Statement
hi link Operator                Statement
hi link Keyword                 Statement
hi link Exception               Statement
hi link Include                 PreProc
hi link Define                  PreProc
hi link Macro                   PreProc
hi link PreCondit               PreProc
hi link StorageClass            Type
hi link Structure               Type
hi link Typedef                 Type
hi link Tag                     Special
hi link SpecialChar             Special
hi link Delimiter               Special
hi link SpecialComment          Special
hi link Debug                   Special







VimTip	{{{1 774: gtk gvim and fontconfig


I switched over to the GTK version of Vim (because the motif version crashes in
my cygwin environment), and was distressed when I saw that my favorite 6x13 and
7x13 fonts could not be found in the font selection dialog.  I found discussions
on similar situations, like missing 6x13 in Gnome Terminal.

So, I spent some time reading the limited documentation on fontconfig, followed
the suggestions posted here, and mangled my .fonts.config enough to give me
6x13.  "Great!", I thought, "7x13 should be easy now.".  Nope.  For the life of
me, I couldn't get anything but 6x13 and 8x13.

I sympathize with folks using GTK2 applications who have very specific font
preferences.  Even if it's possible to get my 7x13 by messing with
.fonts.config, it's WAAAAYYYYY too difficult!  My understanding is that the
intent is a font selection mechanism that is less platform dependant.
Unfortunately, power and flexibility, the cornerstones of Unix-like OS's,
suffered.  So, here I was, after many hours over the course of several days of
screwing around with fontconfig, feeling like I was dealing with a Microsloth
app.  But, I digress...

I thought I would contribute my work-around; call it a hack, if you like, but it
gets me what I want.  It might save the average X font user time and
frustration:

If misc-fixed fonts are missing completely from your system's fontconfig, just
copy the 6x13, 6x13B, and 6x13O fonts to your own directory somewhere and add
that directory to your own config, and you're done.  For example:

$ mkdir ~/.fonts
$ cp /usr/X11R6/lib/X11/fonts/misc/6x13{,B,O}.pcf.gz ~/.fonts
->add "<dir>~/.fonts</dir>" to ~/.fonts.conf

Then, fontconfig only has THAT font to choose from in the 'fixed' family, and
you're home free.  Unless you want 7x13 too...


I want 7x13 _and_ 6x13, but I can't get fontconfig to differentiate them.  So, I
(very easily) made my own versions of these fonts and put them in their own
families:

  - Get the bdf sources for the fonts.  I just downloaded the source package for
    the fonts that were installed on my system, but they should also be easy to
    find through an internet search.

    $ mkdir ~/newfonts
    $ cp path/to/source/font/7x13{,B,O}.bdf ~/newfonts

  - Edit each of these files, changing the family portion of FONT (i.e. the word
    "Fixed") and the value of FAMILY_NAME to "7x13".  A quick ed script can do
    this to several fonts in a jiffy.

  - Use the bdftopcf utility to create your new fonts:

    $ for font in 7x13 7x13B 7x13O ; do
    >   bdftopcf ./${font}.bdf -o ~/.fonts/${font}.pcf
    > done

  - Now, as long as ~/.fonts is in your ~/.fonts.conf, 7x13 will show up in the
    GTK font selection dialog!

This is a one time thing for the fonts you want, and it actually makes choosing
them in the app easier.

Hope this helps somebody out there....








VimTip	{{{1 775: Remapping Caps to Shift


In "keyword #166" a tip for mapping Caps_Lock to Esc was posted.  I never liked having Caps_Lock as Escape though.  I didn't want an easier way to hit Escape, I wanted to prevent unexpected things from happening when I accidently hit Caps_Lock when I was trying to hit Shift.  With Caps_Lock mapped to escape i still got unexpected results.  So here is how your bind Caps lock to the Shift key under Xwindows:

Just put this in a file in your home directory called .Xmodmap
remove lock = Caps_Lock
keycode 66 = Shift_R
remove shift = Shift_R
add shift = Shift_R

Much thanks to avlondono on the #vim channel for his help with this.






VimTip	{{{1 776: Deadkeys / Accented Characters and Mutt integration


Using Mutt and VIM for my email,  I need to write in Spanish a few times a week, but I'm using a US key layout. 

Deadkeys are used for entering accented and special characters.  First you hit a modifier key like apostrophe ( ' ) and then a vowel to get the accented version :  &#972; .   

This tip turns the ' ` ^  and " characters into deadkeys to allow for most all characters used in European languages.
Two functions are added to to turn on deadkeys and turn off deadkeys.  Those functions are then mapped to F-keys.   Finally, an addition to your .muttrc helps start vim in a wordprocessing mode. 

The bulk of the work was done by Claudio Fleiner at http://www.fleiner.com/vim/deadkey.html .  I just wrapped them into functions for ease of use.
---------------------------------------------------------------------------
.vimrc
---------------------------------------------------------------------------
nm <F6> :call DeadKeys()<CR>
nm <F7> :call DeadKeysOff()<CR>

function! DeadKeys()
    :echo "Dead Keys: On"
    let g:DeadKeysOn=1
    " map dead keys
    :imap "a    ä
    :imap "A    Ä
    :imap "e    ë
    :imap "E    Ë
    :imap "i    ï
    :imap "I    Ï
    :imap "o    ö
    :imap "O    Ö
    :imap "u    ü
    :imap "U    Ü
    :imap "y    ÿ
    :imap "<space>    ""<bs>
    :imap ""    ""<bs>

    :imap 'a    á
    :imap 'A    Á
    :imap 'e    é
    :imap 'E    É
    :imap 'i    í
    :imap 'I    Í
    :imap 'o    ó
    :imap 'O    Ó
    :imap 'u    ú
    :imap 'U    Ú
    :imap 'y    ý
    :imap ''    ''<bs>
    :imap '<space>    ''<bs>

    :imap 'c    ç
    :imap 'C    Ç

    :imap `a    à
    :imap `A    À
    :imap `e    è
    :imap `E    È
    :imap `i    ì
    :imap `I    Ì
    :imap `o    ò
    :imap 'O    Ó
    :imap 'u    ú
    :imap 'U    Ú
    :imap 'y    ý
    :imap ''    ''<bs>
    :imap '<space>    ''<bs>

    :imap 'c    ç
    :imap 'C    Ç

    :imap `a    à
    :imap `A    À
    :imap `e    è
    :imap `E    È
    :imap `i    ì
    :imap `I    Ì
    :imap `o    ò
    :imap `O    Ò
    :imap `u    ù
    :imap `U    Ù
    :imap ``    ``<bs>
    :imap `<space>    ``<bs>

    :imap ^a    â
    :imap ^A    Â
    :imap ^e    ê
    :imap ^E    Ê
    :imap ^i    î
    :imap ^I    Î
    :imap ^o    ô
    :imap ^O    Ô
    :imap ^u    û
    :imap ^U    Û
    :imap ^y    xxxx
    :iunmap ^y " this one was giving me problems.
    :imap ^^    ^^<bs>
    :imap ^<space>    ^^<bs>

    :imap ~n    ñ
    :imap ~N    Ñ
    :imap ~~    ~~<bs>
    :imap ~<space>    ~~<bs>
endfunction " deadkeys()

function! DeadKeysOff()
    " Make sure turning them off without having turned them on
    " does nothing bad.
    if !exists("g:DeadKeysOn") || !g:DeadKeysOn
        :echo "Dead Keys not on."
        return
    endif
    :echo "Dead Keys: Off"
    let g:DeadKeysOn=0
    :iunmap "a
    :iunmap "A
    :iunmap "e
    :iunmap "E
    :iunmap "i
    :iunmap "I
    :iunmap "o
    :iunmap "O
    :iunmap "u
    :iunmap "U
    :iunmap "y
    :iunmap ""
    :iunmap "<space>

    :iunmap 'a
    :iunmap 'A
    :iunmap 'e
    :iunmap 'E
    :iunmap 'i
    :iunmap 'I
    :iunmap 'o
    :iunmap 'O
    :iunmap 'u
    :iunmap 'U
    :iunmap 'y
    :iunmap '<space>
    :iunmap ''

    :iunmap 'c
    :iunmap 'C

    :iunmap `a
    :iunmap `A
    :iunmap `e
    :iunmap `E
    :iunmap `i
    :iunmap `I
    :iunmap `o
    :iunmap `O
    :iunmap `u
    :iunmap `U
    :iunmap `<space>
    :iunmap ``

    :iunmap ^a
    :iunmap ^A
    :iunmap ^e
    :iunmap ^E
    :iunmap ^i
    :iunmap ^I
    :iunmap ^o
    :iunmap ^O
    :iunmap ^u
    :iunmap ^U
    ":iunmap ^y
    :iunmap ^^
    :iunmap ^<space>

    :iunmap ~n
    :iunmap ~N
    :iunmap ~~
    :iunmap ~<space>

endfunction

---------------------------------------------------------------------------
.muttrc
---------------------------------------------------------------------------
# Make VI into wordprocessor mode -- auto wrap, backspace to previous line
set editor="vim -c 'set tw=76' -c 'set fo=tcq' -c 'set bs=eol' -c 'set wrap'"







VimTip	{{{1 777: More words searching


Searching a word is nice thing. As you could find in Vim tips, you can search it very fast with ' * ' or ' # ', without
typing word in command window. But what about a searching words or lines? Of course, you type ' / ',  and type words 
or line like '/a few words', or '/some example line with few words'. Too much typing. 

So we can do this much faster. For example, you yank whole line with ' yy ' or ' y$ ', type ' / ' and press <C-R>" 
(Control-R and type "). You will see that line pasted. You can even go in visual mode (' v '), select text with move keys, type ' y ' 
and past it (<C-R>") again; (or you can select text with mouse if you don't like move keys). This is not only for lines, you can select word 
or select as many words as you wish.

Here is little bit of explanation for <C-R>. When you type ' / ' (go in search mode), and after that type <C-R>, you will see
' " ' character. Here Vim ask you to type register number or character from whom will paste content. You can type ' " '(temporary
register), 0-9, a-z, etc. even special registers like ' / '(previous search), ' % '(file name), or more better ' . '(register that contain last inserted word). If you want to see all registers and their content, type ' :display ', and paste what you like.

Note, here i placed quotes in ' character, and " character means that you'll need to type it.

Happy searching !









VimTip	{{{1 778: Speed up Pythoner coding


If you are a Pythoner, I introduce two script file: SuperTab(vimscript #182) and pyCallTips(vimscript #1074). I think they can reduce times of typing and speed up Python coding one times at least. the SuperTab is a very cool script that complete automatically word under the cursor. The pyCallTips is a very useful script . It popup  a window at the bottom of vim in where display the calltips of word under your cursor when you type word. if Both of two script are used together, it will generate perfect effect. let me show you how to do.

The first step is that download and install both of them. Then edit complType="\<C-p>" to complType="\<C-n>" in line 21 in the SuperTab script file. This step is to fix SuperTab script searching backward to forward. And the order of searching is the same as display in the pyCallTips script. Now you create a new Python file, and input:
    import os
and  press <F4>, I call it a "refresh key". Then you continue and input:
    os.ch
 when you type word, you'll find changing continually in the bottom window call "Python Calltips  window". When you input "os.ch", it display like this in the calltips window:
    os.chdir            chdir(path) Change the current working directory to the specified path.
    os.chmod            chmod(path, mode) Change the access permissions of a file.

Maybe the first word "os.chdir" is what you want, you can press <Tab> key, and you'll find the word under the cursor is completed automatically. If you want is "os.chmod", you pree <Tab> key again, "os.chmod" will be completed. It is useful, isn't it? 

It will work well mostly. But if you type like: (it's a example only)
    import sys
    sys.argv[1:].c

It display in the calltips window:
    sys.argv.count       L.count(value) -> integer -- return number of occurrences of value

It is real what you want, but the <Tab> key can't work. Don't worry, the pyCalltips map five key to solve the problem. It is <Alt-1> ... <Alt-5>. You can press <Alt-1> to select the first word, and <Alt-2> to the second, and so on. if the key is not enough, you can map it yourself in the script file.

If you open an exist python file, you don't press <F4> key until you type new "import xxx" or "from xxx import xxx". you can also remap <F4> to other key.

That's all. I wish you enjoy it.






VimTip	{{{1 779: OEM to ANSI conversion


I am using Windows 2000, US system. I have a bunch of text files coming from a DOS machine (OEM charset), with characters above code 127. I would like to convert those files into ANSI charset, so that I can see those characters appropriately everywhere under windows. I looked in newsgroup and other places on how to do this, but found nothing. I came up with this (took me a while, but this seems to be working):

open the file - with vim of course:)
:set encoding=cp437
:set fileencoding=latin1
:wq

you can now reopen the file and the characters should have been converted. I perfer to quit after the conversion so that encoding and fileencoding are reset, but I supopse you can simply set encoding back to latin1.

cp437 is the code page for the OEM charset.
see :help encoding and :help fileencoding








VimTip	{{{1 780: Generalized VISUAL CONTENT onto COMMAND-LINE


Key idea:  Yank the visual area for use on the command-line.

Key use:  searches, complex substitutions, etc.

Refinement:  Make sure all magic characters are escaped. 
(Thanks to vimtip #777 for this.)
Focus on the content of the visual -- independent
of how it was formatted.

Usage:  visual on the area, and hit the TAB key.

DISCUSSION:  imagine searching for this line in your text:
"The price of foobars is $1.89 [see page 7]."

Typing it out literally will not work:

     :/The price of foobars is $1.89 [see page 7]./

The problem is the magic characters.  Escaping them will make it work:

     :/The price of foobars is \$1\.89 \[see page 7\]\./

We really don't have to type it out, just use yank and the " register.
And let vim automatically figure out how to properly escape...

Now suppose elsewhere in the text we have this:
"The price of foobars 
is $1.89 [see page 7]."

Will our previous command work?  No.   It's MULTI-LINE. 
Here's what would work:
     :/The\_s\+price\_s\+of\_s\+foobars\_s\+is\_s\+\$1\.89\_s\+\[see\_s\+page\_s\+7\]\./

That would work even on this:
"The price 
of foobars is     $1.89 
[see page 7]."

That's independence from formatting! 
The secret is the substitution function using whitespace \_s\+
and the 'one or more' operator.

The CODE which magically puts the discussion 
into action (three versions):

"               Yank the " register onto the command-line.
"X- vmap <C-I>  y:/<C-R>"/
"                       ^ plain version without escaping out of magic characters.
"X- vmap <C-I>  y:/<C-R>=escape(@", '\/.*$^~[]')<CR>/
"                        ^ now more fancy.
vmap     <C-I>  y:/<C-R>=substitute(escape(@", '\/.*$^~[]'), "[ \t\n]\\+", "\\\\_s\\\\+", "g")<CR>/
"                                    visual ^ HIGHLIGHTED text placed on the COMMAND LINE.
"                      Input <CR> to perform a SEARCH-, 
"                      otherwise EDIT the COMMAND-LINE containing the yanked text. 
"                 Function ESCAPE to prevent magic characters.
"                 4-tuple function SUBSTITUTE will generalize white spaces & EOL,
"                                  ^ so that string will be independent of formatting!
"  USAGE:  visual on desired area, and simply hit TAB.
"          To search, follow up by carriage return.
"          Else, you may modify the command line to suit your purpose.








VimTip	{{{1 781: Changing the hotkey for "&Diff with Vim"


"&Diff with Vim" is a handy tool to have in Explorer, but it's more common to "&Delete" multiple files via the File menu or context menu by hitting the 'd' hotkey. Personally, I'd rather have the hotkey be changed to 'f', which isn't occupied, making the command "Di&ff with Vim".

To do this, edit the gvimext.dll file in your vim installation directory (e.g., C:\Program Files\Vim\vim63\gvimext.dll). Note that this is a binary file but you can still get it done with Vim. Look for the string "Diff with Vim", and simply move the '&' from its original position to a new one (in our case, before one of the f's). Restart your computer (or at least the explorer process) and you'll see the new menu item.






VimTip	{{{1 782: Jump to definition of entity under cursor


This is what I use when reading/editing DTDs that make use of entities heavily:

:map <Leader>e yiw ?<!ENTITY % <C-R>"<CR>

That will map <Leader>e to search backwards for the definition of the entity under the cursor, then you can just CTRL-o back to where you were. Makes reading DTDs less painful. A second version of this should support external entities, anyone feel obliged? :)






VimTip	{{{1 783: Use the return key to get out of insert mode


I found myself spending way too much time in insert mode, because it takes so much effort to hit <ESC>, or alternatively <C-[>. To train myself to use insert mode only for what it's meant for - namely inserting text - I wanted to make it as easy as possible for myself to get out of insert mode.

My solution: map <CR> to <ESC>! Pressing the return key at the end of an insert operation feels very natural, and it is one of the more accessible keys on the keyboard. For inserting multiline text, you can use shift-return, which really doesn't take that much getting used to.

If you want to give it a try, put the following in your .vimrc:

inoremap <CR> <ESC>







VimTip	{{{1 784: Word under cursor for command


During editing, there are many situations where one would like to do a command based on the word under cursor. Idea is to yank into a register and then use this register automatically.  Basis of this functionality are two commands
1) Yanking into a register
     e.g: "zyw - will yank the word into z reg, "byy - yanks the line into b reg
 2)  Concatenating the register to a command and executing it.
     e.g:  :exe "/".@z.""<CR>  - searches for string in z reg      

Some more e.g:
a) Lets say that you have a file that has a list of files.  You don't want to edit all the files, but selectively.  
     :map <F2> "zyw:exe "vs ".@z.""<CR>
      Pressing <F2> will open the file in vertically split window
b) Browsing a text file and saving all those difficult words you want to refer to during leisure
     Open the text file and in a split window open an empty file.
    :map <F2> "zyw<C-w>wo<Esc>"zp<C-w>w
    yank the word under cursor, change window, paste and return
c)  Help in help in help
     :help 
     :map <F3> "zyw:exe  "h ".@z.""<CR>
     Press <F3> on any word and we can see vim help for that keyword.

More examples left to the fertile imagination of the reader. Attraction of this, to me, is to use the key strokes that we use normally to automate tasks. We can write these mappings on the fly for new type of tasks, or include in the .vimrc for routine tasks.

Have fun and as Bram says Happy Vimming!!!







VimTip	{{{1 785: Toggle Between Tabs and Spaces


I write code for a large company and often work with other developer's code.  I personally don't choose to use all the language/formatting stuff in Vim, but I do like to quickly switch between using tabs and using spaces when I hit the <TAB> key (to integrate with the "current" file formatting).

Here is a snippit from my .vimrc which enables my default settings (using 4 spaces for every <TAB>) and a mapping to <F9> to toggle the settings:

    " virtual tabstops using spaces
    set shiftwidth=4
    set softtabstop=4
    expandtab

    " allow toggling between local and default mode
    function TabToggle()
        if &expandtab
            set shiftwidth=8
            set softtabstop=0
            noexpandtab
        else
            set shiftwidth=4
            set softtabstop=4
            expandtab
        endif
    endfunction
    nmap <F9> mz:execute TabToggle()<CR>'z






VimTip	{{{1 786: Character-set translation


Benji Fisher's foo.vim (vimscript #72) contains a Transform command that I initially thought would be very helpful:  I tend to swap double and single quotation marks around, as well as other pairs of characters.  Unfortunately, the original command fails in this case.  Below is an updated version which is probably slower, but more powerful, as well as a map for my favorite way to use it.

Also included is a character-switching function I developed in the process, but ended up including inline for efficiency.  It turns out that directly assigning to a character in a string (let string[i] = a:new[pos]) is illegal, probably because the rhs can include more than one byte.  StrSwitchPos() takes care of that, but doesn't enforce a single-byte replacement.


" Translate character sets, either in the current line, on a range, or in a string
" Note that in this version, unmatched characters in old are deleted
command! -nargs=* -range Transform <line1>,<line2> call Transform(<f-args>)
function! Transform(old, new, ...)
  let string = a:0 ? a:1 : getline('.')
  
  let i = strlen(string)
  while i > 0
    let i = i - 1
    let pos = stridx(a:old, string[i])
    if pos > -1
      let string = strpart(string, 0, i) . a:new[pos] . strpart(string, i + 1)
    endif
  endwhile
  
  if a:0
    return string
  else
    call setline('.', string)
  endif
endfunction

noremap <silent> "" :Transform "' '"<CR>

" Spin-off from the above: switch a single character specified by index
fun! StrSwitchPos(string, pos, char)
  return strpart(a:string, 0, a:pos) . a:char . strpart(a:string, a:pos + 1)
endfun







VimTip	{{{1 787: A mapping that invokes a function with a count prefix.


" Echoes "Foo: 42" when one types "42,a".

function! Foo(count)
  echo 'Foo: ' . a:count
endfunction

command! -nargs=1 FooCmd call Foo(<args>)                           

map ,a :<C-U>FooCmd(v:count)<CR>







VimTip	{{{1 788: Need Function to setup dirs.


I have this in my ~/_vimrc

if expand($DOC) == "" && isdirectory("d:/doc")
 let $DOC = "d:/doc"
endif
 






VimTip	{{{1 789: Automatically redate file headers


I keep forgetting to change the dates in my file headers.  Even though it isn't extremely important before the release time, I found it helpful to automate the process.  The following is tuned more for Rebol headers than anything else, but it works for most types of files.  As a bonus, it increments the last part of a version field; that can be commented out if it isn't desired.

I should probably search for the end of headers marked by comment leaders (such as Vim scripts), but haven't gotten around to it.  It also fails to find version numbers that don't terminate at the end of the line.

  "Redate file headers automatically
  autocmd BufWritePre * call RedateHeader()
  function! RedateHeader()
    " Mark the current position, and find the end of the header (if possible)
    silent! normal! msHmtgg$%
    let lastline = line('.')
    if lastline == 1
      " Header not found, so use fifteen lines or the full file
      let lastline = Min(15, line('$'))
    endif
    
    " Replace any timestamps discovered, in whatever format
    silent! execute '1,' . lastline . 's/\m\%(date\|changed\?\|modifi\w\+\):\s\+"\?\zs\%(\a\|\d\|[/, :-]\)*/\=strftime("%d-%b-%Y")/ie'
    
    " Increment the version marker
    silent! execute '1,' . lastline . "g/[Vv]ersion:/normal! $\<C-a>"
    
    " Restore the marked position
    silent! normal! 'tzt`s
  endf
  
  function! Min(number, ...)
    let result = a:number
    let index = a:0
    while index > 0
      let result = (a:{index} > result) ? result : a:{index}
      let index = index - 1
    endwhile
    return result
  endf







VimTip	{{{1 790: ms-word files (viewing and diff'ing)


antiword (http://www.winfield.demon.nl/) is written by Adri van Os
windows version can be found at:
(http://www.informatik.uni-frankfurt.de/~markus/antiword/)

download and install it (and put it in your path)

antiword takes a ms-word filename from the command line and spits it out in text/plain. it does not take input from stdin

all you gotta do to get vim to view ms-word files is to add lines to your .vimrc similar to:

autocmd BufReadPre *.doc set ro
autocmd BufReadPre *.doc set hlsearch!
autocmd BufReadPost *.doc %!antiword "%"

now, when you're curious you can do: vim resume.doc to view a text version of your ms-word document (hitting <enter> on .doc file in your .vimprojects list works too)

but that's not too fun on it's own. 

one thing ms-word can't do (properly), is do a diff on two versions.
however, if you're on a windows system, in explorer, try -> selecting resume-1.1.doc and resume-1.2.doc -> right click -> "Diff with Vim"

you could probably also do: vim -d resume-1.1.doc resume-1.2.doc 
to achieve the same effect






VimTip	{{{1 791: How to Search for a "non-Ascii Character"


Occasionally when you've pasted into VIM from some other application, you get a pesky visible non-ascii character. You can do a ga command to see what it is, but you might want to search for it or substitute it; here's a technique:-

place cursor on the character.

yl            # yank one character into unnamed buffer
/<C-R>"   # pull unnamed buffer contents onto search  (that's Control-R)

:h ga
:h c_ctrl-r







VimTip	{{{1 792: Preloading registers


There never seem to be enough spare keys for maps.

It's possible however to preload VIMs registers in .vimrc with your frequent commands eg


let @m=":'a,'bs/"
let @s=":%!sort -u"

here's a twisted one
let @y='yy@"'

The command is executed by doing a @m

You can overwrite them of course when doing a recording or a plain yank; I prefer to leave registers a-q for yanks or recordings and preload the others






VimTip	{{{1 793: searching phrases visually module spaces.


This builds on two previous tips to search for sentences.

What: To re-search for a phrase again, ignoring space differences.

How: Visually select a phrase with the mouse and press //
 to find the phrase again (modulo spaces).

    :vmap <silent> //    y/<C-R>=substitute(escape(@", '\\/.*$^~[]'),"[ \\t\\r\\n]\\+","\\\\_s\\\\+","g")<CR><CR>

How, it escapes metachars in selection, 
and changes spaces in selection to generic space+.

HTTP post might garble the backslashes in the mapping above, it
has 2,2,2,2,2,4,4 backslashes.

- Mosh http://www.cs.albany.edu/~mosh


 






VimTip	{{{1 794: Scripting - Indirectly Referencing Variables


It is possible to indirectly reference a variable using {} (curly braces) in your VIM script. This give you the ability to build up variable names on-the-fly and subseqnetly reference the data that those variables hold.

For example:

:let richard_name = "Richard"
:let name_pointer="richard_name"
:echo {name_pointer}

will display the string "Richard" on screen

Another example:

:let richard_name = "Richard"
:let alan_name = "Alan"
:let postfix="_name"
:let name_pointer = "richard" . postfix
:echo {name_pointer}
:let name_pointer = "alan" . postfix
:echo {name_pointer}

will display "Richard" then "Alan" on screen.









VimTip	{{{1 795: Simulating arrays with VIM


It is possible to simulate arrays in VIM, without recourse to third party scripts or libraries. This can be done by dynamically constructing variable names, and then referencing their data.

For example, implementing a 1 dimensional array :

:let interests_0="Running"
:let interests_1="Swimming"
:let interests_2="Inline Skating"
:let interests_3="Cycling"
:let j = 0
:while j < 4
:  let entry = 'interests_' . j
:  echo entry . ':'
:  echo {entry} 
:  let j = j + 1
:endwhile

This can be extended to 2 or more dimensional arrays :

:let interests_0_0="Walking"
:let interests_0_1="Running"
:let interests_0_2="Jogging"
:let interests_1_0="Backstroke"
:let interests_1_1="Butterfly"
:let interests_1_2="Front Crawl"
:let j = 0
:while j < 2
:  let i = 0
:  while i < 3
:    let entry = 'interests_' . j . '_' . i
:    echo entry . ':'
:    echo {entry}
:    let i = i + 1
:  endwhile
:  let j = j + 1
:endwhile

Or arrays of records :

:let academic_0_graduation_year="1995"
:let academic_0_college="Bristol Polytechnic"
:let academic_1_graduation_year="1998"
:let academic_1_college="Bristol University"
:let j = 0
:while j < 2
:  let year = 'academic_' . j . '_graduation_year'
:  echo {year} 
:  let college = 'academic_' . j . '_college'
:  echo {college} 
:  let j = j + 1
:endwhile








VimTip	{{{1 796: Search only over a visual range


If you want to be able to select an area of text within a file and then search for occurrences of a string only within that selection.  Then you can add the following to your .vimrc.

This creates 2 visual maps, / and ?, the same command you would use in normal mode.  Visually select a range and press /, enter your usual regex and hit enter.

function! RangeSearch(direction)
  call inputsave()
  let g:srchstr = input(a:direction)
  call inputrestore()
  if strlen(g:srchstr) > 0
      let g:srchstr = g:srchstr.
                  \ '\%>'.(line("'<")-1).'l'.
                  \ '\%<'.(line("'>")+1).'l'
  else
      let g:srchstr = ''
  endif
endfunction
" Each map should be on a single line
vnoremap <silent> / :<C-U>call RangeSearch('/')<CR>:if strlen(g:srchstr) > 0\|exec '/'.g:srchstr\|endif<CR>
vnoremap <silent> ? :<C-U>call RangeSearch('?')<CR>:if strlen(g:srchstr) > 0\|exec '?'.g:srchstr\|endif<CR>


The execute is performed outside of the function so that the values remain highlighted (based on the hlsearch option), and the search history is automatically updated.  So if you press / (in normal mode instead of visual mode) and press the up arrow, you will see your previous search which can be easily modified.







VimTip	{{{1 797: All folds open at startup or just openen file


when you set foldmethod=indent all folds are closed when you open a file. If you set the foldlevel to a high setting files are always started with opened folds. Put the settings below in your .vimrc

set foldmethod=indent
set foldlevel=20







VimTip	{{{1 798: Split current window and search for word under cursor in new window


:map zm :let @/=expand("<cword>") <BAR> split <BAR> execute 'normal n'<CR>

See
:h cword
:h <BAR>
:h split

*** -----Original Message-----
*** From: Chandrasekaran V. [mailto:chandrasekaran_v@hotmail.com]
*** Sent: Friday, October 01, 2004 6:58 PM
*** To: vim@vim.org
*** Subject: Searching in another (split) window
*** 
*** 
*** Hi all,
***     Is it possible through a key mapping sequence, to do the following:
*** 
*** I have a file open in split windows. ie., only two windows are 
*** active and 
*** both have the same file.
*** I want to initiate a search of a word under the cursor in one 
*** window and let 
*** the other window
*** show the place where the search-hit happened, while the current window 
*** doesn't change its
*** view. Is this possible to do using some key mapping? Please let me know.
*** 
***    Thanks a lot,
***    chandra.

This is rather rudimentary, but it works.  Feel free to enhance to your liking:

	:map zm :let @/=expand("<cword>") <BAR> wincmd w <BAR> execute 'normal n'<CR>

Then for successive matches, just type 'n' or '/<CR>', etc.  Use normal window motion command to return to original window.  E.G.:

	:wincmd w

	<C-W>w

	[mouse click on desired window]

Or, better still:

	:map zm :let @/=expand("<cword>") <BAR> split <BAR> execute 'normal n'<CR>

This just splits the current window and starts you at the next occurrence of the word under the cursor in the new split.  Repeat search as usual.  Close the split window when you're done.  You return to the original window at the cursor position you left.

HTH:

thx,
Dave S. 







VimTip	{{{1 799: Searching for files


You can add the following to you .vimrc file:

" find files
fun! FindFiles()
  let $filename =  input("Enter file name to find: ")
  let $error_file = $HOME."/.findfile.output"
  silent! exe "!find . -iname \"".$filename."\" \| xargs file \| perl -pe 's/:/:1:/' > ".$error_file
  cfile $error_file
  copen
  redraw!
endfun
nmap \f :call FindFiles()<CR>

Then, when in normal mode, type "\f" (or any other mapping that you prefer). This will give a prompt for a file name pattern to search for. Then, all the file names that match this pattern (under the current directory) will be displayed in the quich fix window, along with a description of each of one of them.

Notice, the search is done in a recursive manner. It is case insensitive, and you can use wildcards. If you want to use a regular expression, you can call "find" with the "-regex" or "-iregex" flags.

Background:
The function uses some standard gnu *nix utitlities: find, file. 
You also need perl to be installed.






VimTip	{{{1 800: Sorting lines in a file based on the number of words in each line


Here is one use of the substitute with an expression (:help
sub-replace-expression) I needed to sort a file according to the number of
words in each line. Using the :s command, at the begining of each line, I
insert the number of words it contains. 

To simplify sorting (using the excellent VisSort, see
http://mysite.verizon.net/astronaut/vim/), instead of inserting a number, I put
the corresponding character (plus 64, to start with A).

Here is the expression I use:

"%s/^.*/\=nr2char(strlen((substitute(substitute(submatch(0), "\\S\\+", "x", "g"), "\\s","","g")))+64) . "\t" . submatch(0)         

Now decomposed in parts, from the inside out:
part 1 = substitute(submatch(0), "\\S\\+", "x", "g")
  replace all consecutive non space by a single x (each word is now a single x)

part 2 = (substitute(part 1),"\\s","","g")
  remove the spaces between "x"
  
part 3 =  (strlen(part 2)
  count the number of "x"

part 4 = nr2char(part 3)+64
  get the ASCII char representing the number of words + 64
  
I replace all lines (^.*) by that ASCII char, followed by a tab and the initial line itself.

I can then sort, then remove all characters between the begining of lines and
the first tab.
                             






VimTip	{{{1 801: Folding of (gnu)make output


I regularly use the compiler output window of the QuickFix feature (see help on 'quickfix' and 'copen') to navigate the compiler output. Working on a largish software system with multiple directories with subdirectories in them, the list can get quite long. I use the following entries in my .vimrc to automatically fold on each subdirectory, and open folds containing errors (the string 'error:'). Aditionally 'zw' open also the folds containing the string 'warning:', while 'zq' switches back to the original.

"Folding of (gnu)make output
au BufReadPost quickfix setlocal foldmethod=marker
au BufReadPost quickfix setlocal foldmarker=Entering\ directory,Leaving\ directory
au BufReadPost quickfix map <buffer> <silent> zq zM:g/error:/normal zv<cr>
au BufReadPost quickfix map <buffer> <silent> zw zq:g/warning:/normal zv<cr>
au BufReadPost quickfix normal zq








VimTip	{{{1 802: Specify what you do not want to have in a search and other helpful searches.


Sometimes, I found useful to specify in a search or a substitution what I do not want to have. There is a way with Vim to do such a thing:
/^\(\(The_Regular_Expression\)\@!.\)*$

This will find everything but the regular expression you have specified. For example, if we want to find all the lines not containing the word 'foo', simply do:
/^\(\(.*foo.*\)\@!.\)*$

If we want to find a more complex regular expression on multiple lines, like all the lines which do not begin with 'foo' with 'bar' somewhere else and the word 'magic' at the end of the next line, do:
/^\(\(^foo.*bar.*\n.*magic$\)\@!.\)*$

Another thing useful in searches and substitutions is to ommit some information, for instance, suppose we want to find every 'foo' with 'bar' somewhere else on the line, but we do not want to take the 'bar' part in the search (let's say not highlight it if the hlsearch is set), we can do:
/foo\(.*bar\)\@=
/foo.*\(bar\)\@=
/foo.\{-}\(bar\)\@=

The first one will highlight only 'foo' in lines containing both 'foo' and 'bar'. The second one will highlight 'foo' and everything up to the longest much where 'bar' appear on the line. The third one, will do the same thing, but with the shortest match (non-greedy). So, if there is more than one 'bar' on the same line, the search will stop right before the first occurrence of 'bar'.

We can also do the opposite. Let's say for example finding all the 'foo' with 'bar' some place else without highlighting the 'foo', we can do:
/\(foo.*\)\@<=bar
/\(foo\)\@<=.*bar
/\(foo\)\@<=.\{-}bar

The first one will highlight only 'bar' in lines containing both 'foo' and 'bar'. The second one will highlight everything right after 'foo' up to the last 'bar' on the line. The third one will highlight everything right after 'foo' and up to the first 'bar' (non-greedy).

There is also a way to specify that a part of the regular expression should not be there. As an example, if we want to search for all the lines where there is no word 'foo' preceding the word 'bar', we can do:
/\(foo.*\)\@<!bar

Or, on the other sie, find all the word 'foo' where there is no 'bar' following, we can do:
/foo\(.*bar\)\@!

Now, let's see another kind of search. Imagine we want to find every 'bar' where there is no 'foo' before it. We can do such a thing 

There is a way with vim to specify where the beginning of the search pattern should start. As an example, suppose we want to find the lines beginning with 'foo', with the word 'bar' somewhere else and then 'magic', but that we only want to highlight 'magic' and everything up to the end to the line. We can use 'zs' for that like this:
/^foo.*bar.*\zsmagic.*

We can also do the opposite, specify where the search sould stop highlight, for example, if we want to highlight every 'foo' with 'bar' with 'magic' but not highlighting 'magic', we can do:
/foo.*bar.*\zemagic
/foo.*bar.\{-}\zemagic

The last example was non-greedy, that is, mathches up to the first occurence of the word 'magic' in a line.

Other interesting searches are the beginning of a file. For example to find the first word of a file, we can do (this one needs the +syntax feature when compiled):
/\%^\_.\{-}\<.\{-}\>

Or the first occurence of a word in a file:
/\%^\_.\{-}\zsVIM

We can also search for something at the end of a file. For example, the last occurence of 'VIM' in a file (this one is tricky):
/VIM\ze\(\(VIM\)\@!\_.\)*\%$

It finds the word 'VIM' where there is no word 'VIM' after it until the end of the file!

There are a lot of other searches of substitutions pattern out there. But I use these very often for complex substitution (often for multiple line purpose).

For more information, you can type:
:h /\@=
:h /\@!
:h /\@<=
:h /\@<!
:h /\@>
:h /\zs
:h /\ze
:h /\%^
:h /\%$







VimTip	{{{1 803: Saving a file


In order to save a file you'll have to come out of the insert mode, commonly by hitting the Esc key.

Once you are up there to hit the Esc key, why not make it save the file too with a few more hits.
This can be done by simply adding the following line in the .vimrc file:

map <Esc><Esc> :w <CR>

Note: Mapping with a single Esc is somehow causing problems with the Up/Down/Left/Right arrow keys.






VimTip	{{{1 804: single 'tags' file for a source tree


At the top of a source tree, create a tags file by

% ctags -R

(assuming Exuberant Ctags).  The -R (or --recurse) option tells ctags to recurse into directories.

Then, set the tags option in ~/.vimrc as

set tags=tags;

The last semicolon is the key here.  When Vim tries to locate the 'tags' file, it first looks at the current directory, and then looks at the parent directory, then the parent of the parent...

This setting works nicely together with 'set autochdir'.  You need +path-extra feature for this tip.  Also see *file-searching* .







VimTip	{{{1 805: Windows: gvim as an external editor


This tip provides a (Windows only) means of using gvim as an external
editor for almost any other program. This script has been tested with
Lotus Notes and Internet Explorer on Windows NT. 

This tip was written using gvim from internet explorer.


Step 1.
=======
Download a copy of clipbrd.vim (vimscript#1014) and put it in your
plugin directory. Modify clipbrd.vim by adding a line as shown below to
the autocommand block in clipbrd.vim:

  aug ClipBrd
    au!
    exec 'au BufWriteCmd ' . auTitle .' :call <SID>UpdateRegister(0, 1)'
    exec 'au BufReadCmd ' . auTitle .' :call <SID>ViewRegister()'

    exec 'au VimLeave ' .auTitle .' :norm gg"*yG'        " <-- this line

  aug END


Step 2.
=======
The vbscript below should be saved as something like runvim.vbs and put
it in your c:\vim\vim6x\ directory. Create a shortcut to runvim.vbs on
your desktop. Right-click on the shortcut, select "Properties" from
the context menu, click the "Shorcut" tab and add a "Shortcut Key" --
something like: "Ctrl-Alt-V".

-----8<-----
set oShell = CreateObject("WScript.Shell")
oShell.SendKeys"^a"
oShell.SendKeys"^c"
oShell.SendKeys"^{Home}"
ReturnCode = oShell.run ("c:\\vim\\vim63\\gvim.exe +ClipBrd +only",0,True)
oShell.SendKeys"^a"
oShell.SendKeys"^v"
oShell.SendKeys"^{Home}"
-----8<-----


Usage:
======
Now when you want to use vim to edit some text in your employers' crappy
email client or web browser just move your cursor to the text area and
hit Ctrl-Alt-V. The current text will be copied into gvim where it can
be edited. Once you are finished editing, quit without saving (:q!). Your
edited text should now appear in the text area.








VimTip	{{{1 806: Always keep quickfix window at specified height


When I use Vim I have multiple windows open which are all maximized after becoming active, see for example vimtip #173

This makes debugging code in combination with the quickfix window a little difficult. After switching from the quickfix window to the code, the quickfix window is minimized and the error message is out of sight. Put the following in your .gvimrc to keep the quickfix window at a user specified height:


" Maximize the window after entering it, be sure to keep the quickfix window
" at the specified height.
au WinEnter * call MaximizeAndResizeQuickfix(8)

" Maximize current window and set the quickfix window to the specified height.
function MaximizeAndResizeQuickfix(quickfixHeight)
	" Redraw after executing the function.
	set lazyredraw

	" Ignore WinEnter events for now.
	set ei=WinEnter

	" Maximize current window.
	wincmd _

	" If the current window is the quickfix window
	if (getbufvar(winbufnr(winnr()), "&buftype") == "quickfix")
		" Maximize previous window, and resize the quickfix window to the
		" specified height.
		wincmd p
		resize
		wincmd p
		exe "resize " . a:quickfixHeight
	else
		" Current window isn't the quickfix window, loop over all windows to
		" find it (if it exists...)
		let i = 1
		let currBufNr = winbufnr(i)
		while (currBufNr != -1)
			" If the buffer in window i is the quickfix buffer.
			if (getbufvar(currBufNr, "&buftype") == "quickfix")
				" Go to the quickfix window, set height to quickfixHeight, and jump to the previous
				" window.
				exe i . "wincmd w"
				exe "resize " . a:quickfixHeight
				wincmd p
				break
			endif
			let i = i + 1
			let currBufNr = winbufnr(i)
		endwhile
	endif
	set ei-=WinEnter
	set nolazyredraw
endfunction


As an added bonus; map ,m to the make command and let the quickfix window pop up if there were any errors:


" Remap ,m to make and open error window if there are any errors. If there
" weren't any errors, the current window is maximized.
map <silent> ,m :mak<CR><CR>:cw<CR>:call MaximizeIfNotQuickfix()<CR>

" Maximizes the current window if it is not the quickfix window.
function MaximizeIfNotQuickfix()
	if (getbufvar(winbufnr(winnr()), "&buftype") != "quickfix")
		wincmd _
	endif
endfunction






VimTip	{{{1 807: Backing up and commenting .vimrc


Hi,
1) BACKING UP .VIMRC :You can always easily reinstall VIM however the loss of your .vimrc could be a catastrophe!

So remember to variously back it up. One good place is to store it as, say vimrc.txt, on your free webspace then you can recover it from anywhere.

2) COMMENTING .VIMRC : My .vimrc now has 348 lines, but about 50% is deadwood because it's no longer clear to me what it's supposed to do, wish I'd thought of this tip years ago!. In .vimrc you use the double quote as a comment

e.g.
" open search result in a new window (the comment)
map zm :let @/=expand("<cword>") <BAR> split <BAR> execute 'normal n'<CR>








VimTip	{{{1 808: how to overwrite a visual-block of text with another such block


One may overwrite a visual-block of text with another visual-block of text by:

   1.  Pick the first block: ctrl-v move "ay
   2.  Pick the second block: ctrl-v move c ctrl-o "aP <esc>









VimTip	{{{1 809: GNU\Linux - gvim as an external editor


The script, external-edit, provides the windows only functionality of vimtip#805 to GNU/Linux (or any *nix) systems with X Windows.

This script does not rely on clipbrd.vim script -- it uses a temporary file to pass the clipboard to gvim. This tip is actually not gvim specific but can be configured to use any external editor.

This script is still under development. New versions will be available from http://bur.st/~benc/external-edit.html.

----------external-edit----------
#!/bin/sh
##################################################
#
# external-edit: launches an external editor from within an X11 Application.
#
# Author: Ben Collerson { benc [at] bur [dot] st }
# Copyright: 2004 Ben Collerson
# Lastchange: 2004 Oct 24
# License: GPL version 2.0 or later (http://www.gnu.org/copyleft/gpl.html)
#
# Install:
# =======
# NOTE: These installation instructions are targeted towards a Debian
# system. To install on a non-Debian system you will need to reinterpret
# these instructions.
#
# First you will need to install the required packages some of which
# are part of Debian so become root and do the following:
# 
#   apt-get install xbase-clients xautomation 
#
# You will also need to install wmctrl. This is not currently a Debian 
# Package. The source is available from http://sweb.cz/tripie/utils/wmctrl/
#
# Wmctrl is a \"command line tool to interact with an EWMH/NetWM 
# compatible X Window Manager\". This means that this tip will not work
# if you are using a particularly old window manager, however most modern 
# WMs should be okay -- including the default Gnome and KDE Window Managers.
#
# More info is available at the wmctrl link provided above.
#
# Once you have the source tarball for wmctrl extract it and do a 
#
#   ./configure && make && su -c make install
#
# Once wmctrl is installed your system put this script somewhere handy
# such as ~/bin/external-edit and chmod +x ~/bin/external-edit
#
# Usage:
# =====
# using your favourite keygrabber/window manager bind a key combination 
# (eg: Ctrl-Alt-V) to a command like the following:
#
#   external-edit /usr/bin/gvim -f
#
# For my fluxbox/bbkeys configuration I have the following in my .bbkeysrc:
#
#   KeyToGrab(V), WithModifier(Mod1+Control), WithAction(ExecCommand), 
#                 DoThis(/home/ben/bin/external-edit gvim -f)
#
# Note: the editor you specify must be executed so it does not fork 
# (ie. gvim -f). When executed the editor must allow the script to wait
# until the editor has finished executing.
#
###############################################################3


# editor plus arguments (except filename) passed on command line
editor=$*

# this gets the window id of the window with focus
winid=`xdpyinfo | sed -ne \'s/^focus:.*\\(0x[^,]\\+\\).*/\\1/p\'`
# and this gets window title
wintitle=`xwininfo -id $winid | sed -ne \'s/xwininfo: .*\"\\([^\"]\\+\\)\"/\\1/p\'`

mytemp=`mktemp`

# copy text using application keyboard short-cuts
case $wintitle in
  *Mozilla*)
  xte << EOM 
sleep 1
keydown Alt_L
key a
keyup Alt_L
keydown Control_L
key c
sleep 1
key Home
keyup Control_L
EOM
  ;;
  *)
  xte << EOM 
sleep 1
keydown Control_L
key a
key c
sleep 1
key Home
keyup Control_L
EOM
esac

xsel -b -o > $mytemp
# xclip could also be used eg:
# xclip -selection clipboard -o > $mytemp

# invoke the editor, wait for it to finish
#/usr/bin/gvim -f $mytemp 
$editor $mytemp 

# applications should be using the clipboard to paste!
xsel -b -i < $mytemp

# some applications have incorrect behaviour and use the primary
# selection to paste
xsel -p -i < $mytemp

# activates the original window
wmctrl -ia $winid

# paste text using standard keyboard short-cuts
case $wintitle in
  *Mozilla*)
  xte << EOM 
keydown Alt_L
key a
keyup Alt_L
keydown Control_L
key v
sleep 1
key Home
keyup Control_L
EOM
  ;;
  *)
  xte << EOM 
keydown Control_L
key a
key v
sleep 1
key Home
keyup Control_L
EOM
esac

# cleanup temporary file
rm $mytemp

# vim:ft=sh:sw=2
----------external-edit----------







VimTip	{{{1 810: Highlighting Text Beyond 80 Columns



Due to oversightedness we are often left with lines of text longer than 80 columns or the set textwidth. One way to spot such lines is to highlight the text  beyond textwidth.

I found that lines beyong textwidth in .c and .h files can be highlighted using the below line in .vimrc.

au BufNewFile,BufRead *.c,*.h exec 'match Todo /\%>' .  &textwidth . 'v.\+/' 

you may add different file extensions for which you may wish to highlight text after textwidth.

Regards,
Nitin Raut






VimTip	{{{1 811: Highlight whitespace errors in files


Being somewhat of a neat-freak, I dislike redundant trailing spaces,
and redundant space chars embedded inside of leading spaces.

This auto-command will highlight both of these when added to your vimrc.

    au Syntax *    syn match Error /\s\+$/ | syn match Error /^\s* \t\s*/

You'll be surprised how much whitespace crud there is in source files everywhere.

-Frank.






VimTip	{{{1 812: Keep modified [+] flag after writing to a file


I have seen this being asked in vim mailing list several times, including the recent one which suggested that it should work this way when 'cp' is reset. Basically what happens is that when you modify a file and write contents to a different file, Vim resets the 'modified' flag, which is a Vi compatible behavior. For those who don't want the 'modified' flag reset, the suggested alternative is to use :saveas command instead of :write command, but this changes the name of the current buffer rather than what is wanted. So I have cooked up the following solution which seems to work for regular files, but it is not a fool proof mechanism. The problem is plugins like netrw that catch the event that is triggered when you try to write contents to a different file, and the below solution also uses the same mechanism, so it would end up getting triggered unexpectedly (actually, netrw might work just fine, but you would get ugly error messages in addition).

I have provided a simple workaround for taking care of at least netrw. Basically, it checks if netrw would react to the event and if so skip itself. A more sophisticated solution would actually parse the output of ":au BufWriteCmd" and automatically check if there are other event handlers for this file, but there are not all that many plugins that take advantage of this event (actually I am aware of only netrw), so the workaround should be sufficient (actually, I haven't tested the netrw filenames, so I am not sure it would work). What you should do is to run the ":au BufWriteCmd" before installing this solution and see what other autocommands exist, other than those that are for netrw. You will have to then tweek the code that returns early from the BufWrite() function.

OK, enough said, the solution follows. You basically put the below code in your vimrc and your :write's will work as expected (ie., as described at the start). 

----------cut here-----------
function! SetBufWriteAuEnabled(enabled)
  aug BufWrite
  au!
  if a:enabled
    au BufWriteCmd * :call BufWrite()
  endif
  aug END
endfunction
call SetBufWriteAuEnabled(1)

function! BufWrite()
  let fileName = expand('<afile>')
  " If the filename already matches netrw's criteria, then don't do anything.
  if fileName =~ 'ftp://\|rcp://\|scp://\|dav://\|rync://\|sftp://'
    return
  endif
  let _modifiable = &modified
  exec 'w'.(v:cmdbang?'!':'') v:cmdarg fileName
  let &modified = _modifiable
endfunction
----------cut here-----------

Enjoy,
Hari






VimTip	{{{1 813: Reverse all the lines in a file


This simple command 

   :g/^/m0

will reverse all the lines in a file. Useful for certain files like logs.






VimTip	{{{1 814: Use cygwin shell


By default, Vim on Windows uses the "Command Prompt" as its shell. If you have Cygwin installed (http://www.cygwin.com) you may want to use one of its shells instead, such as bash. This also makes all of the programs installed under Cygwin available for text processing.

The following settings may be included in a startup script to use bash as your shell. I have these commands in my _gvimrc file in the installation directory.

set shell=C:/cygwin/bin/bash
set shellcmdflag=--login\ -c
set shellxquote=\"

I had problems with parts of the /etc/profile not being executed, but I didn't want to add -i (interactive) to the shellcmdflag because this caused the shell to always open in my home directory. I prefer that it opens in the directory containing the file being edited. However, without that part of /etc/profile running, the path wasn't set up properly. To get around this, I added the following line to /etc/profile:

RANPROFILE="TRUE"

I added this to my .bashrc:

if [ -z "$RANPROFILE" ]; then
    PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
fi

Newer versions of the /etc/profile installed with Cygwin may behave differently.






VimTip	{{{1 815: Getting vim to work with cvs commit


One thing which I find annoying about CVS is doing a commit. You end up with a screen with a bunch of lines starting with "CVS: ", and you need to strip these strings out if you want to finish doing the `cvs commit`.

Here's some sample output from a `cvs commit`:

CVS: ----------------------------------------------------------------------
CVS: Enter Log.  Lines beginning with `CVS:' are removed automatically
CVS: 
CVS: Committing in .
CVS: 
CVS: Modified Files:
CVS:    foo.c
CVS: Added Files:
CVS:    bar.c
CVS: ----------------------------------------------------------------------

Normally, you can just type the following:
        :1,$s/^CVS: //

However, even this is too annoying. I'd rather have a single button which did this.

Putting the following in your ~.vimrc file acomplishes this task:

:map <F1> :1,$s/^CVS: //p<CR><CR>

This maps the F1 key to doing the desired action. So now all you have to do is a `cvs commit`, hit <F1> and viola! You can now just start typing in what you changed for the log.

This is certainly a simple, stupid map trick. But it is a superb example IMHO of applying the map command in an everyday, useful fashion. And this trick can be applied to other Source Code Control mechanisms as well.

        -dwight-

        dwight@supercomputer.org










VimTip	{{{1 816: JAVH: Just another VIM Hacker


Perl has it's JAPH Just Another Perl Hacker (a short script that produces the output 'Just another Perl hacker' (Just Google for it)) I thought one day I'd try to something similar with VIM , the trick being to make it as obscure as possible:-

vim -c ":%s%s*%Cyrnfr)fcbafbe[Oenz(Zbbyranne%|:%s)[[()])-)Ig|norm Vg?"

Somebody (sorry I forget who, possibly Peppe) did this one

:s(.*(rekcaH iV rehtonA tsuJ(|t.|s).$)&&)|-s'.'s,\\(.\\)\\(.\\)\\(\\2.*\\),\\2\\3\\1,|'g|s=[^|]*|$=s,.,,=|d a|@a

Another voyager in cyberspace created the following

gvim -c "exec \"normal itYNQ#v'Z#ABG#GUR#BAYL#BAR\"|%s/#/ /g|normal ggVGg?ggVG~"

So what's the point:-
1) Well it attracts a few more people to VIM (I use it as a signature)
2) It sharpens your Vim skills,(they can never be sharp enough)
3) It's fun

So over to you! can you do any better!






VimTip	{{{1 817: Non-blinking block cursor in the linux console


If you are a Linux user editing with Vim in the console, you can put the following in your .vimrc to have a nice non-blinking block cursor like in a xterm:

if &term == "linux"
        set t_ve+=^[[?81;0;112c
endif

Note that the ^[ above needs to be typed like this: <CTRL-V> <ESC>.

See Documentation/VGA-softcursor.txt in the kernel sources for details about this escape sequence.






VimTip	{{{1 818: Vim/GVim as Diff tool for TortoiseCVS


Under Win you can use TortoiseCVS along w/ Vim/GVim as the diff tool of choice:

1. Create a .bat file containing the following and put it in your path:

@echo off
"C:\Program Files\Vim\vim63\GVim.exe" -d %1 %2

2. Add this .bat file as the diff utility under TortoiseCVS->Preferences->Tools->External Diff Application.

Alejandro






VimTip	{{{1 819: Quick (Re-)starting and Iconizing gvim with keystrokes for Windows


gvim is iconized (resp. send to the background) with
     CTRL-Z
so for me it is useful to start it with
     CTRL-ALT-Z
which is easily configured from the properties menu of a windows shortcut  pointing to gvim.exe using the right mouse button.
Since  the last command brings gvim into the foreground if it has already been started, the above  2 control-commands toggle between another application and gvim very fast.







VimTip	{{{1 820: VimTip is a one-stop resource to vim. Keep it in your $VIM directory


The VimTip textfile and database has become one of my favorite ways to learn
new tricks in vim. So I keep it easy available at all times and have applied
some of the nice tricks I have learned to the file to make it easier to read.

1: Get the text file (wget is a external tool, you can get a windows version)
    Download the text version with a browser or use wget like this.
    On the vim commandline: (It's all on one line)
	:!wget http://www.vim.org/tips/tip_download.php?download=download -O
	~/.vim/vimtips.txt

2: Open it and apply foldmarks. 
	:e ~/.vim/vimtips.txt
	:%s/\(^VimTip\)/\1\t{{{1/g
	:set foldmethod=marker
	
3:	Now you should have a nice index of all the vimtip's provided. Open a fold
by placing the cursor on a line and hit za. Open all folds with zR. Close them
again with zM

4: After some vimtip's reading you shoul be able to make a automatic process of it to update your vimtips.txt file regularly.

Happy vim'ing
Best Regards
Staale Flock






VimTip	{{{1 821: Simplest buffer explorer ever


In the footsteps of vimscript #42 and vimscript #159, here's perhaps the simplest way to select a buffer from the list of all buffers:
    nnoremap :e :ls<CR>:e<Space>

Just type ':e' and continue typing '#' and the number of a filename from the list (or a new filename).

A minor drawback is that ':' now doesn't show up immediately (vim waits some time to see if you'll complete the mapping), but I got used to this with no trouble at all.  I imagine it'll be the same for most people who type fast - you won't notice that ':' and the next character you type show up together rather than in sequence.

I always get nervous with mappings involving ':' or '/' but this one's created no problems in a couple of months.






VimTip	{{{1 822: add java import statements easily (assume using ctags)



I like the build (make) process to be fast... Eclipse/Netbeans users are excited about "auto-import" features...
Vim can do it just fine....  Well, I just got this working today....and it may need some tweaking.
If It doesn't work for you.... take some java.... that compiles... break one of the imports (assume you don't using foo.*; syntax much).
Then comment lines below starting from bottom up....  watch editing happen.... try to do edits slow to reproduce whats here.
I generally hit F1 key to build with (jikes) (tip # 3).... 90% of build failures are missing import statements....
If you already have a ctags system (tip #804, 94, etc)... the information can be found!
I hit F1 (:make), then hit F9 (add import for keword found under cursor)...then F1 (make/build)....and so on.  (FAST)

(Add Import)   
:noremap <F9> <esc>
                  \<C-W>}o//TEMP MARKER<esc>
                  \<C-W>P1G/public class<cr><esc>yy<C-W>pG?import<cr><esc>p<esc>
	          \<C-W>P1G/package<cr><esc>yy<C-W>pG?import<cr><esc>p<esc>
	          \$xa.<esc>0jwwi<cr><esc>kdd<esc>
                  \wDx<esc>kJxx<esc>$a;<esc>
	          \0cwimport<esc>
	          \:update<cr><esc>
                  \/TEMP MARKER<cr>dd<esc>
(Make)    
 :noremap <F1> :update<cr>:make<cr><C-W>j<esc>:cw 3<cr><C-W>p  









VimTip	{{{1 823: Add your note files to vim's help system.


I guess you have one or more files containing short notes regarding your computer, stuff you study and suche. If you have several years of notes laying around, and are like me..:o), You tend to forget what's in your notes and you start grepping through your files ore start over again to figure stuff out. 

One of my solution has been to vim-helpify my note files and add a link to them from my ~/.vim/doc/ folder. 

This is the process:
Make a few changes to your note file.

---- sample notes file start -------------------------------
" vim: filetype=help foldmetod=tags foldtags=<<<,>>> modifiable noreadonly
NOTE! You need the noreadonly and modifiable keywords in the vim modeline above. help files are by default regarded as readonly and nomodifiable files by vim.

Notes about sed		*sed* *sfsed*	<<<
swapping word's in stream (I know, you don't need the cat)
	cat Myfile.h|sed 's/foo/fyy/g'


Notes about vim		*vim* *sfvim*	<<<
	Stuff I have learned about vim.
	Create a help link like this |add-local-help|
	Regenerate help tags: |helptags|

	A realy big section closed with a tag <<<
	--- lots of stuf ---
	Closing tag >>>
	

Telephonelist		*sfphone*	<<<
	mom:	555-676767-333
	dad:	555-767676-222
	sis:	555-121212-999

---- sample notes file end ---------------------------------

As you can see from my sample I tend to prepend my keywords with sf so I can get a handy list with <CTRL+d> later.

I have tried to index files placed in an arbitray place. Sadly enough the helptags command does not seem to like this, so my solution has been to make a soft link from the ~/.vim/doc/ folder to my file. You can do this from vim:
	:!ln -s ~/.vim/doc/mynotes.txt ~/Documents/mynotesfile.myext
To have vim create the tags
	:helptags ~/.vim/doc

Viola, now when I need that important phone numer it's only one :h command away
	:h sfp<CTRL-d>
	

You could also create your own helptags function adding tags containing a more specifig file position. A realy simple function would be.

function! AddMyHelpTags()
	exe 'echo -e "sfsed\t ~/Documents/mynotesfile.mytext\t/\*sfsed\*" >> ~/.vim/doc/tags'
	exe 'echo -e "sfphone\t ~/Documents/mynotesfile.mytext\t/\*sfphone\*" >> ~/.vim/doc/tags'
	exe 'sort ~/.vim/doc/tags > /tmp/foo.vim.tags'
	exe 'mv -f /tmp/foo.vim.tags ~/.vim/doc/tags'
endfunction

NOTE! I do not use such a AddMyHelpTags function myself. But I have tested the principle (The sample function it self is not tested, only the commands). This is just a sample to get you going. Remember that you probably would have to run this AddMyHelpTags function each time :helptags has been called, so as-is it is not very convinient..:o(

Happy viming, regards
Staale Flock







VimTip	{{{1 824: Choose smaller font in vimdiff mode.


Recently someone wants me to post the solutions of this.

I just want to change the font when vim is launched in vimdiff mode, since you'll not be able to change the font later while retain the 1:1 split, (in other cases, I can change the font before :diffs)

Just add something like the following in .gvimrc:

Of course, your fonts may vary.


" Font must be set in .gvimrc
let in_diff_mode = 0
windo let in_diff_mode = in_diff_mode + &l:diff
    set guifont=Lucida_Console:h15:cDEFAULT

    " In diff mode
    if in_diff_mode == 1
        set guifont=isi_ansi:h14:cDEFAULT
    endif

unlet in_diff_mode








VimTip	{{{1 825: Expand #* search to grep-find


When #/* will not find a word under-cursor, 
use the macro 'g/' given below, to expand the
same search with gnu-grep to dirs/files.

Search results are shown in a small window (quickfix mode),
use c-n/c-p to move between results.

Uses gnu-grep on PC/Unix to search vim \<regexp\> in files/trees.

Based on 'grep-find' which is a emacs commands.

" Put this in ~/_vimrc and use g/ to repeat current search as a grep-find.
" Usage 
"   /xyz   .. not found in current file, so lets look for it in *.* with 
"   g/     .. search for xyz in *.*, next lets look for it in the whole tree
"   :call Mosh_grep("../..") 
"   :call Mosh_grep("/usr/include","strstr")
" GNU-grep -recursive,nocase,linenum,noerror,VimRegexp (in that order).
:set  grepprg=grep\ -rinsE

:map g/  :call Mosh_grep()<CR>

function! Mosh_grep(...)
    if a:0 == 0 
        :exec "grep '".@/."' *.*"
    elseif a:0 == 1
        :exec "grep '".@/."' " a:1
    elseif a:0 == 2
        :exec "grep" a:2 " " a:1
    endif
    " Optional mappings for easy navigation of results
    :map <c-n>  :cnext<CR>
    :map <c-p>  :cprev<CR>
    :copen 
endfunction

- Mohsin   
http://www.cs.albany.edu/~mosh
 






VimTip	{{{1 826: PHP manual in VIM help format


Download http://planetxml.de/php_manual.txt and put it into your vim/doc folder, then run :helptags [path to vim/doc]. Documentation for PHP functions can be shown by pressing K while the cursor is on a function name.

The manual was created using a modified version of script found at http://www.phpvolcano.com/articles/manual/index.php.






VimTip	{{{1 827: XTerm and 256 Colors


XTerm supports 256 colors when compiled with the --enable-256-color configure option.  To actually enable the colors set the TERM enviroment variable to TERM=xterm-256color

Some of the colorschemes support the 256 color format.






VimTip	{{{1 828: pad trailing blanks onto end of lines to ease visual blocks


I love using the visual block feature to move columns around (<ctrl-v>, blockwise-visual).
However, this does not work conveniently on the last column 
when  lines are not of equal length. <ctrl-v> marks then a block which
is equal in width to the shortest line.

In order to pad all lines to a given width with trailing blanks 
you can use the following functions:

" truncate line 'line' to no more than 'limit' width
function! Truncate( line, limit )
    call cursor(a:line,a:limit)
    norm d$
endfunc

" Pad all lines with trailing blanks to 'limit' length.
function! AtOnce( limit )
    norm mm
    g/^/norm 100A 
    g/^/call Truncate( getline('.'), a:limit )
    let @/=""
    norm 'm
endfunc


You may alternatively use the oneliner:
:g/^/exe "norm! 100A" | call cursor(getline('.'), 79) | norm d$


I even saw someone use a standard vi (non vim) oneliner to achieve the
same, but I forgot how. Any ideas?







VimTip	{{{1 829: copy & paste between vim session


I use putty + vim + screen on web application developing.
because, daily working directory is more than 10. I couldn't find easy way
to develop in only one vim session.

so, copy & paste between session, usally used window's clipboard. but, to copy longer
than one screen, It's really hard. yes, there are auto-indenting problem too.

and sometimes, I just want copy function definition or long variable names. between vim
buffers I simply use visual selection. or cw/ciw. in this case, yanking by line is worse than
clipboard.

last night I made this script saving current register to file supporting visual selection too.

,y saves current unnamed buffer to ~/reg.txt file.
,p / ,P read from ~/reg.txt and paste using p/P.
in visual mode,  ,y  is yank and save.

vmap <silent> ,y y:new<cr>:call setline(1,getregtype())<cr>o<esc>P:wq! ~/reg.txt<cr>
nmap <silent> ,y :new<cr>:call setline(1,getregtype())<cr>o<esc>P:wq! ~/reg.txt<cr>
map  <silent> ,p :sview ~/reg.txt<cr>"zdddG:q!<cr>:call setreg('"', @", @z)<cr>p
map  <silent> ,P :sview ~/reg.txt<cr>"zdddG:q!<cr>:call setreg('"', @", @z)<cr>P

but, I think there are more simple way to this in our vim world. always there were.

what's the best way to copy & paste between vim sessons?







VimTip	{{{1 830: Using netbeans 4 and vim for java


This tip explains how to configure Vim to build Java sources and to execute classes without having to start Netbeans, but everything done in the same way Netbeans would do it. Netbeans can then be started any time to do things that Vim cannot, like debugging in a GUI or refactoring.

This has been tested in Linux.

It is assumed that your Java source code is in the directory "~/data/java/src" and that your classes are in different packages below this directory. For example the package com.your_domain.util is in the directory "~/data/java/src/com/your_domain/util"

Step 1: Install Ant

Step 2: Install Netbeans and create a new project with existing sources. At this point you can choose within Netbeans where all project files will be saved. Let say "~/data/java/netbeans" and the project name is "my_domain". The source code directory should be the top directory, here: "~/data/java/src". Netbeans will add packages in the project for all subdirectories, which allows to move classes between packages with the mouse, and Netbeans will refactor your whole source files for you.

Step 3: Compile your project with Netbeans. After that you can close Netbeans.

Step 4: Add the following two lines in .vimrc or in ~/.vim/ftplugin/java_netbeans.vim or ...

             nmap <F6> :! ant -buildfile ~/data/java/netbeans/my_domain/build.xml compile<CR>

             nmap <F7> :cd ~/data/java/src<CR>:! ant -buildfile ~/data/java/netbeans/my_domain/build.xml -Drun.class=%:.:r -Djavac.includes=~/data/java/netbeans/my_domain/build/classes/ run-single<CR>:cd %:p:h<CR>

That's it ! Now you can compile changed files pressing <F6> or execute the class you are editing with <F7> in Vim. And you can start anytime Netbeans for debugging, refactoring, etc.






VimTip	{{{1 831: regexp to strip redundant zeroes in decimal fractions


Vim command
%s/\(\.\d\+\)\@<=0\+\>//g 
will strip all trailing (meaningless) zeroes in decimal fractions. Some of my data files lost 50% fat after this procedure and also became much more human readable.

I guess "correct"regular expression should be
\(\.\d\{-1,}}\)\@<=0\+\>
(since the intention is to preserve just one zero that comes right after decimal point), but for some reason original expression works as well.

I guess this serves as another example of how \@<= regexp token makes things so much easier.







VimTip	{{{1 832: Remembering previous deletes/yanks


The following was posted on the Irish Linux User Group mailing list:

&lt;quote&gt;
ok, let's say your cursor is on ok, and you delete this paragraph with
the command [d}] (just the d} part, for this mail i'm wrapping
keystrokes in []'s).  the reason you deleted it is because you want to
move it to another file.

so now you open the other file with [:e other.file.txt<return>].  as
you're scrolling down to where you want to put it, you accidentally
delete/yank some text.

you've saved the last file and now doing [p] just inserts the text you
just deleted/yanked.  how can you get back what you deleted?  vim
extends vi's numbered delete buffers so that they work from one file to
the next - switching files doesn't delete the numbered delete buffers.

the numbered buffers are numbered from 0 to 9.  ["0p] is the same as
plain old [p].  ["1p] is the buffer from the previous delete, ["2p] is
from the delete before that, etc.  note that while ["0p] has the last
delete or yank, the other numbered buffers only contain previous
deletes.

it's handy, and thanks to donncha for looking it up the other day while
i was on the train.

&lt;/quote&gt;
Credit where credit due, it was Kevin Lyda who posted this.






VimTip	{{{1 833: Google lookup as a contextual spell check and phrase verifier.


I started hacking vim + google apis yesterday to do phrase lookups 
on google. Google is much better (but
slower than a dictionary) as a contextual speller/data verifier.

However here is something readymade by Danny O'Brien, from
http://www.oblomovka.com/entries/2003/04/16#1050554820

In your .vimrc, add these lines:

" ,g  - create google a href for word under cursor
map ,g <Esc>Bm`:r!ghref <cword><CR>"gdd``i<C-R><C-R>g<esc>dw
vmap ,g yvgvdm`:r!ghref '<C-R>=substitute(@0, "['\n]", " ", "g")<cr>'<cr>"gdd``i<C-R><C-R>g<Esc>

Now put this program somewhere in your PATH, saved as "ghref"

#!/usr/bin/python
##
# ghref - takes a string on command line, looks it up in google, outputs
#         the HTML for a hyperlink to the "I'm feeling lucky" URL
##
import google
import sys
import re
def main(argv):
    search=argv[0]
    data = google.doGoogleSearch(search)
    if (data.results[0].summary):
        title = data.results[0].summary
    else:
        title = data.results[0].title
        title = re.sub('</*b>','',title)
    print '<a href="%s" title="%s">%s</a>' % (data.results[0].URL, title, argv[0])

if __name__ == '__main__':
    main(sys.argv[1:])

 






VimTip	{{{1 834: Word-wise cut, copy & paste


Word-wise cut, copy & paste over the current word. There's nothing special or magical about these bindings, just that I find them really useful for coding, and I thought I'd share.

Add the following lines to _vimrc:

map <A-v> viw"+gPb
map <A-c> viw"+y
map <A-x> viw"+x

These bindings follow the Windows-style keys of control-V, control-C, and control-X; except using alt instead of control. Adjust to your preference.






VimTip	{{{1 835: Get Intellisense for C++ to search CWD/PWD


I searched the tips database and didn't find this.  Do not know the best place for this tip.

This tip is relevant to those who use the "Intellisense" functionality for vim (insenvim.sourceforge.net) for C++.  This requires, as a part of its setup, that the paths for the all the included header files in a C++ file be present in the $INCLUDE variable.  This is fine so long as all your header files are in one (invariant) location (say the MSVC's include directory).  However, if your C++ file includes header files in locations relative to the current file, updating the INCLUDE environment variable is not an option.

E.g., if your header files are in the same directory as your source file, simply add the following line to the cpp_vis.vim file that is delivered to the vimfiles\ftplugin location:

let $INCLUDE = expand("%:p:h") . ";" . $INCLUDE

To include other relative paths, simply tweak the argument to expand().  For more info, see

:help filename-modifiers

Happy vimming! :)






VimTip	{{{1 837: Load file from list of filenames in textfile


Following is a BIG timesaver if you need to open lots of files.

Assume you have a text file containing filenames with or without paths (created by for instance 'grep -Erl "^" * > files.txt'). Following opens all these files in the same vim.

Asumming that only this text file is opened:

- Set the cursor on the first line
- in command mode, type: q0gf:rew<CR><DOWN-ARROW>q
     - This loads the file on the first line and create a macro '0'
- Check the number of lines with <CTRL-g> and substract one for the first line
- Type this value, then: @0
    - This loads the remaining files











VimTip	{{{1 838: How to make arrow keys in Vim behave like they do in Vi


It seems quite different of four arrow keys between Vim and Vi.

For an example, in Vi:
At normal mode, if type 'd + Down arrow', Vi get back to normal mode and nothing else happens.
But in Vim:
At normal mode, if type 'd + Down arrow', the current line where the cursor is and the next line will be deleted.

I browsed vi_diff.txt and found one sentence:
"The arrow keys can be used in insert mode to move around in the file"
I do not want such function. I prefer arrow keys bring Vim to normal mode firstly.

I've got used to Vi and I use Vim only for syntax highlighting .
How could I make those arrow keys acts as they do in Vi.

BTW, I launch Vim in Vi compatible mode.






VimTip	{{{1 839: switch editing: .c* to .h*


This command allows you to
quickly switch editing between .c* and .h* files.

It is especially useful when the header file is 
in different direcotry and filenames are long.
Example: press 'zh' when editing fxx1234.cxx to open fxx1234.hxx

:map zh :call Mosh_Flip_Ext()

" Since .h file can be in a different dir, call :find instead of :e
" :find file will be searched in this path
set  path=.,,..,../..,./*,./*/*,../*,~/,~/**,

" note there are double backslashes below, http post might mangle them.

function! Mosh_Flip_Ext()
    :if match(expand("%"),"\\.c") > 0 
        let s:flipname = glob(expand("%:r").".h*")
        :exe ":find " s:flipname
    :elseif match(expand("%"),"\\.h") > 0 
        let s:flipname = glob(expand("%:r").".c*")
        :exe ":find " s:flipname
    :endif
endfun     








VimTip	{{{1 840: Show tags in a separate preview window


I love using exuberant ctags (especially ctags -R).  But I dislike how the show-tag-under-cursor command (Control-]) replaces the current buffer and loses my cursor position.  Instead I want to view the tag definition in a separate 'preview' window so I can, for example, view a C/C++ type declaration while coding a call.

Add the following to your _vimrc/.vimrc file:

nnoremap <C-]> <Esc>:exe "ptjump " . expand("<cword>")<Esc>

This will make Control-] pop open a window and show the tag there.  The :ptjump command shows the tag in a preview window without changing the current buffer or your cursor position.

This is especially handy for referencing C/C++ function declarations while entering code.






VimTip	{{{1 841: Vim reference card of common commands


Charles E. Campbell wrote an excellent Vim reference card in 1999 for Vim 5.7.  I revised it for Vim 6.3.

http://utools.com/vimrefcard.pdf






VimTip	{{{1 842: c/c++ function abbreviations


I have been seeking for some 'perfect' abbrevs for long time. They have to work in c code, but not in string or comment. They have to place cursor inside the function and leave vim in insert mode, so that I can just continue typing. They have to respect my indenting, and they have to produce exactly the same results when I start the abbreviation by <C-]> or just by <Space> (no bothersome space should appear). And they should be easy to maintain. I thought that this is not possible, but after seeing Luc Hermitte's lh-cpp-ftplugins, I found my way through. Here is what I got:

" Help delete character if it is 'empty space'
"  stolen from vim manual
function! Eatchar()
  let c = nr2char(getchar())
  return (c =~ '\s') ? '' : c
endfunction

" Replace abbreviation if we're not in comment or other unwanted places
"  stolen from Luc Hermitte's excellent http://hermitte.free.fr/vim/
function! MapNoContext(key, seq)
  let syn = synIDattr(synID(line('.'),col('.')-1,1),'name')
  if syn =~? 'comment\|string\|character\|doxygen'
    return a:key
  else
    exe 'return "' .
      \   substitute( a:seq, '\\<\(.\{-}\)\\>', '"."\\<\1>"."', 'g' ) .  '"'
  endif
endfunction

" Create abbreviation suitable for MapNoContext
function! Iab (ab, full)
  exe "iab <silent> <buffer> ".a:ab." <C-R>=MapNoContext('".
    \  a:ab."', '".escape (a:full.'<C-R>=Eatchar()<CR>', '<>\"').
    \"')<CR>"
endfunction

call Iab('#d', '#define ')
call Iab('#i', '#include <><Left>')
call Iab('#I', '#include ""<Left>')
call Iab('printf', 'printf ("\n");<C-O>?\<CR>')
call Iab('if', 'if ()<CR>{<CR>}<Left><C-O>?)<CR>')
call Iab('for', 'for (;;)<CR>{<CR>}<C-O>?;;<CR>')
call Iab('while', 'while ()<CR>{<CR>}<C-O>?)<CR>')
call Iab('else', 'else<CR>{<CR>x;<CR>}<C-O>?x;<CR><Del><Del>')
call Iab('ifelse', 'if ()<CR>{<CR>}<CR>else<CR>{<CR>}<C-O>?)<CR>')
call Iab('intmain', 'int<CR>main (int argc, char **argv)<CR>'.
       \'{<CR>x;<CR>return 0;<CR>}<CR><C-O>?x;<CR><Del><Del>')

For me it's working, I also tried it with plain vim (without .vimrc), but it may depend on some settings. Hope it helps.

Happy vimming
--
  Neuron






VimTip	{{{1 843: Moving between buffers using mouse and minibufexpl.


After some time using mini buffer explorer (http://www.vim.org/scripts/script.php?script_id=159), here is the way for moving between buffers using mouse (thus GVim only) and minibufexpl I feel comfortable with (Who knows you might feel the same :)

1. download the minibufexpl script and put it in the plugin directory (~/.vim/plugin or %HOME%\vimfiles\plugin in windows). Thus we have a pseudo tabbar in GVim window.
2. map the right click to <Esc> by adding this line to vimrc
imap <RightMouse> <Esc>
nmap <RightMouse> <Esc>
3. Then when we want to switch buffer in insert mode (or normal mode), instead having to press the <Esc> key, then move the mouse and click the buffer name, we instead just need to right click and click the buffer name using the mouse. Quite easier I think.

Drawback, you lose your right click menu, but do you use it anyway ?






VimTip	{{{1 844: Simple Macros to quote and unquote a word



Here are some simple mappings that can be used to quote and unquote a word. Place the cursor over a word and
press qw to place single quotes, or qd to place double quotes around the word. To remove quotes press wq.

The mnemonic used is perls qw() operator.

  " 'quote' a word
  nnoremap qw :silent! normal mpea'<esc>bi'<esc>`pl
  " double "quote" a word
  nnoremap qd :silent! normal mpea"<esc>bi"<esc>`pl
  " remove quotes from a word
  nnoremap wq :silent! normal mpeld bhd `ph^M







VimTip	{{{1 845: Getting color to work in SecureCRT


I was puzzled I couldn't get colors despite setting SecureCRT emulation settings to ANSI Color

Adding this to .cshrc fixed it:
setenv TERM xterm-color






VimTip	{{{1 846: gvim ampersand in freebsd shell commands (viewing with vim-latex)



could not execute shell commands ending with ampersand (&) in gvim running under Freebds. Commands like:

:!xdvi &
:!xterm &

did not work. This meant that I couldn't use vim-latex to view documents dvi since by default vim-latex sends a command ending with &.  The problem does not occure in vim.

The fix. The problem is solved if the shell is changed to ksh from the default sh or bash.

1) install pdksh

     $ su                (su to root)
     # cd /usr/ports/shells/pdksh/
     #make install cleanset 

2)  Change the shell to ksh in .vimrc. Add 

    set sh=ksh
  
(see help sh)

Happy  ampersanding in gvim








VimTip	{{{1 847: Avoid irritating "ATTENTION" message and always open it read-only


When you open a file opened in somewhere else,
you would get "E325: ATTENTION" message because a swap file already exists there.
I (almost) always choose the action "[O]pen Read-Only" in this case,
so typing 'O' key is an annoying job for me.
The following in my vimrc reduce my job.

func CheckSwap()
    swapname
    if v:statusmsg =~ '\.sw[^p]$'
	set ro
    endif
endfunc

if &swf
    set shm+=A
    au BufReadPre * call CheckSwap()
endif







VimTip	{{{1 848: Installing several releases in parallel, even with matchit


It is possible to install several different releases of Vim (for instance, Vim 6.3 "stable" and Vim 7.0 "alpha") on a single computer and decide at run-time which one to use. The present tip tells how. However, it does not solve all of the problems; in particular, it tells how to use either one or the other but not both by the same user at the same time. (It is possible to use both at the same time if "users" are different, or if the matchit plugin is not used.)

1. One version should be chosen as "default", normally the stabler one. It will be accessible via the PATH, through one of the following methods:

a) Put the name of its directory in the PATH: for example, on Windows 98, AUTOEXEC.BAT may contain:
...
set VIM=C:\PROGRA~1\vim
...
path %VIM%\vim63;%PATH%

b) Have a soft link to it in a directory in the PATH, for example on Unix you may have a soft link /usr/bin/vim pointing to /usr/share/vim/vim63/vim

To use the non-default version (or, on Windows, the default when you are in the directory of the other one), use a full path: in the case above, you will invoke the default Vim as "vim" and the other one as (for example, on Windows) %VIM%\vim70aa\vim

2. The permanent environment may possibly contain a VIM variable (which may for instance be set to C:\PROGRA~1\vim on Windows or to /usr/share/vim on Unix) but not a VIMRUNTIME variable. Each executable will select a different $VIMRUNTIME according to its version number. If VIM is unset, Vim will normally set it correctly; but even if you use the default it can be useful to set VIM in the permanent environment so that the shell can see it: indeed, it is much easier to type cd $VIM than cd /usr/share/vim; or %VIM%\vim70aa\gvim filename.ext than "C:\Program Files\vim\vim70aa\gvim" filename.ext. For best results on Windows, use "short" directory names in the value of VIM, HOME, etc. (as in the W98 example above).

3. The "system-wide customizations" in $VIM/vimfiles and the "user-specific customizations" in $HOME/.vim or $HOME/vimfiles will be common to the different versions; any differences can be resolved by testing the value of v:version at run-time.

4. Each distribution should have its own distribution tree at the proper place under $VIM, for instance $VIM/vim63 for stable release 6.3 (at any patchlevel) or $VIM/vim70aa for alpha release 7.0aa (at any snapshot date). If you install via a pre-compiled archive or installer, it should select the proper default. If you compile your own, the subdirectory name is the value of the constant VIM_VERSION_NODOT defined in src/version.h

5. Now we come to the ticklish point: the matchit plugin. It comes with each distribution, with its own script and helpfile, but they are deactivated by default and they may vary from version to version. They are however, very useful; but how can we sure of using the right one? Here is how I solve the dilemma: I use a small "system-wide" plugin $VIM/matchit.vim to automatically select the right plugin at run-time (the first line takes care of the plugin itself; the rest is for the help file. This "fancy footwork" is needed to avoid changing the distribution files in or under $VIMRUNTIME.) Note that the following assumes that different users may use both versions at the same time, but that a single user will not. The contents of that scriptlet is shown here between -----start and -----end; it assumes that +eval (expression evaluation) and +windows (the ability to use split windows) have been compiled-in. In other words, the "normal" feature set should be enough. (With only "small" features, we can't use the :if statement and that's a big handicap.) This plugin also assumes that there exists a "doc" subdirectory in ~/vimfiles or ~/.vim for "user help files". You should create that directory if it doesn't yet exist.

$VIM/vimfiles/plugin/matchit.vim:
----- start
	runtime! macros/matchit.vim
	split $VIMRUNTIME/macros/matchit.txt
	if has("unix")
		saveas! ~/.vim/doc/matchit.txt
		helptags ~/.vim/doc
	else
		saveas! ~/vimfiles/doc/matchit.txt
		helptags ~/vimfiles/doc
	endif
	close
----- end

see
	:help $VIM
	:help $VIMRUNTIME
	:help v:version
	:help matchit-install
	:help :helptags






VimTip	{{{1 849: Shortcuts to compile/run default file and alternate file in Java


Coding in Java? Add this to your .vimrc to map F9 to compile, and F10 to run. You can also use F11 and F12 to compile and run the alternate file. I\'ve found this .vimrc very useful where I am working on a Java class in one file, and a driver program to test it in the alternate file. See also: #vimtip 3 and #vimtip 120. Note that ^M and ^[[ below need to be typed as control characters (hit Ctrl+V, Ctrl+M, etc.), and makeprg could easily be modified for those using jikes. Hope someone else finds this useful.

\" F9/F10 compile/run default file
\" F11/F12 compile/run alternate file
map <F9> :set makeprg=javac\\ %^M:make

map <F10> :!echo %\\|awk -F. \'{print $1}\'\\|xargs java^M
map <F11> :set makeprg=javac\\ #^M:make^M
map <F12> :!echo #\\|awk -F. \'{print $1}\'\\|xargs java^M

map! <F9> ^[[:set makeprg=javac\\ %^M:make^M
map! <F10> ^[[:!echo %\\|awk -F. \'{print $1}\'\\|xargs java^M
map! <F11> ^[[set makeprg=javac\\ #^M:make^M
map! <F12> ^[[!echo #\\|awk -F. \'{print $1}\'\\|xargs java^M

\" Tip: load a file into the default buffer, and its driver
\"    into the alternate buffer, then use F9/F12 to build/run. 
\" Note: # (alternate filename) isn\'t set until you :next to it!
\" Tip2: You can make then run without hitting ENTER to continue. F9-F12

\" With these you can cl/cn/cp (quickfix commands) to browse the errors
\" after you compile it with :make
set makeprg=javac\\ %
set errorformat=%A:%f:%l:\\ %m,%-Z%p^,%-C%.%#

\" If two files are loaded, switch to the alternate file, then back.
\" Useful because then # is set!
if argc() == 2
    n
    e #
endif






VimTip	{{{1 850: automatic word wrapping


To automatically wrap word in vim
:set wm=2
which sets a wrap margin of 2 characters at the end of each
line, and does automatic word-wrapping as u type in text.

To set textwidth as of your screen with do
:set textwidth=0 (If u want to set it yourself do :set textwidth=78.)

If you want to apply this to specific areas; bring the cursor at
the beginning of the text u want to format and type gq. Now specify the range,
say $ to format a large line.

For more help
:help wn
:help gq

Hope this helps.
mmj






VimTip	{{{1 851: compose mail in Mozilla Thunderbird using Vim.


Hi.

There si finally an extension for thunderbird that enables user to 
compose mail in an external editor. 
Like Vim, or Gvim ;-)

I have been waiting for this for a looong time.
Sometimes I want to use very powerfull editor of my choice (Vim)
to format an email message and Copy and Paste sucks.

You can find it here:
http://globs.chez.tiscali.fr/moz_extensions/exteditor.html

It works also in W2000 (not only on XP and Linux as the author claims)

I couldn't make it work at first. 
You have to start a new massage, right click the toolbar and add icon for External Editor.
Now, when you click on the icon, your mail is displayed in Vim.

Have a nice day
Stanislav






VimTip	{{{1 852: Make support for NEC V850 CA850 compilers


This line will replace "make" with the "build" command when using ":make". 

" Use build.exe for making
set makeprg=build\ -script\ script.bld\ -XO\ build.err

NOTE: It directs the output to a file called "build.err" and assumes a script based build where the scriptname is "script.bld".

This line allows the error output from the build to be processed for display and linking back to the source.

" Find CA850 errors and warnings
set errorformat=%f\ %l\ %.%#rror:\ %t%n:%m,%f\ %l\ %.%#arning:\ %t%n:%m,%+Eld850:\ %.%#rror:\ %t%n:%m







VimTip	{{{1 853: Write a dated backup of the current file.


I sometimes find it useful to take a backup of the file I am currently editing
before continueing to edit the file.  Thats what this function is for :-)

Put this into your vimrc and press \ba while in normal mode, and the current
file will be backed up.

" A mapping to make a backup of the current file.
fun! WriteBackup()
        let fname = expand("%:p") . "__" . strftime("%Y_%m_%d_%H.%M.%S")
        silent exe ":w " . fname
        echo "Wrote " . fname
endfun
nnoremap <Leader>ba :call WriteBackup()<CR>







VimTip	{{{1 854: What seems to be a bug in Vim version 6.3. I hope it is OK to send here.


Hello,

I want to ask about what seems to be a bug in VIM version 6.3. I currently only tested it on _one_ Win XP installation. The bug does not appear in Vim 6.2, so maybe it is not a bug but an option...

Here is how to test it:
1. Start VIM
2. Enter this command. Use copy-paste. Do _not_ include the quotation marks:
"abbreviate bla +blabla|map! mm +|noremap! nn +"

3. Enter  insert  mode.

4. Type: blamm
-- The text will be replaced to:
-- +blabla+
as it should be (mm is mapped to +, and since + is not in the iskeyword group, the abbreviation bla is expanded to +blabla)

5. Type: blann
--- This time the text will be replaced to:
     bla+ (the bla abbreviation was not expanded to +blabla)
This is _not_ how it should be:

the only difference between the mapping of  'mm' and 'nn' is that in the first I used the 'map' command, while in the second I used the 'noremap' command.
However, noremap should prevent  nested expansion of mappings, not abbreviations.

In versions 6.2 and 6.1 of VIM, which I also have installed, this works fine.

If anyone is familiar with it, or I am missing something, please let me know.
If it is true, I will also send it to comp.editors newsgroup and to  bugs@vim.org.

Regards,

Jonathan Orlev







VimTip	{{{1 855: Automatically add closing brace to block when coding


I got fed up with having to add the closing brace to a code block, so I've got my Vim to automatically add a closing brace when coding in c#. Add the following to any appropriate ftplugin files (prefereably in vimfiles/ftplugin) so they don't get overwritten on upgrades.

The script will automatically add the closing brace and position the cursor on a line between the opening and closing braces. It ignores braces in comments, strings and if the word new is in the line (e.g. for string[] myArray = new string[] {"a", "b"}.

There are maps for enclosing code in a set of braces.

imap { <esc>:call ReplaceCurly()<Cr>cl

function! ReplaceCurly()
    imap { {
    " only replace outside of comments or strings (which map to constant)
    let elesyn = synIDtrans(synID(line("."), col(".") - 1, 0))
    if elesyn != hlID('Comment') && elesyn != hlID('Constant') && match(getline("."), "\\<new\\>") < 0
      exe "normal a{"
      " need to add a spare character (x) to position the cursor afterwards
      exe "normal ox"
      exe "normal o}"
      exe "normal kw"
    else
      " need to add a spare character (x) to position the cursor afterwards
      exe "normal a{x"
    endif
    imap { <esc>:let word= ReplaceCurly()<Cr>cl
endfunction

"Surround code with braces
nmap <leader>{} O{<esc>ddj>>ddkP
vmap <leader>{} <esc>o{<esc>ddgv>gvdp








VimTip	{{{1 856: syntax highlighting


(Originally posted in http://www.livejournal.com/community/vim_ers/3546.html)

I've just found a very nice feature of syntax highlighting in Vim.

Try this:
1. Create new file (for example, qwerty.txt).
2. Execute the following:

    :syntax on
    :syntax include @CPP syntax/cpp.vim
    :syntax region cppSnip matchgroup=Snip start="@begin=cpp@" end="@end=cpp@" contains=@CPP
    :hi link Snip SpecialComment

3. Now type in following text:

This is simple text; and this is C++:
@begin=cpp@
  int q;
  struct w { double e };
@end=cpp@

4. Now you have text between @begin=cpp@ and @end=cpp@ highlightied as C++, though filetype is not 'cpp'.

Isn't it magnificent?

-------------------------
Here is more useful version:

function! TextEnableCodeSnip(filetype,start,end) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  unlet b:current_syntax
  execute 'syntax region textSnip'.ft.'
    \ matchgroup=textSnip
    \ start="'.a:start.'" end="'.a:end.'"
    \ contains=@'.group
  hi link textSnip SpecialComment
endfunction

Now we can write something like:
  call TextEnableCodeSnip('c'   ,'@begin=c@'   ,'@end=c@'  )
  call TextEnableCodeSnip('cpp' ,'@begin=cpp@' ,'@end=cpp@')
  call TextEnableCodeSnip('sql' ,'@begin=sql@' ,'@end=sql@')
to enable highlighting of code pieces for c, cpp and sql.






VimTip	{{{1 857: syntax highlighting


(Originally posted in http://www.livejournal.com/community/vim_ers/3546.html)

I've just found a very nice feature of syntax highlighting in Vim.

Try this:
1. Create new file (for example, qwerty.txt).
2. Execute the following:

    :syntax on
    :syntax include @CPP syntax/cpp.vim
    :syntax region cppSnip matchgroup=Snip start="@begin=cpp@" end="@end=cpp@" contains=@CPP
    :hi link Snip SpecialComment

3. Now type in following text:

This is simple text; and this is C++:
@begin=cpp@
  int q;
  struct w { double e };
@end=cpp@

4. Now you have text between @begin=cpp@ and @end=cpp@ highlightied as C++, though filetype is not 'cpp'.

Isn't it magnificent?

-------------------------
Here is more useful version:

function! TextEnableCodeSnip(filetype,start,end) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  unlet b:current_syntax
  execute 'syntax region textSnip'.ft.'
    \ matchgroup=textSnip
    \ start="'.a:start.'" end="'.a:end.'"
    \ contains=@'.group
  hi link textSnip SpecialComment
endfunction

Now we can write something like:
  call TextEnableCodeSnip('c'   ,'@begin=c@'   ,'@end=c@'  )
  call TextEnableCodeSnip('cpp' ,'@begin=cpp@' ,'@end=cpp@')
  call TextEnableCodeSnip('sql' ,'@begin=sql@' ,'@end=sql@')
to enable highlighting of code pieces for c, cpp and sql.






VimTip	{{{1 858: Setting tags when working with multiple source branches.


This ~/_vimrc code will setup your tags variable, according to
the source tree you are working in. This is useful
when you have multiple source trees with duplicate tags
in each branch.

If you work in a single source tree, then you can hardcode 
:set tags=$SRC/tags and ignore this tip.

Example:

cd /a ; ctags -r .  # creates /a/tags
cd /k ; ctags -r .  # creates /k/tags
cd /x ; ctags -r .  # creates /x/tags

cd /x/y/z ; vim /a/b/c/d/e/f/h/i.c
:set tags
   tags=/a/tags,/x/y/tags  

cd /k/l/m ; vim i.c
:set tags
   tags=/k/tags  .. vim found the tags in parent of PWD and parent 

" put this code in your ~/_vimrc

" Your customised tags go first.
     set tags+=~/tags,$DOC/tags 

     let parent_dir = expand("%:p:h")."/"
     while match(parent_dir,"/",0)>-1 && isdirectory(parent_dir)
         let parent_tag = parent_dir."tags"
         if filereadable(parent_tag) 
            exe ":set tags+=".parent_tag
         endif
         let parent_dir = substitute(parent_dir,"[^/]*/$","","")
     endwhile

     let parent_dir = getcwd()."/"
     while match(parent_dir,"/",0)>-1 && isdirectory(parent_dir)
         let parent_tag = parent_dir."tags"
         if filereadable(parent_tag) 
            exe ":set tags+=".parent_tag
         endif
         let parent_dir = substitute(parent_dir,"[^/]*/$","","")
     endwhile
 
    unlet parent_dir parent_tag   









VimTip	{{{1 859: Remap % to show how many lines in between pairs


Add this line to your ~/.vimrc to have vim show how many lines you moved between when you hit the % key (which moves between matching pairs of characters, such as parenthesises and braces). The number of lines will be displayed at the bottom of the screen, positive for down, negative for up.

Especially useful when programming Java, C++, Perl, as % easily lets you count how many lines are in a method, class, or clause. Note that ^M needs to be typed as Ctrl+V, Ctrl+M.

" Count number of lines within this matching pair, print them
" when jumping between braces with %. Very useful. By shellreef.
nnoremap % :let line=line(".")^M%:echo line(".") - line^M








VimTip	{{{1 860: count number of matches of a pattern


mfyahya asked at #vim on freenode this question and I told him to try a simple substitude command such like :s/pattern/foo/g, to watch the status line and to press "u" (ndo) ;) Happy vimming!






VimTip	{{{1 861: Right click in Windows Explorer to open GVim in 'Ex;plorer Mode' on the current directory.


This may have been done before but maybe not.

There is a Windows 'reghack' that permits you to right click on a directory in Windows Explorer to open a command prompt at that same directory.  I''ve "hacked" it so as to open GVim in explorer mode at that directory.   You can then use the 'Explorer Mode' of GVim to navigate the directory and view or edit the files within.

! ---------- Windows XP / Windows 2000 / Winnt -----------------------
REGEDIT4

[HKEY_CLASSES_ROOT\Folder\shell\GVimHere]
@="gViM Here"

[HKEY_CLASSES_ROOT\Folder\shell\GVimHere\command]
@="C:\\Program Files\\Vim\\vim63\\gvim.exe ."

! ---------------------------------------------------------------------------------------

The following is the 'reghack' of the 'Command Prompt Here' for Windows 9x.  I haven't tried the alteration above on it, but I don't see why it wouldn't work.


! -------------------- Windows 9x --------------------------------------------------
REGEDIT4

[HKEY_CLASSES_ROOT\Directory\shell\DosHere]
@="Command &Prompt Here"

[HKEY_CLASSES_ROOT\Directory\shell\DosHere\command]
@="C:\\WINDOWS\\command.com /k cd \"%1\""

! ---------------------------------------------------------------------------------------

 - corp-mule








VimTip	{{{1 862: how to toggle between all vertical and all horizontal window layout


How to change from a horizontal list to a vertical list of windows, and vice versa:

---------------------------
horizontal list of windows
to vertical list of windows
---------------------------
    W|W|W
to
    W
    W  
    W

    :windo wincmd K

----------------------------
vertical list of windows
to horizonal list of windows
----------------------------
    W
    W  
    W
to
    W|W|W

  :windo wincmd H

This tip was written in response to a request in comp.editors and now shared in the vim-tip database.






